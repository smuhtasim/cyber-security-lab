[
  {
    "function_code": "public void displaysErrorWhenPasswordContravenesPolicy() {\n        //the only policy we can contravene by default is the length\n\n        String newPassword = new RandomValueStringGenerator(260).generate();\n\n        signIn(userEmail, PASSWORD);\n\n        changePassword(PASSWORD, newPassword, newPassword);\n        WebElement errorMessage = webDriver.findElement(By.className(\"error-message\"));\n        assertTrue(errorMessage.isDisplayed());\n        assertEquals(\"Password must be no more than 255 characters in length.\", errorMessage.getText());\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void displaysErrorWhenPasswordContravenesPolicy() {\n        //the only policy we can contravene by default is the length\n\n        String newPassword = new RandomValueStringGenerator(260).generate();\n        webDriver.get(baseUrl + \"/change_password\");\n        signIn(userEmail, PASSWORD);\n\n        changePassword(PASSWORD, newPassword, newPassword);\n        WebElement errorMessage = webDriver.findElement(By.className(\"error-message\"));\n        assertTrue(errorMessage.isDisplayed());\n        assertEquals(\"Password must be no more than 255 characters in length.\", errorMessage.getText());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void signIn(String userName, String password) {\n        webDriver.get(baseUrl + \"/logout.do\");\n        webDriver.get(baseUrl + \"/login\");\n        webDriver.findElement(By.name(\"username\")).sendKeys(userName);\n        webDriver.findElement(By.name(\"password\")).sendKeys(password);\n        webDriver.findElement(By.xpath(\"//input[@value='Sign in']\")).click();\n        assertThat(webDriver.findElement(By.cssSelector(\"h1\")).getText(), containsString(\"Where to?\"));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void signIn(String userName, String password) {\n        webDriver.findElement(By.name(\"username\")).sendKeys(userName);\n        webDriver.findElement(By.name(\"password\")).sendKeys(password);\n        webDriver.findElement(By.xpath(\"//input[@value='Sign in']\")).click();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void assertResponseAndCodeCorrect(String[] emails, String redirectUrl, String subdomain, InvitationsResponse response, ClientDetails clientDetails) {\n        for (int i = 0; i < emails.length; i++) {\n            assertThat(response.getNewInvites().size(), is(emails.length));\n            assertThat(response.getNewInvites().get(i).getEmail(), is(emails[i]));\n            assertThat(response.getNewInvites().get(i).getOrigin(), is(OriginKeys.UAA));\n            assertThat(response.getNewInvites().get(i).getUserId(), is(notNullValue()));\n            assertThat(response.getNewInvites().get(i).getErrorCode(), is(nullValue()));\n            assertThat(response.getNewInvites().get(i).getErrorMessage(), is(nullValue()));\n            String link = response.getNewInvites().get(i).getInviteLink().toString();\n            assertFalse(contains(link, \"@\"));\n            assertFalse(contains(link, \"%40\"));\n            if (StringUtils.hasText(subdomain)) {\n                assertThat(link, startsWith(\"http://\" + subdomain + \".localhost/invitations/accept\"));\n            } else {\n                assertThat(link, startsWith(\"http://localhost/invitations/accept\"));\n            }\n\n            String query = response.getNewInvites().get(i).getInviteLink().getQuery();\n            assertThat(query, startsWith(\"code=\"));\n            String code = query.split(\"=\")[1];\n            ExpiringCode expiringCode = codeStore.retrieveCode(code);\n            assertThat(expiringCode.getExpiresAt().getTime(), is(greaterThan(System.currentTimeMillis())));\n            assertThat(expiringCode.getIntent(), is(ExpiringCodeType.INVITATION.name()));\n            Map<String, String> data = readValue(expiringCode.getData(), new TypeReference<Map<String, String>>() {});\n            assertThat(data.get(InvitationConstants.USER_ID), is(notNullValue()));\n            assertThat(data.get(InvitationConstants.EMAIL), is(emails[i]));\n            assertThat(data.get(ORIGIN), is(OriginKeys.UAA));\n            assertThat(data.get(CLIENT_ID), is(clientDetails.getClientId()));\n            assertThat(data.get(REDIRECT_URI), is(redirectUrl));\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void assertResponseAndCodeCorrect(String[] emails, String redirectUrl, IdentityZone zone, InvitationsResponse response, ClientDetails clientDetails) {\n        for (int i = 0; i < emails.length; i++) {\n            assertThat(response.getNewInvites().size(), is(emails.length));\n            assertThat(response.getNewInvites().get(i).getEmail(), is(emails[i]));\n            assertThat(response.getNewInvites().get(i).getOrigin(), is(OriginKeys.UAA));\n            assertThat(response.getNewInvites().get(i).getUserId(), is(notNullValue()));\n            assertThat(response.getNewInvites().get(i).getErrorCode(), is(nullValue()));\n            assertThat(response.getNewInvites().get(i).getErrorMessage(), is(nullValue()));\n            String link = response.getNewInvites().get(i).getInviteLink().toString();\n            assertFalse(contains(link, \"@\"));\n            assertFalse(contains(link, \"%40\"));\n            if (zone != null && StringUtils.hasText(zone.getSubdomain())) {\n                assertThat(link, startsWith(\"http://\" + zone.getSubdomain() + \".localhost/invitations/accept\"));\n                IdentityZoneHolder.set(zone);\n            } else {\n                assertThat(link, startsWith(\"http://localhost/invitations/accept\"));\n            }\n\n            String query = response.getNewInvites().get(i).getInviteLink().getQuery();\n            assertThat(query, startsWith(\"code=\"));\n            String code = query.split(\"=\")[1];\n            ExpiringCode expiringCode = codeStore.retrieveCode(code);\n            IdentityZoneHolder.clear();\n            assertThat(expiringCode.getExpiresAt().getTime(), is(greaterThan(System.currentTimeMillis())));\n            assertThat(expiringCode.getIntent(), is(ExpiringCodeType.INVITATION.name()));\n            Map<String, String> data = readValue(expiringCode.getData(), new TypeReference<Map<String, String>>() {});\n            assertThat(data.get(InvitationConstants.USER_ID), is(notNullValue()));\n            assertThat(data.get(InvitationConstants.EMAIL), is(emails[i]));\n            assertThat(data.get(ORIGIN), is(OriginKeys.UAA));\n            assertThat(data.get(CLIENT_ID), is(clientDetails.getClientId()));\n            assertThat(data.get(REDIRECT_URI), is(redirectUrl));\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setMethods(Set<String> methods) {\n        this.methods = new HashSet<String>();\n        for (String method : methods) {\n            this.methods.add(method.toUpperCase());\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setMethods(Set<String> methods) {\n        this.methods = new HashSet<>();\n        for (String method : methods) {\n            this.methods.add(method.toUpperCase());\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public AuthorizationRequest createAuthorizationRequest(Map<String, String> authorizationParameters) {\n\n        String clientId = authorizationParameters.get(\"client_id\");\n        BaseClientDetails clientDetails = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId);\n        validateParameters(authorizationParameters, clientDetails);\n        Set<String> scopes = OAuth2Utils.parseParameterList(authorizationParameters.get(OAuth2Utils.SCOPE));\n        Set<String> responseTypes = OAuth2Utils.parseParameterList(authorizationParameters.get(OAuth2Utils.RESPONSE_TYPE));\n        String grantType = authorizationParameters.get(OAuth2Utils.GRANT_TYPE);\n        String state = authorizationParameters.get(OAuth2Utils.STATE);\n        String redirectUri = authorizationParameters.get(OAuth2Utils.REDIRECT_URI);\n        if ((scopes == null || scopes.isEmpty())) {\n            if (\"client_credentials\".equals(grantType)) {\n                // The client authorities should be a list of requestedScopes\n                scopes = AuthorityUtils.authorityListToSet(clientDetails.getAuthorities());\n            }\n            else {\n                // The default for a user token is the requestedScopes registered with\n                // the client\n                scopes = clientDetails.getScope();\n            }\n        }\n\n        Set<String> scopesFromExternalAuthorities = null;\n        if (!\"client_credentials\".equals(grantType) && securityContextAccessor.isUser()) {\n            String userId = securityContextAccessor.getUserId();\n            UaaUser uaaUser = uaaUserDatabase.retrieveUserById(userId);\n            Collection<? extends GrantedAuthority> authorities = uaaUser.getAuthorities();\n            //validate scopes\n            scopes = checkUserScopes(scopes, authorities, clientDetails);\n            //check client IDP relationship - allowed providers\n            checkClientIdpAuthorization(clientDetails, uaaUser);\n\n            // TODO: will the grantType ever contain client_credentials or\n            // authorization_code\n            // External Authorities are things like LDAP groups that will be\n            // mapped to Oauth requestedScopes\n            // Add those requestedScopes to the request. These requestedScopes will not be\n            // validated against the requestedScopes\n            // registered to a client.\n            // These requestedScopes also do not need approval. The fact that they are\n            // already in an external\n            // group communicates user approval. Denying approval does not mean\n            // much\n            scopesFromExternalAuthorities = findScopesFromAuthorities(authorizationParameters.get(\"authorities\"));\n        }\n\n        Set<String> resourceIds = getResourceIds(clientDetails, scopes);\n        clientDetails.setResourceIds(resourceIds);\n        Map<String, String> actualParameters = new HashMap<>(authorizationParameters);\n        if (scopesFromExternalAuthorities != null) {\n            actualParameters.put(\"external_scopes\",\n                            OAuth2Utils.formatParameterList(scopesFromExternalAuthorities));\n\n        }\n        AuthorizationRequest request = new AuthorizationRequest(\n            actualParameters,\n            null,\n            clientId,\n            scopes.isEmpty()?null:scopes,\n            null,\n            null,\n            false,\n            state,\n            redirectUri,\n            responseTypes\n        );\n        if (!scopes.isEmpty()) {\n            request.setScope(scopes);\n        }\n\n        request.setResourceIdsAndAuthoritiesFromClientDetails(clientDetails);\n\n        return request;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public AuthorizationRequest createAuthorizationRequest(Map<String, String> authorizationParameters) {\n\n        String clientId = authorizationParameters.get(\"client_id\");\n        BaseClientDetails clientDetails = (BaseClientDetails)clientDetailsService.loadClientByClientId(clientId);\n        validateParameters(authorizationParameters, clientDetails);\n        Set<String> scopes = OAuth2Utils.parseParameterList(authorizationParameters.get(OAuth2Utils.SCOPE));\n        Set<String> responseTypes = OAuth2Utils.parseParameterList(authorizationParameters.get(OAuth2Utils.RESPONSE_TYPE));\n        String grantType = authorizationParameters.get(OAuth2Utils.GRANT_TYPE);\n        String state = authorizationParameters.get(OAuth2Utils.STATE);\n        String redirectUri = authorizationParameters.get(OAuth2Utils.REDIRECT_URI);\n        if ((scopes == null || scopes.isEmpty())) {\n            if (\"client_credentials\".equals(grantType)) {\n                // The client authorities should be a list of requestedScopes\n                scopes = AuthorityUtils.authorityListToSet(clientDetails.getAuthorities());\n            }\n            else {\n                // The default for a user token is the requestedScopes registered with\n                // the client\n                scopes = clientDetails.getScope();\n            }\n        }\n\n        if (!\"client_credentials\".equals(grantType) && securityContextAccessor.isUser()) {\n            String userId = securityContextAccessor.getUserId();\n            UaaUser uaaUser = uaaUserDatabase.retrieveUserById(userId);\n            Collection<? extends GrantedAuthority> authorities = uaaUser.getAuthorities();\n            //validate scopes\n            scopes = checkUserScopes(scopes, authorities, clientDetails);\n            //check client IDP relationship - allowed providers\n            checkClientIdpAuthorization(clientDetails, uaaUser);\n        }\n\n        Set<String> resourceIds = getResourceIds(clientDetails, scopes);\n        clientDetails.setResourceIds(resourceIds);\n        Map<String, String> actualParameters = new HashMap<>(authorizationParameters);\n        AuthorizationRequest request = new AuthorizationRequest(\n            actualParameters,\n            null,\n            clientId,\n            scopes.isEmpty()?null:scopes,\n            null,\n            null,\n            false,\n            state,\n            redirectUri,\n            responseTypes\n        );\n        if (!scopes.isEmpty()) {\n            request.setScope(scopes);\n        }\n\n        request.setResourceIdsAndAuthoritiesFromClientDetails(clientDetails);\n\n        return request;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<Approval> updateClientApprovals(@PathVariable String clientId, @RequestBody Approval[] approvals) {\n        String currentUserId = getCurrentUserId();\n        logger.debug(\"Updating approvals for user: \" + currentUserId);\n        approvalStore.revokeApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n        for (Approval approval : approvals) {\n            if (approval.getUserId() !=null &&  !isValidUser(approval.getUserId())) {\n                logger.warn(String.format(\"Error[1] %s attemting to update approvals for %s.\", currentUserId, approval.getUserId()));\n                throw new UaaException(\"unauthorized_operation\", \"Cannot update approvals for another user. Set user_id to null to update for existing user.\",\n                        HttpStatus.UNAUTHORIZED.value());\n            } else {\n                approval.setUserId(currentUserId);\n            }\n            approval.setLastUpdatedAt(new Date());\n            approvalStore.addApproval(approval);\n        }\n        return approvalStore.getApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<Approval> updateClientApprovals(@PathVariable String clientId, @RequestBody Approval[] approvals) {\n        clientDetailsService.loadClientByClientId(clientId);\n        String currentUserId = getCurrentUserId();\n        logger.debug(\"Updating approvals for user: \" + currentUserId);\n        approvalStore.revokeApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n        for (Approval approval : approvals) {\n            if (approval.getUserId() !=null &&  !isValidUser(approval.getUserId())) {\n                logger.warn(String.format(\"Error[1] %s attemting to update approvals for %s.\", currentUserId, approval.getUserId()));\n                throw new UaaException(\"unauthorized_operation\", \"Cannot update approvals for another user. Set user_id to null to update for existing user.\",\n                        HttpStatus.UNAUTHORIZED.value());\n            } else {\n                approval.setUserId(currentUserId);\n            }\n            approval.setLastUpdatedAt(new Date());\n            approvalStore.addApproval(approval);\n        }\n        return approvalStore.getApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void resetPassword_InvalidPasswordException_NewPasswordSameAsOld() {\n        ScimUser user = new ScimUser(\"user-id\", \"username\", \"firstname\", \"lastname\");\n        user.setMeta(new ScimMeta(new Date(), new Date(), 0));\n        user.setPrimaryEmail(\"foo@example.com\");\n        ExpiringCode expiringCode = new ExpiringCode(\"good_code\",\n            new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME), \"user-id\", null);\n        when(codeStore.retrieveCode(\"good_code\")).thenReturn(expiringCode);\n        when(scimUserProvisioning.retrieve(\"user-id\")).thenReturn(user);\n        when(scimUserProvisioning.checkPasswordMatches(\"user-id\", \"Passwo3dAsOld\"))\n            .thenThrow(new InvalidPasswordException(\"Your new password cannot be the same as the old password.\", UNPROCESSABLE_ENTITY));\n        SecurityContext securityContext = mock(SecurityContext.class);\n        when(securityContext.getAuthentication()).thenReturn(new MockAuthentication());\n        SecurityContextHolder.setContext(securityContext);\n        try {\n            emailResetPasswordService.resetPassword(\"good_code\", \"Passwo3dAsOld\");\n            fail();\n        } catch (InvalidPasswordException e) {\n            assertEquals(\"Your new password cannot be the same as the old password.\", e.getMessage());\n            assertEquals(UNPROCESSABLE_ENTITY, e.getStatus());\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void resetPassword_InvalidPasswordException_NewPasswordSameAsOld() {\n        ScimUser user = new ScimUser(\"user-id\", \"username\", \"firstname\", \"lastname\");\n        user.setMeta(new ScimMeta(new Date(), new Date(), 0));\n        user.setPrimaryEmail(\"foo@example.com\");\n        ExpiringCode expiringCode = new ExpiringCode(\"good_code\",\n            new Timestamp(System.currentTimeMillis() + UaaResetPasswordService.PASSWORD_RESET_LIFETIME), \"{\\\"user_id\\\":\\\"user-id\\\",\\\"username\\\":\\\"username\\\",\\\"passwordModifiedTime\\\":null,\\\"client_id\\\":\\\"\\\",\\\"redirect_uri\\\":\\\"\\\"}\", null);\n        when(codeStore.retrieveCode(\"good_code\")).thenReturn(expiringCode);\n        when(scimUserProvisioning.retrieve(\"user-id\")).thenReturn(user);\n        when(scimUserProvisioning.checkPasswordMatches(\"user-id\", \"Passwo3dAsOld\"))\n            .thenThrow(new InvalidPasswordException(\"Your new password cannot be the same as the old password.\", UNPROCESSABLE_ENTITY));\n        SecurityContext securityContext = mock(SecurityContext.class);\n        when(securityContext.getAuthentication()).thenReturn(new MockAuthentication());\n        SecurityContextHolder.setContext(securityContext);\n        try {\n            emailResetPasswordService.resetPassword(\"good_code\", \"Passwo3dAsOld\");\n            fail();\n        } catch (InvalidPasswordException e) {\n            assertEquals(\"Your new password cannot be the same as the old password.\", e.getMessage());\n            assertEquals(UNPROCESSABLE_ENTITY, e.getStatus());\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private MockHttpServletRequestBuilder startAcceptInviteFlow(String password) {\n        UaaPrincipal uaaPrincipal = new UaaPrincipal(\"user-id-001\", \"user@example.com\", \"user@example.com\", OriginKeys.UAA, null, IdentityZoneHolder.get().getId());\n        UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(uaaPrincipal, null, UaaAuthority.USER_AUTHORITIES);\n        SecurityContextHolder.getContext().setAuthentication(token);\n\n        return post(\"/invitations/accept.do\")\n            .param(\"code\",\"thecode\")\n            .param(\"password\", password)\n            .param(\"password_confirmation\", password);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private MockHttpServletRequestBuilder startAcceptInviteFlow(String password, String confirmPassword) {\n        UaaPrincipal uaaPrincipal = new UaaPrincipal(\"user-id-001\", \"user@example.com\", \"user@example.com\", OriginKeys.UAA, null, IdentityZoneHolder.get().getId());\n        UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(uaaPrincipal, null, UaaAuthority.USER_AUTHORITIES);\n        SecurityContextHolder.getContext().setAuthentication(token);\n\n        return post(\"/invitations/accept.do\")\n            .param(\"code\",\"thecode\")\n            .param(\"password\", password)\n            .param(\"password_confirmation\", confirmPassword);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void readAccessToken(Set<String> excludedClaims) {\n        tokenServices.setExcludedClaims(excludedClaims);\n        AuthorizationRequest authorizationRequest =new AuthorizationRequest(CLIENT_ID, tokenSupport.requestedAuthScopes);\n        authorizationRequest.setResourceIds(new HashSet<>(tokenSupport.resourceIds));\n        Map<String, String> azParameters = new HashMap<>(authorizationRequest.getRequestParameters());\n        azParameters.put(GRANT_TYPE, AUTHORIZATION_CODE);\n        authorizationRequest.setRequestParameters(azParameters);\n        Authentication userAuthentication = tokenSupport.defaultUserAuthentication;\n\n        Calendar expiresAt = Calendar.getInstance();\n        expiresAt.add(Calendar.MILLISECOND, 3000);\n        Calendar updatedAt = Calendar.getInstance();\n        updatedAt.add(Calendar.MILLISECOND, -1000);\n\n        tokenSupport.approvalStore.addApproval(new Approval()\n            .setUserId(tokenSupport.userId)\n            .setClientId(CLIENT_ID)\n            .setScope(tokenSupport.readScope.get(0))\n            .setExpiresAt(expiresAt.getTime())\n            .setStatus(ApprovalStatus.APPROVED)\n            .setLastUpdatedAt(updatedAt.getTime()), IdentityZoneHolder.get().getId());\n        tokenSupport.approvalStore.addApproval(new Approval()\n            .setUserId(tokenSupport.userId)\n            .setClientId(CLIENT_ID)\n            .setScope(tokenSupport.writeScope.get(0))\n            .setExpiresAt(expiresAt.getTime())\n            .setStatus(ApprovalStatus.APPROVED)\n            .setLastUpdatedAt(updatedAt.getTime()), IdentityZoneHolder.get().getId());\n        Approval approval = new Approval()\n            .setUserId(tokenSupport.userId)\n            .setClientId(CLIENT_ID)\n            .setScope(OPENID)\n            .setExpiresAt(expiresAt.getTime())\n            .setStatus(ApprovalStatus.APPROVED)\n            .setLastUpdatedAt(updatedAt.getTime());\n        tokenSupport.approvalStore.addApproval(\n            approval, IdentityZoneHolder.get().getId());\n\n        OAuth2Authentication authentication = new OAuth2Authentication(authorizationRequest.createOAuth2Request(), userAuthentication);\n        OAuth2AccessToken accessToken = tokenServices.createAccessToken(authentication);\n        assertEquals(accessToken, tokenServices.readAccessToken(accessToken.getValue()));\n\n        tokenSupport.approvalStore.revokeApproval(approval, IdentityZoneHolder.get().getId());\n        try {\n            tokenServices.readAccessToken(accessToken.getValue());\n            fail(\"Approval has been revoked\");\n        } catch (InvalidTokenException x) {\n            assertThat(\"Exception should be about approvals\", x.getMessage().contains(\"some requested scopes are not approved\"));\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void readAccessToken(Set<String> excludedClaims) {\n        tokenServices.setExcludedClaims(excludedClaims);\n        AuthorizationRequest authorizationRequest =new AuthorizationRequest(CLIENT_ID, tokenSupport.requestedAuthScopes);\n        authorizationRequest.setResourceIds(new HashSet<>(tokenSupport.resourceIds));\n        Map<String, String> azParameters = new HashMap<>(authorizationRequest.getRequestParameters());\n        azParameters.put(GRANT_TYPE, AUTHORIZATION_CODE);\n        authorizationRequest.setRequestParameters(azParameters);\n        Authentication userAuthentication = tokenSupport.defaultUserAuthentication;\n\n        Calendar expiresAt = Calendar.getInstance();\n        expiresAt.add(Calendar.MILLISECOND, 3000);\n        Calendar updatedAt = Calendar.getInstance();\n        updatedAt.add(Calendar.MILLISECOND, -1000);\n\n        tokenSupport.approvalStore.addApproval(new Approval()\n            .setUserId(tokenSupport.userId)\n            .setClientId(CLIENT_ID)\n            .setScope(tokenSupport.readScope.get(0))\n            .setExpiresAt(expiresAt.getTime())\n            .setStatus(ApprovalStatus.APPROVED)\n            .setLastUpdatedAt(updatedAt.getTime()), IdentityZoneHolder.get().getId());\n        tokenSupport.approvalStore.addApproval(new Approval()\n            .setUserId(tokenSupport.userId)\n            .setClientId(CLIENT_ID)\n            .setScope(tokenSupport.writeScope.get(0))\n            .setExpiresAt(expiresAt.getTime())\n            .setStatus(ApprovalStatus.APPROVED)\n            .setLastUpdatedAt(updatedAt.getTime()), IdentityZoneHolder.get().getId());\n        Approval approval = new Approval()\n            .setUserId(tokenSupport.userId)\n            .setClientId(CLIENT_ID)\n            .setScope(OPENID)\n            .setExpiresAt(expiresAt.getTime())\n            .setStatus(ApprovalStatus.APPROVED)\n            .setLastUpdatedAt(updatedAt.getTime());\n        tokenSupport.approvalStore.addApproval(\n            approval, IdentityZoneHolder.get().getId());\n\n        OAuth2Authentication authentication = new OAuth2Authentication(authorizationRequest.createOAuth2Request(), userAuthentication);\n        OAuth2AccessToken accessToken = tokenServices.createAccessToken(authentication);\n        assertEquals(accessToken, tokenServices.readAccessToken(accessToken.getValue()));\n\n        tokenSupport.approvalStore.revokeApproval(approval, IdentityZoneHolder.get().getId());\n        try {\n            tokenServices.readAccessToken(accessToken.getValue());\n            fail(\"Approval has been revoked\");\n        } catch (InvalidTokenException x) {\n            assertThat(\"Exception should be about approvals\", x.getMessage().contains(\"some requested scopes are not approved\"));\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void loadAuthentication_when_given_an_opaque_refreshToken_should_throw_exception() {\n        tokenSupport.defaultClient.setAutoApproveScopes(singleton(\"true\"));\n        AuthorizationRequest authorizationRequest = new AuthorizationRequest(CLIENT_ID,tokenSupport.requestedAuthScopes);\n        authorizationRequest.setResponseTypes(new HashSet(Arrays.asList(\"token\")));\n        authorizationRequest.setResourceIds(new HashSet<>(tokenSupport.resourceIds));\n        Map<String, String> azParameters = new HashMap<>(authorizationRequest.getRequestParameters());\n        azParameters.put(GRANT_TYPE, AUTHORIZATION_CODE);\n\n        azParameters.put(REQUEST_TOKEN_FORMAT, TokenConstants.OPAQUE);\n\n        authorizationRequest.setRequestParameters(azParameters);\n        Authentication userAuthentication = tokenSupport.defaultUserAuthentication;\n\n        OAuth2Authentication authentication = new OAuth2Authentication(authorizationRequest.createOAuth2Request(), userAuthentication);\n        OAuth2AccessToken compositeToken = tokenServices.createAccessToken(authentication);\n\n        String refreshTokenValue = tokenProvisioning.retrieve(compositeToken.getRefreshToken().getValue(), IdentityZoneHolder.get().getId()).getValue();\n\n        expectedException.expect(InvalidTokenException.class);\n        expectedException.expectMessage(\"Invalid access token was provided.\");\n\n        tokenServices.loadAuthentication(refreshTokenValue);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void loadAuthentication_when_given_an_opaque_refreshToken_should_throw_exception() {\n        tokenSupport.defaultClient.setAutoApproveScopes(singleton(\"true\"));\n        AuthorizationRequest authorizationRequest = new AuthorizationRequest(CLIENT_ID,tokenSupport.requestedAuthScopes);\n        authorizationRequest.setResponseTypes(new HashSet(Arrays.asList(\"token\")));\n        authorizationRequest.setResourceIds(new HashSet<>(tokenSupport.resourceIds));\n        Map<String, String> azParameters = new HashMap<>(authorizationRequest.getRequestParameters());\n        azParameters.put(GRANT_TYPE, AUTHORIZATION_CODE);\n\n        azParameters.put(REQUEST_TOKEN_FORMAT, TokenConstants.OPAQUE);\n\n        authorizationRequest.setRequestParameters(azParameters);\n        Authentication userAuthentication = tokenSupport.defaultUserAuthentication;\n\n        OAuth2Authentication authentication = new OAuth2Authentication(authorizationRequest.createOAuth2Request(), userAuthentication);\n        OAuth2AccessToken compositeToken = tokenServices.createAccessToken(authentication);\n\n        String refreshTokenValue = tokenProvisioning.retrieve(compositeToken.getRefreshToken().getValue(), IdentityZoneHolder.get().getId()).getValue();\n\n        expectedException.expect(InvalidTokenException.class);\n        expectedException.expectMessage(\"Invalid access token.\");\n\n        tokenServices.loadAuthentication(refreshTokenValue);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void loadAuthentication_when_given_an_refresh_jwt_should_throw_exception() {\n        IdentityZoneHolder.get().getConfig().getTokenPolicy().setJwtRevocable(true);\n        tokenSupport.defaultClient.setAutoApproveScopes(singleton(\"true\"));\n        AuthorizationRequest authorizationRequest = new AuthorizationRequest(CLIENT_ID,tokenSupport.requestedAuthScopes);\n        authorizationRequest.setResponseTypes(new HashSet(Arrays.asList(\"token\")));\n        authorizationRequest.setResourceIds(new HashSet<>(tokenSupport.resourceIds));\n        Map<String, String> azParameters = new HashMap<>(authorizationRequest.getRequestParameters());\n        azParameters.put(GRANT_TYPE, AUTHORIZATION_CODE);\n\n        azParameters.put(REQUEST_TOKEN_FORMAT, JWT.getStringValue());\n\n        authorizationRequest.setRequestParameters(azParameters);\n        Authentication userAuthentication = tokenSupport.defaultUserAuthentication;\n\n        OAuth2Authentication authentication = new OAuth2Authentication(authorizationRequest.createOAuth2Request(), userAuthentication);\n        OAuth2AccessToken compositeToken = tokenServices.createAccessToken(authentication);\n        TokenValidation refreshToken = tokenServices.validateToken(compositeToken.getRefreshToken().getValue());\n\n        String refreshTokenValue = tokenProvisioning.retrieve(refreshToken.getClaims().get(\"jti\").toString(), IdentityZoneHolder.get().getId()).getValue();\n\n        expectedException.expect(InvalidTokenException.class);\n        expectedException.expectMessage(\"Invalid access token was provided.\");\n        tokenServices.loadAuthentication(refreshTokenValue);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void loadAuthentication_when_given_an_refresh_jwt_should_throw_exception() {\n        IdentityZoneHolder.get().getConfig().getTokenPolicy().setJwtRevocable(true);\n        tokenSupport.defaultClient.setAutoApproveScopes(singleton(\"true\"));\n        AuthorizationRequest authorizationRequest = new AuthorizationRequest(CLIENT_ID,tokenSupport.requestedAuthScopes);\n        authorizationRequest.setResponseTypes(new HashSet(Arrays.asList(\"token\")));\n        authorizationRequest.setResourceIds(new HashSet<>(tokenSupport.resourceIds));\n        Map<String, String> azParameters = new HashMap<>(authorizationRequest.getRequestParameters());\n        azParameters.put(GRANT_TYPE, AUTHORIZATION_CODE);\n\n        azParameters.put(REQUEST_TOKEN_FORMAT, JWT.getStringValue());\n\n        authorizationRequest.setRequestParameters(azParameters);\n        Authentication userAuthentication = tokenSupport.defaultUserAuthentication;\n\n        OAuth2Authentication authentication = new OAuth2Authentication(authorizationRequest.createOAuth2Request(), userAuthentication);\n        OAuth2AccessToken compositeToken = tokenServices.createAccessToken(authentication);\n        TokenValidation refreshToken = tokenServices.validateToken(compositeToken.getRefreshToken().getValue());\n\n        String refreshTokenValue = tokenProvisioning.retrieve(refreshToken.getClaims().get(\"jti\").toString(), IdentityZoneHolder.get().getId()).getValue();\n\n        expectedException.expect(InvalidTokenException.class);\n        expectedException.expectMessage(\"Invalid access token.\");\n        tokenServices.loadAuthentication(refreshTokenValue);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected String comparisonClause(SCIMFilter filter, String comparator, Map<String, Object> values, String valuePrefix, String valueSuffix, String paramPrefix) {\n        String pName = getParamName(values, paramPrefix);\n        String paramName = \":\"+pName;\n        if (filter.getFilterValue() == null) {\n            return getAttributeName(filter, mapper) + \" IS NULL\";\n        } else if (filter.isQuoteFilterValue()) {\n            Object value = getStringOrDate(filter.getFilterValue());\n            if (value instanceof String) {\n                //lower is used to satisfy the requirement that all quoted values are compared case insensitive\n                switch (filter.getFilterAttribute().getAttributeName().toLowerCase()) {\n                    case \"client_secret\" :\n                    case \"password\" :\n                    case \"salt\" :\n                        value = \"\";\n                    default:\n                        break;\n                }\n                values.put(pName, valuePrefix+value+valueSuffix);\n                if (isDbCaseInsensitive()) {\n                    return \"\" + getAttributeName(filter, mapper) + \" \"+comparator+\" \" + paramName+\"\";\n                } else {\n                    return \"LOWER(\" + getAttributeName(filter, mapper) + \") \" + comparator + \" LOWER(\" + paramName + \")\";\n                }\n            } else {\n                values.put(pName, value);\n                return getAttributeName(filter, mapper) + \" \"+comparator+\" \" + paramName;\n            }\n        } else {\n            try {\n                values.put(pName, Double.parseDouble(filter.getFilterValue()));\n            } catch (NumberFormatException x) {\n                if (\"true\".equalsIgnoreCase(filter.getFilterValue())) {\n                    values.put(pName, Boolean.TRUE);\n                } else if (\"false\".equalsIgnoreCase(filter.getFilterValue())) {\n                    values.put(pName, Boolean.FALSE);\n                } else {\n                    throw new IllegalArgumentException(\"Invalid non quoted value [\"+filter.getFilterAttribute()+\n                        \" : \"+filter.getFilterValue()+\"]\");\n                }\n            }\n            return getAttributeName(filter, mapper) + \" \"+comparator+\" \" + paramName;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected String comparisonClause(SCIMFilter filter,\n                                      String comparator,\n                                      Map<String, Object> values,\n                                      String valuePrefix,\n                                      String valueSuffix,\n                                      String paramPrefix) {\n        String pName = getParamName(values, paramPrefix);\n        String paramName = \":\"+pName;\n        if (filter.getFilterValue() == null) {\n            return getAttributeName(filter, mapper) + \" IS NULL\";\n        } else if (filter.isQuoteFilterValue()) {\n            Object value = getStringOrDate(filter.getFilterValue());\n            if (value instanceof String) {\n                //lower is used to satisfy the requirement that all quoted values are compared case insensitive\n                switch (filter.getFilterAttribute().getAttributeName().toLowerCase()) {\n                    case \"client_secret\" :\n                    case \"password\" :\n                    case \"salt\" :\n                        value = \"\";\n                    default:\n                        break;\n                }\n                values.put(pName, valuePrefix+value+valueSuffix);\n                if (isDbCaseInsensitive()) {\n                    return \"\" + getAttributeName(filter, mapper) + \" \"+comparator+\" \" + paramName+\"\";\n                } else {\n                    return \"LOWER(\" + getAttributeName(filter, mapper) + \") \" + comparator + \" LOWER(\" + paramName + \")\";\n                }\n            } else {\n                values.put(pName, value);\n                return getAttributeName(filter, mapper) + \" \"+comparator+\" \" + paramName;\n            }\n        } else {\n            try {\n                values.put(pName, Double.parseDouble(filter.getFilterValue()));\n            } catch (NumberFormatException x) {\n                if (\"true\".equalsIgnoreCase(filter.getFilterValue())) {\n                    values.put(pName, Boolean.TRUE);\n                } else if (\"false\".equalsIgnoreCase(filter.getFilterValue())) {\n                    values.put(pName, Boolean.FALSE);\n                } else {\n                    throw new IllegalArgumentException(\"Invalid non quoted value [\"+filter.getFilterAttribute()+\n                        \" : \"+filter.getFilterValue()+\"]\");\n                }\n            }\n            return getAttributeName(filter, mapper) + \" \"+comparator+\" \" + paramName;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<Approval> updateClientApprovals(@PathVariable String clientId, @RequestBody Approval[] approvals) {\n        String currentUserId = getCurrentUserId();\n        logger.debug(\"Updating approvals for user: \" + currentUserId);\n        approvalStore.revokeApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n        for (Approval approval : approvals) {\n            if (StringUtils.hasText(approval.getUserId()) && !isValidUser(approval.getUserId())) {\n                logger.warn(String.format(\"Error[1] %s attemting to update approvals for %s.\", currentUserId, approval.getUserId()));\n                throw new UaaException(\"unauthorized_operation\", \"Cannot update approvals for another user. Set user_id to null to update for existing user.\",\n                        HttpStatus.UNAUTHORIZED.value());\n            } else {\n                approval.setUserId(currentUserId);\n            }\n            approvalStore.addApproval(approval);\n        }\n        return approvalStore.getApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<Approval> updateClientApprovals(@PathVariable String clientId, @RequestBody Approval[] approvals) {\n        clientDetailsService.loadClientByClientId(clientId);\n        String currentUserId = getCurrentUserId();\n        logger.debug(\"Updating approvals for user: \" + currentUserId);\n        approvalStore.revokeApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n        for (Approval approval : approvals) {\n            if (StringUtils.hasText(approval.getUserId()) && !isValidUser(approval.getUserId())) {\n                logger.warn(String.format(\"Error[1] %s attemting to update approvals for %s.\", currentUserId, approval.getUserId()));\n                throw new UaaException(\"unauthorized_operation\", \"Cannot update approvals for another user. Set user_id to null to update for existing user.\",\n                        HttpStatus.UNAUTHORIZED.value());\n            } else {\n                approval.setUserId(currentUserId);\n            }\n            approvalStore.addApproval(approval);\n        }\n        return approvalStore.getApprovals(String.format(USER_AND_CLIENT_FILTER_TEMPLATE, currentUserId, clientId));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public LockoutPolicy getLockoutPolicy() {\n        LockoutPolicy res = IdentityZoneHolder.get().getConfig().getClientLockoutPolicy();\n        return res.getLockoutAfterFailures() != -1 ? res : defaultLockoutPolicy;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public LockoutPolicy getLockoutPolicy() {\n        if(isEnabled) {\n            LockoutPolicy res = IdentityZoneHolder.get().getConfig().getClientLockoutPolicy();\n            return res.getLockoutAfterFailures() != -1 ? res : defaultLockoutPolicy;\n        } else {\n            return disabledLockoutPolicy;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Result isAllowed(String principalId) {\n        LockoutPolicy lockoutPolicy = lockoutPolicyRetriever.getLockoutPolicy();\n\n        if (!lockoutPolicy.isLockoutEnabled()) {\n            return new Result(true, 0);\n        }\n\n        long eventsAfter = timeService.getCurrentTimeMillis() - lockoutPolicy.getCountFailuresWithin() * 1000;\n        List<AuditEvent> events = auditService.find(principalId, eventsAfter);\n\n        final int failureCount = sequentialFailureCount(events);\n\n        if (failureCount >= lockoutPolicy.getLockoutAfterFailures()) {\n            // Check whether time of most recent failure is within the lockout period\n            AuditEvent lastFailure = mostRecentFailure(events);\n            if (lastFailure != null && lastFailure.getTime() > timeService.getCurrentTimeMillis() - lockoutPolicy.getLockoutPeriodSeconds() * 1000) {\n                return new Result(false, failureCount);\n            }\n        }\n        return new Result(true, failureCount);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Result isAllowed(String principalId) {\n        LockoutPolicy lockoutPolicy = lockoutPolicyRetriever.getLockoutPolicy();\n\n        long eventsAfter = timeService.getCurrentTimeMillis() - lockoutPolicy.getCountFailuresWithin() * 1000;\n        List<AuditEvent> events = auditService.find(principalId, eventsAfter);\n\n        final int failureCount = sequentialFailureCount(events);\n\n        if (failureCount >= lockoutPolicy.getLockoutAfterFailures()) {\n            // Check whether time of most recent failure is within the lockout period\n            AuditEvent lastFailure = mostRecentFailure(events);\n            if (lastFailure != null && lastFailure.getTime() > timeService.getCurrentTimeMillis() - lockoutPolicy.getLockoutPeriodSeconds() * 1000) {\n                return new Result(false, failureCount);\n            }\n        }\n        return new Result(true, failureCount);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean isUaaManagedUser(Authentication authentication) {\n        if (authentication.getPrincipal() instanceof UaaPrincipal) {\n            UaaPrincipal principal = (UaaPrincipal) authentication.getPrincipal();\n            return OriginKeys.UAA.equals(principal.getOrigin());\n        }\n        return false;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean isUaaManagedUser(Authentication authentication) {\n        if (authentication.getPrincipal() instanceof UaaPrincipal) {\n            UaaPrincipal principal = (UaaPrincipal) authentication.getPrincipal();\n            return OriginKeys.UAA.equals(principal.getOrigin());\n        }\n        return false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private ResetPasswordResponse changePasswordCodeAuthenticated(String code, String newPassword) {\n        ExpiringCode expiringCode = expiringCodeStore.retrieveCode(code);\n        if (expiringCode == null) {\n            throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n        }\n        String userId;\n        String userName = null;\n        Date passwordLastModified = null;\n        String clientId = null;\n        String redirectUri = null;\n        try {\n            PasswordChange change = JsonUtils.readValue(expiringCode.getData(), PasswordChange.class);\n            userId = change.getUserId();\n            userName = change.getUsername();\n            passwordLastModified = change.getPasswordModifiedTime();\n            clientId = change.getClientId();\n            redirectUri = change.getRedirectUri();\n        } catch (JsonUtils.JsonUtilException x) {\n            userId = expiringCode.getData();\n        }\n        ScimUser user = scimUserProvisioning.retrieve(userId);\n        try {\n            if (isUserModified(user, expiringCode.getExpiresAt(), userName, passwordLastModified)) {\n                throw new UaaException(\"Invalid password reset request.\");\n            }\n            if (!user.isVerified()) {\n                scimUserProvisioning.verifyUser(userId, -1);\n            }\n            if (scimUserProvisioning.checkPasswordMatches(userId, newPassword)) {\n                throw new InvalidPasswordException(\"Your new password cannot be the same as the old password.\", UNPROCESSABLE_ENTITY);\n            }\n            scimUserProvisioning.changePassword(userId, null, newPassword);\n            publish(new PasswordChangeEvent(\"Password changed\", getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n\n            String redirectLocation = \"home\";\n            if (!isEmpty(clientId) && !isEmpty(redirectUri)) {\n                try {\n                    ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n                    Set<String> redirectUris = clientDetails.getRegisteredRedirectUri() == null ? Collections.emptySet() :\n                        clientDetails.getRegisteredRedirectUri();\n                    String matchingRedirectUri = UaaUrlUtils.findMatchingRedirectUri(redirectUris, redirectUri, null);\n                    if (matchingRedirectUri != null) {\n                        redirectLocation = matchingRedirectUri;\n                    }\n                } catch (NoSuchClientException nsce) {}\n            }\n            return new ResetPasswordResponse(user, redirectLocation, clientId);\n        } catch (Exception e) {\n            publish(new PasswordChangeFailureEvent(e.getMessage(), getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n            throw e;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private ResetPasswordResponse changePasswordCodeAuthenticated(String code, String newPassword) {\n        ExpiringCode expiringCode = expiringCodeStore.retrieveCode(code);\n        if (expiringCode == null) {\n            throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n        }\n        String userId;\n        String userName;\n        Date passwordLastModified;\n        String clientId;\n        String redirectUri;\n        PasswordChange change;\n        try {\n            change = JsonUtils.readValue(expiringCode.getData(), PasswordChange.class);\n        } catch (JsonUtils.JsonUtilException x) {\n            throw new InvalidCodeException(\"invalid_code\", \"Sorry, your reset password link is no longer valid. Please request a new one\", 422);\n        }\n        userId = change.getUserId();\n        userName = change.getUsername();\n        passwordLastModified = change.getPasswordModifiedTime();\n        clientId = change.getClientId();\n        redirectUri = change.getRedirectUri();\n\n        ScimUser user = scimUserProvisioning.retrieve(userId);\n        try {\n            if (isUserModified(user, expiringCode.getExpiresAt(), userName, passwordLastModified)) {\n                throw new UaaException(\"Invalid password reset request.\");\n            }\n            if (!user.isVerified()) {\n                scimUserProvisioning.verifyUser(userId, -1);\n            }\n            if (scimUserProvisioning.checkPasswordMatches(userId, newPassword)) {\n                throw new InvalidPasswordException(\"Your new password cannot be the same as the old password.\", UNPROCESSABLE_ENTITY);\n            }\n            scimUserProvisioning.changePassword(userId, null, newPassword);\n            publish(new PasswordChangeEvent(\"Password changed\", getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n\n            String redirectLocation = \"home\";\n            if (!isEmpty(clientId) && !isEmpty(redirectUri)) {\n                try {\n                    ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n                    Set<String> redirectUris = clientDetails.getRegisteredRedirectUri() == null ? Collections.emptySet() :\n                        clientDetails.getRegisteredRedirectUri();\n                    String matchingRedirectUri = UaaUrlUtils.findMatchingRedirectUri(redirectUris, redirectUri, null);\n                    if (matchingRedirectUri != null) {\n                        redirectLocation = matchingRedirectUri;\n                    }\n                } catch (NoSuchClientException nsce) {}\n            }\n            return new ResetPasswordResponse(user, redirectLocation, clientId);\n        } catch (Exception e) {\n            publish(new PasswordChangeFailureEvent(e.getMessage(), getUaaUser(user), SecurityContextHolder.getContext().getAuthentication()));\n            throw e;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ExpiringCode generateCode(String data, Timestamp expiresAt, String intent) {\n        cleanExpiredEntries();\n\n        if (data == null || expiresAt == null) {\n            throw new NullPointerException();\n        }\n\n        if (expiresAt.getTime() < System.currentTimeMillis()) {\n            throw new IllegalArgumentException();\n        }\n\n        int count = 0;\n        while (count < 3) {\n            count++;\n            String code = generator.generate();\n            try {\n                int update = jdbcTemplate.update(insert, code, expiresAt.getTime(), data, intent);\n                if (update == 1) {\n                    ExpiringCode expiringCode = new ExpiringCode(code, expiresAt, data, intent);\n                    return expiringCode;\n                } else {\n                    logger.warn(\"Unable to store expiring code:\" + code);\n                }\n            } catch (DataIntegrityViolationException x) {\n                if (count == 3) {\n                    throw x;\n                }\n            }\n        }\n\n        return null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ExpiringCode generateCode(String data, Timestamp expiresAt, String intent) {\n        cleanExpiredEntries();\n\n        if (data == null || expiresAt == null) {\n            throw new NullPointerException();\n        }\n\n        if (expiresAt.getTime() < System.currentTimeMillis()) {\n            throw new IllegalArgumentException();\n        }\n\n        int count = 0;\n        while (count < 3) {\n            count++;\n            String code = generator.generate();\n            try {\n                int update = jdbcTemplate.update(insert, zonifyCode(code), expiresAt.getTime(), data, intent);\n                if (update == 1) {\n                    ExpiringCode expiringCode = new ExpiringCode(code, expiresAt, data, intent);\n                    return expiringCode;\n                } else {\n                    logger.warn(\"Unable to store expiring code:\" + code);\n                }\n            } catch (DataIntegrityViolationException x) {\n                if (count == 3) {\n                    throw x;\n                }\n            }\n        }\n\n        return null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ExpiringCode retrieveCode(String code) {\n        cleanExpiredEntries();\n\n        if (code == null) {\n            throw new NullPointerException();\n        }\n\n        try {\n            ExpiringCode expiringCode = jdbcTemplate.queryForObject(select, new JdbcExpiringCodeMapper(), code);\n            try {\n                if (expiringCode != null) {\n                    jdbcTemplate.update(delete, code);\n                }\n                if (expiringCode.getExpiresAt().getTime() < System.currentTimeMillis()) {\n                    expiringCode = null;\n                }\n            } finally {\n                return expiringCode;\n            }\n        } catch (EmptyResultDataAccessException x) {\n            return null;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ExpiringCode retrieveCode(String code) {\n        cleanExpiredEntries();\n\n        if (code == null) {\n            throw new NullPointerException();\n        }\n\n        try {\n            ExpiringCode expiringCode = jdbcTemplate.queryForObject(selectAllFields, rowMapper, zonifyCode(code));\n            if (expiringCode != null) {\n                jdbcTemplate.update(delete, zonifyCode(code));\n            }\n            if (expiringCode.getExpiresAt().getTime() < System.currentTimeMillis()) {\n                expiringCode = null;\n            }\n            return expiringCode;\n        } catch (EmptyResultDataAccessException x) {\n            return null;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void expireByIntent(String intent) {\n        Assert.hasText(intent);\n\n        jdbcTemplate.update(deleteIntent, intent);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void expireByIntent(String intent) {\n        Assert.hasText(intent);\n\n        jdbcTemplate.update(deleteIntent, intent, zonifyCode(\"%\")+\"%\");\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ExpiringCode generateCode(String data, Timestamp expiresAt, String intent) {\n        if (data == null || expiresAt == null) {\n            throw new NullPointerException();\n        }\n\n        if (expiresAt.getTime() < System.currentTimeMillis()) {\n            throw new IllegalArgumentException();\n        }\n\n        String code = generator.generate();\n\n        ExpiringCode expiringCode = new ExpiringCode(code, expiresAt, data, intent);\n\n        ExpiringCode duplicate = store.putIfAbsent(code, expiringCode);\n        if (duplicate != null) {\n            throw new DataIntegrityViolationException(\"Duplicate code: \" + code);\n        }\n\n        return expiringCode;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ExpiringCode generateCode(String data, Timestamp expiresAt, String intent) {\n        if (data == null || expiresAt == null) {\n            throw new NullPointerException();\n        }\n\n        if (expiresAt.getTime() < System.currentTimeMillis()) {\n            throw new IllegalArgumentException();\n        }\n\n        String code = generator.generate();\n\n        ExpiringCode expiringCode = new ExpiringCode(code, expiresAt, data, intent);\n\n        ExpiringCode duplicate = store.putIfAbsent(zonifyCode(code), expiringCode);\n        if (duplicate != null) {\n            throw new DataIntegrityViolationException(\"Duplicate code: \" + code);\n        }\n\n        return expiringCode;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ExpiringCode retrieveCode(String code) {\n        if (code == null) {\n            throw new NullPointerException();\n        }\n\n        ExpiringCode expiringCode = store.remove(code);\n\n        if (expiringCode == null || expiringCode.getExpiresAt().getTime() < System.currentTimeMillis()) {\n            expiringCode = null;\n        }\n\n        return expiringCode;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ExpiringCode retrieveCode(String code) {\n        if (code == null) {\n            throw new NullPointerException();\n        }\n\n        ExpiringCode expiringCode = store.remove(zonifyCode(code));\n\n        if (expiringCode == null || expiringCode.getExpiresAt().getTime() < System.currentTimeMillis()) {\n            expiringCode = null;\n        }\n\n        return expiringCode;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void expireByIntent(String intent) {\n        Assert.hasText(intent);\n\n        store.values().stream().filter(c -> intent.equals(c.getIntent())).forEach(c -> store.remove(c.getCode()));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void expireByIntent(String intent) {\n        Assert.hasText(intent);\n        String id = IdentityZoneHolder.get().getId();\n        store.entrySet().stream().filter(c -> c.getKey().contains(id) && intent.equals(c.getValue().getIntent())).forEach(c -> store.remove(c.getKey()));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        Object redirectAttribute = request.getAttribute(URI_OVERRIDE_ATTRIBUTE);\n        String redirectFormParam = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (redirectAttribute !=null) {\n            logger.debug(\"Returning redirectAttribute saved URI:\"+redirectAttribute);\n            return (String) redirectAttribute;\n        } else if (isApprovedFormRedirectUri(request, redirectFormParam)) {\n            return redirectFormParam;\n        } else {\n            return super.determineTargetUrl(request, response);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        Object redirectAttribute = request.getAttribute(URI_OVERRIDE_ATTRIBUTE);\n        String redirectFormParam = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (redirectAttribute !=null) {\n            logger.debug(\"Returning redirectAttribute saved URI:\"+redirectAttribute);\n            return (String) redirectAttribute;\n        } else if (UaaUrlUtils.uriHasMatchingHost(redirectFormParam, request.getServerName())) {\n            return redirectFormParam;\n        } else {\n            return super.determineTargetUrl(request, response);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean shouldSaveFormRedirectParameter(HttpServletRequest request) {\n        String formRedirect = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (!HttpMethod.POST.name().equals(request.getMethod())) {\n            return false;\n        }\n        if (StringUtils.isEmpty(formRedirect)) {\n            return false;\n        }\n\n        if (hasSavedRequest(request)) {\n            return false;\n        }\n\n        return POST.name().equals(request.getMethod());\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean shouldSaveFormRedirectParameter(HttpServletRequest request) {\n        String formRedirect = request.getParameter(FORM_REDIRECT_PARAMETER);\n        if (!HttpMethod.POST.name().equals(request.getMethod())) {\n            return false;\n        }\n        if (StringUtils.isEmpty(formRedirect)) {\n            return false;\n        }\n        if (!UaaUrlUtils.uriHasMatchingHost(formRedirect, request.getServerName())) {\n            return false;\n        }\n        if (hasSavedRequest(request)) {\n            return false;\n        }\n\n        return POST.name().equals(request.getMethod());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "new PreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps) throws SQLException {\n                ps.setString(1, origin);\n                ps.setString(2, externalGroup);\n\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "new PreparedStatementSetter() {\n            @Override\n            public void setValues(PreparedStatement ps) throws SQLException {\n                ps.setString(1, IdentityZoneHolder.get().getId());\n                ps.setString(2, origin);\n                ps.setString(3, externalGroup);\n\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public OAuth2AccessToken readAccessToken(String accessToken) {\n        TokenValidation tokenValidation = validateToken(accessToken);\n        Map<String, Object> claims = tokenValidation.getClaims();\n        accessToken = tokenValidation.getJwt().getEncoded();\n\n        // Expiry is verified by check_token\n        CompositeAccessToken token = new CompositeAccessToken(accessToken);\n        token.setTokenType(OAuth2AccessToken.BEARER_TYPE);\n        Integer exp = (Integer) claims.get(EXP);\n        if (null != exp) {\n            token.setExpiration(new Date(exp.longValue() * 1000l));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<String> scopes = (ArrayList<String>) claims.get(SCOPE);\n        if (null != scopes && scopes.size() > 0) {\n            token.setScope(new HashSet<>(scopes));\n        }\n        String clientId = (String) claims.get(CID);\n        ClientDetails client = clientDetailsService.loadClientByClientId(clientId, IdentityZoneHolder.get().getId());\n        String userId = (String)claims.get(USER_ID);\n        // Only check user access tokens\n        if (null != userId) {\n            @SuppressWarnings(\"unchecked\")\n            ArrayList<String> tokenScopes = (ArrayList<String>) claims.get(SCOPE);\n            Set<String> autoApprovedScopes = getAutoApprovedScopes(claims.get(GRANT_TYPE), tokenScopes, client);\n            checkForApproval(userId, clientId, tokenScopes, autoApprovedScopes);\n        }\n\n        return token;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public OAuth2AccessToken readAccessToken(String accessToken) {\n        TokenValidation tokenValidation = validateToken(accessToken)\n          .checkAccessToken()\n          .throwIfInvalid();\n\n        Map<String, Object> claims = tokenValidation.getClaims();\n        accessToken = tokenValidation.getJwt().getEncoded();\n\n        // Expiry is verified by check_token\n        CompositeAccessToken token = new CompositeAccessToken(accessToken);\n        token.setTokenType(OAuth2AccessToken.BEARER_TYPE);\n        Integer exp = (Integer) claims.get(EXP);\n        if (null != exp) {\n            token.setExpiration(new Date(exp.longValue() * 1000l));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<String> scopes = (ArrayList<String>) claims.get(SCOPE);\n        if (null != scopes && scopes.size() > 0) {\n            token.setScope(new HashSet<>(scopes));\n        }\n        String clientId = (String) claims.get(CID);\n        ClientDetails client = clientDetailsService.loadClientByClientId(clientId, IdentityZoneHolder.get().getId());\n        String userId = (String)claims.get(USER_ID);\n        // Only check user access tokens\n        if (null != userId) {\n            @SuppressWarnings(\"unchecked\")\n            ArrayList<String> tokenScopes = (ArrayList<String>) claims.get(SCOPE);\n            Set<String> autoApprovedScopes = getAutoApprovedScopes(claims.get(GRANT_TYPE), tokenScopes, client);\n            checkForApproval(userId, clientId, tokenScopes, autoApprovedScopes);\n        }\n\n        return token;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Environment(Settings settings) {\n        this.settings = settings;\n        if (settings.get(\"path.home\") != null) {\n            homeFile = new File(cleanPath(settings.get(\"path.home\")));\n        } else {\n            homeFile = new File(System.getProperty(\"user.dir\"));\n        }\n\n        if (settings.get(\"path.conf\") != null) {\n            configFile = new File(cleanPath(settings.get(\"path.conf\")));\n        } else {\n            configFile = new File(homeFile, \"config\");\n        }\n\n        if (settings.get(\"path.plugins\") != null) {\n            pluginsFile = new File(cleanPath(settings.get(\"path.plugins\")));\n        } else {\n            pluginsFile = new File(homeFile, \"plugins\");\n        }\n\n        if (settings.get(\"path.work\") != null) {\n            workFile = new File(cleanPath(settings.get(\"path.work\")));\n        } else {\n            workFile = new File(homeFile, \"work\");\n        }\n        workWithClusterFile = new File(workFile, ClusterName.clusterNameFromSettings(settings).value());\n\n        String[] dataPaths = settings.getAsArray(\"path.data\");\n        if (dataPaths.length > 0) {\n            dataFiles = new File[dataPaths.length];\n            dataWithClusterFiles = new File[dataPaths.length];\n            for (int i = 0; i < dataPaths.length; i++) {\n                dataFiles[i] = new File(dataPaths[i]);\n                dataWithClusterFiles[i] = new File(dataFiles[i], ClusterName.clusterNameFromSettings(settings).value());\n            }\n        } else {\n            dataFiles = new File[]{new File(homeFile, \"data\")};\n            dataWithClusterFiles = new File[]{new File(new File(homeFile, \"data\"), ClusterName.clusterNameFromSettings(settings).value())};\n        }\n\n        if (settings.get(\"path.logs\") != null) {\n            logsFile = new File(cleanPath(settings.get(\"path.logs\")));\n        } else {\n            logsFile = new File(homeFile, \"logs\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Environment(Settings settings) {\n        this.settings = settings;\n        if (settings.get(\"path.home\") != null) {\n            homeFile = new File(cleanPath(settings.get(\"path.home\")));\n        } else {\n            homeFile = new File(System.getProperty(\"user.dir\"));\n        }\n\n        if (settings.get(\"path.conf\") != null) {\n            configFile = new File(cleanPath(settings.get(\"path.conf\")));\n        } else {\n            configFile = new File(homeFile, \"config\");\n        }\n\n        if (settings.get(\"path.plugins\") != null) {\n            pluginsFile = new File(cleanPath(settings.get(\"path.plugins\")));\n        } else {\n            pluginsFile = new File(homeFile, \"plugins\");\n        }\n\n        if (settings.get(\"path.work\") != null) {\n            workFile = new File(cleanPath(settings.get(\"path.work\")));\n        } else {\n            workFile = new File(homeFile, \"work\");\n        }\n        workWithClusterFile = new File(workFile, ClusterName.clusterNameFromSettings(settings).value());\n\n        String[] dataPaths = settings.getAsArray(\"path.data\");\n        if (dataPaths.length > 0) {\n            dataFiles = new File[dataPaths.length];\n            dataWithClusterFiles = new File[dataPaths.length];\n            for (int i = 0; i < dataPaths.length; i++) {\n                dataFiles[i] = new File(dataPaths[i]);\n                dataWithClusterFiles[i] = new File(dataFiles[i], ClusterName.clusterNameFromSettings(settings).value());\n            }\n        } else {\n            dataFiles = new File[]{new File(homeFile, \"data\")};\n            dataWithClusterFiles = new File[]{new File(new File(homeFile, \"data\"), ClusterName.clusterNameFromSettings(settings).value())};\n        }\n\n        String[] repoPaths = settings.getAsArray(\"path.repo\");\n        if (repoPaths.length > 0) {\n            repoFiles = new File[repoPaths.length];\n            for (int i = 0; i < repoPaths.length; i++) {\n                repoFiles[i] = new File(repoPaths[i]);\n            }\n        } else {\n            repoFiles = new File[0];\n        }\n\n        if (settings.get(\"path.logs\") != null) {\n            logsFile = new File(cleanPath(settings.get(\"path.logs\")));\n        } else {\n            logsFile = new File(homeFile, \"logs\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void lifecycleEvent(LifecycleEvent event) {\n        // When the server starts, configure JMX/RMI\n        if (Lifecycle.START_EVENT.equals(event.getType())) {\n            // Configure using standard jmx system properties\n            init();\n\n            // Prevent an attacker guessing the RMI object ID\n            System.setProperty(\"java.rmi.server.randomIDs\", \"true\");\n\n            // Create the environment\n            HashMap<String,Object> env = new HashMap<>();\n\n            RMIClientSocketFactory registryCsf = null;\n            RMIServerSocketFactory registrySsf = null;\n\n            RMIClientSocketFactory serverCsf = null;\n            RMIServerSocketFactory serverSsf = null;\n\n            // Configure registry socket factories\n            if (rmiRegistrySSL) {\n                registryCsf = new SslRMIClientSocketFactory();\n                if (rmiBindAddress == null) {\n                    registrySsf = new SslRMIServerSocketFactory(\n                            ciphers, protocols, clientAuth);\n                } else {\n                    registrySsf = new SslRmiServerBindSocketFactory(\n                            ciphers, protocols, clientAuth, rmiBindAddress);\n                }\n            } else {\n                if (rmiBindAddress != null) {\n                    registrySsf = new RmiServerBindSocketFactory(rmiBindAddress);\n                }\n            }\n\n            // Configure server socket factories\n            if (rmiServerSSL) {\n                serverCsf = new SslRMIClientSocketFactory();\n                if (rmiBindAddress == null) {\n                    serverSsf = new SslRMIServerSocketFactory(\n                            ciphers, protocols, clientAuth);\n                } else {\n                    serverSsf = new SslRmiServerBindSocketFactory(\n                            ciphers, protocols, clientAuth, rmiBindAddress);\n                }\n            } else {\n                if (rmiBindAddress != null) {\n                    serverSsf = new RmiServerBindSocketFactory(rmiBindAddress);\n                }\n            }\n\n            // By default, the registry will pick an address to listen on.\n            // Setting this property overrides that and ensures it listens on\n            // the configured address.\n            if (rmiBindAddress != null) {\n                System.setProperty(\"java.rmi.server.hostname\", rmiBindAddress);\n            }\n\n            // Force the use of local ports if required\n            if (useLocalPorts) {\n                registryCsf = new RmiClientLocalhostSocketFactory(registryCsf);\n                serverCsf = new RmiClientLocalhostSocketFactory(serverCsf);\n            }\n\n            // Populate the env properties used to create the server\n            if (serverCsf != null) {\n                env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, serverCsf);\n                env.put(\"com.sun.jndi.rmi.factory.socket\", registryCsf);\n            }\n            if (serverSsf != null) {\n                env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverSsf);\n            }\n\n            // Configure authentication\n            if (authenticate) {\n                env.put(\"jmx.remote.x.password.file\", passwordFile);\n                env.put(\"jmx.remote.x.access.file\", accessFile);\n                env.put(\"jmx.remote.x.login.config\", loginModuleName);\n            }\n\n            // Create the Platform server\n            csPlatform = createServer(\"Platform\", rmiBindAddress, rmiRegistryPortPlatform,\n                    rmiServerPortPlatform, env, registryCsf, registrySsf, serverCsf, serverSsf);\n\n        } else if (Lifecycle.STOP_EVENT.equals(event.getType())) {\n            destroyServer(\"Platform\", csPlatform);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void lifecycleEvent(LifecycleEvent event) {\n        // When the server starts, configure JMX/RMI\n        if (Lifecycle.START_EVENT.equals(event.getType())) {\n            // Configure using standard jmx system properties\n            init();\n\n            // Prevent an attacker guessing the RMI object ID\n            System.setProperty(\"java.rmi.server.randomIDs\", \"true\");\n\n            // Create the environment\n            HashMap<String,Object> env = new HashMap<>();\n\n            RMIClientSocketFactory registryCsf = null;\n            RMIServerSocketFactory registrySsf = null;\n\n            RMIClientSocketFactory serverCsf = null;\n            RMIServerSocketFactory serverSsf = null;\n\n            // Configure registry socket factories\n            if (rmiRegistrySSL) {\n                registryCsf = new SslRMIClientSocketFactory();\n                if (rmiBindAddress == null) {\n                    registrySsf = new SslRMIServerSocketFactory(\n                            ciphers, protocols, clientAuth);\n                } else {\n                    registrySsf = new SslRmiServerBindSocketFactory(\n                            ciphers, protocols, clientAuth, rmiBindAddress);\n                }\n            } else {\n                if (rmiBindAddress != null) {\n                    registrySsf = new RmiServerBindSocketFactory(rmiBindAddress);\n                }\n            }\n\n            // Configure server socket factories\n            if (rmiServerSSL) {\n                serverCsf = new SslRMIClientSocketFactory();\n                if (rmiBindAddress == null) {\n                    serverSsf = new SslRMIServerSocketFactory(\n                            ciphers, protocols, clientAuth);\n                } else {\n                    serverSsf = new SslRmiServerBindSocketFactory(\n                            ciphers, protocols, clientAuth, rmiBindAddress);\n                }\n            } else {\n                if (rmiBindAddress != null) {\n                    serverSsf = new RmiServerBindSocketFactory(rmiBindAddress);\n                }\n            }\n\n            // By default, the registry will pick an address to listen on.\n            // Setting this property overrides that and ensures it listens on\n            // the configured address.\n            if (rmiBindAddress != null) {\n                System.setProperty(\"java.rmi.server.hostname\", rmiBindAddress);\n            }\n\n            // Force the use of local ports if required\n            if (useLocalPorts) {\n                registryCsf = new RmiClientLocalhostSocketFactory(registryCsf);\n                serverCsf = new RmiClientLocalhostSocketFactory(serverCsf);\n            }\n\n            env.put(\"jmx.remote.rmi.server.credential.types\", new String[] {\n                    String[].class.getName(),\n                    String.class.getName() });\n\n            // Populate the env properties used to create the server\n            if (serverCsf != null) {\n                env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, serverCsf);\n                env.put(\"com.sun.jndi.rmi.factory.socket\", registryCsf);\n            }\n            if (serverSsf != null) {\n                env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, serverSsf);\n            }\n\n            // Configure authentication\n            if (authenticate) {\n                env.put(\"jmx.remote.x.password.file\", passwordFile);\n                env.put(\"jmx.remote.x.access.file\", accessFile);\n                env.put(\"jmx.remote.x.login.config\", loginModuleName);\n            }\n\n            // Create the Platform server\n            csPlatform = createServer(\"Platform\", rmiBindAddress, rmiRegistryPortPlatform,\n                    rmiServerPortPlatform, env, registryCsf, registrySsf, serverCsf, serverSsf);\n\n        } else if (Lifecycle.STOP_EVENT.equals(event.getType())) {\n            destroyServer(\"Platform\", csPlatform);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private JMXConnectorServer createServer(String serverName,\n            String bindAddress, int theRmiRegistryPort, int theRmiServerPort,\n            HashMap<String,Object> theEnv,\n            RMIClientSocketFactory registryCsf, RMIServerSocketFactory registrySsf,\n            RMIClientSocketFactory serverCsf, RMIServerSocketFactory serverSsf) {\n\n        // Create the RMI registry\n        Registry registry;\n        try {\n            registry = LocateRegistry.createRegistry(\n                    theRmiRegistryPort, registryCsf, registrySsf);\n        } catch (RemoteException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                    serverName, Integer.toString(theRmiRegistryPort)), e);\n            return null;\n        }\n\n        if (bindAddress == null) {\n            bindAddress = \"localhost\";\n        }\n\n        String url = \"service:jmx:rmi://\" + bindAddress;\n        JMXServiceURL serviceUrl;\n        try {\n            serviceUrl = new JMXServiceURL(url);\n        } catch (MalformedURLException e) {\n            log.error(sm.getString(\"jmxRemoteLifecycleListener.invalidURL\", serverName, url), e);\n            return null;\n        }\n\n        RMIConnectorServer cs = null;\n        try {\n            RMIJRMPServerImpl server = new RMIJRMPServerImpl(\n                    rmiServerPortPlatform, serverCsf, serverSsf, theEnv);\n            cs = new RMIConnectorServer(serviceUrl, theEnv, server,\n                    ManagementFactory.getPlatformMBeanServer());\n            cs.start();\n            registry.bind(\"jmxrmi\", server);\n            log.info(sm.getString(\"jmxRemoteLifecycleListener.start\",\n                    Integer.toString(theRmiRegistryPort),\n                    Integer.toString(theRmiServerPort), serverName));\n        } catch (IOException | AlreadyBoundException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        }\n        return cs;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private JMXConnectorServer createServer(String serverName,\n            String bindAddress, int theRmiRegistryPort, int theRmiServerPort,\n            HashMap<String,Object> theEnv,\n            RMIClientSocketFactory registryCsf, RMIServerSocketFactory registrySsf,\n            RMIClientSocketFactory serverCsf, RMIServerSocketFactory serverSsf) {\n\n        // Create the RMI registry\n        Registry registry;\n        try {\n            registry = LocateRegistry.createRegistry(\n                    theRmiRegistryPort, registryCsf, registrySsf);\n        } catch (RemoteException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createRegistryFailed\",\n                    serverName, Integer.toString(theRmiRegistryPort)), e);\n            return null;\n        }\n\n        if (bindAddress == null) {\n            bindAddress = \"localhost\";\n        }\n\n        String url = \"service:jmx:rmi://\" + bindAddress;\n        JMXServiceURL serviceUrl;\n        try {\n            serviceUrl = new JMXServiceURL(url);\n        } catch (MalformedURLException e) {\n            log.error(sm.getString(\"jmxRemoteLifecycleListener.invalidURL\", serverName, url), e);\n            return null;\n        }\n\n        RMIConnectorServer cs = null;\n        try {\n            RMIJRMPServerImpl server = new RMIJRMPServerImpl(\n                    rmiServerPortPlatform, serverCsf, serverSsf, theEnv);\n            cs = new RMIConnectorServer(serviceUrl, theEnv, server,\n                    ManagementFactory.getPlatformMBeanServer());\n            cs.start();\n            registry.bind(\"jmxrmi\", server.toStub());\n            log.info(sm.getString(\"jmxRemoteLifecycleListener.start\",\n                    Integer.toString(theRmiRegistryPort),\n                    Integer.toString(theRmiServerPort), serverName));\n        } catch (IOException | AlreadyBoundException e) {\n            log.error(sm.getString(\n                    \"jmxRemoteLifecycleListener.createServerFailed\",\n                    serverName), e);\n        }\n        return cs;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void recycle() {\n\n        internalDispatcherType = null;\n        requestDispatcherPath = null;\n\n        comet = false;\n        if (event != null) {\n            event.clear();\n            event = null;\n        }\n\n        authType = null;\n        inputBuffer.recycle();\n        usingInputStream = false;\n        usingReader = false;\n        userPrincipal = null;\n        subject = null;\n        parametersParsed = false;\n        if (parts != null) {\n            for (Part part: parts) {\n                try {\n                    part.delete();\n                } catch (IOException ignored) {\n                    // ApplicationPart.delete() never throws an IOEx\n                }\n            }\n            parts = null;\n        }\n        partsParseException = null;\n        cookiesParsed = false;\n        cookiesConverted = false;\n        locales.clear();\n        localesParsed = false;\n        secure = false;\n        remoteAddr = null;\n        remoteHost = null;\n        remotePort = -1;\n        localPort = -1;\n        localAddr = null;\n        localName = null;\n\n        attributes.clear();\n        sslAttributesParsed = false;\n        notes.clear();\n        cookies = null;\n\n        recycleSessionInfo();\n\n        if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) {\n            parameterMap = new ParameterMap<>();\n        } else {\n            parameterMap.setLocked(false);\n            parameterMap.clear();\n        }\n\n        mappingData.recycle();\n\n        if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) {\n            if (facade != null) {\n                facade.clear();\n                facade = null;\n            }\n            if (inputStream != null) {\n                inputStream.clear();\n                inputStream = null;\n            }\n            if (reader != null) {\n                reader.clear();\n                reader = null;\n            }\n        }\n\n        asyncSupported = null;\n        if (asyncContext!=null) {\n            asyncContext.recycle();\n        }\n        asyncContext = null;\n\n        pathParameters.clear();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void recycle() {\n\n        internalDispatcherType = null;\n        requestDispatcherPath = null;\n\n        comet = false;\n        if (event != null) {\n            event.clear();\n            event = null;\n        }\n\n        authType = null;\n        inputBuffer.recycle();\n        usingInputStream = false;\n        usingReader = false;\n        userPrincipal = null;\n        subject = null;\n        parametersParsed = false;\n        if (parts != null) {\n            for (Part part: parts) {\n                try {\n                    part.delete();\n                } catch (IOException ignored) {\n                    // ApplicationPart.delete() never throws an IOEx\n                }\n            }\n            parts = null;\n        }\n        partsParseException = null;\n        locales.clear();\n        localesParsed = false;\n        secure = false;\n        remoteAddr = null;\n        remoteHost = null;\n        remotePort = -1;\n        localPort = -1;\n        localAddr = null;\n        localName = null;\n\n        attributes.clear();\n        sslAttributesParsed = false;\n        notes.clear();\n\n        recycleSessionInfo();\n        recycleCookieInfo(false);\n\n        if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) {\n            parameterMap = new ParameterMap<>();\n        } else {\n            parameterMap.setLocked(false);\n            parameterMap.clear();\n        }\n\n        mappingData.recycle();\n\n        if (Globals.IS_SECURITY_ENABLED || Connector.RECYCLE_FACADES) {\n            if (facade != null) {\n                facade.clear();\n                facade = null;\n            }\n            if (inputStream != null) {\n                inputStream.clear();\n                inputStream = null;\n            }\n            if (reader != null) {\n                reader.clear();\n                reader = null;\n            }\n        }\n\n        asyncSupported = null;\n        if (asyncContext!=null) {\n            asyncContext.recycle();\n        }\n        asyncContext = null;\n\n        pathParameters.clear();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getSessionAttributeNameFilter() {\n        if (sessionAttributeNamePattern == null) {\n            return null;\n        }\n        return sessionAttributeNamePattern.toString();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getSessionAttributeNameFilter() {\n        if (sessionAttributeNamePattern == null) {\n            return null;\n        }\n        return sessionAttributeNamePattern.toString();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "sessions\n            synchronized (sessions) {\n                try (ObjectInputStream ois = new CustomObjectInputStream(bis, classLoader)) {\n                    Integer count = (Integer) ois.readObject();\n                    int n = count.intValue();\n                    if (log.isDebugEnabled())\n                        log.debug(\"Loading \" + n + \" persisted sessions\");\n                    for (int i = 0; i < n; i++) {\n                        StandardSession session = getNewSession();\n                        session.readObjectData(ois);\n                        session.setManager(this);\n                        sessions.put(session.getIdInternal(), session);\n                        session.activate();\n                        if (!session.isValidInternal()) {\n                            // If session is already invalid,\n                            // expire session to prevent memory leak.\n                            session.setValid(true);\n                            session.expire();\n                        }\n                        sessionCounter++;\n                    }\n                } finally {\n                    // Delete the persistent storage file\n                    if (file.exists()) {\n                        file.delete();\n                    }\n                }\n            }",
    "is_vulnerable": true
  },
  {
    "function_code": "sessions\n            synchronized (sessions) {\n                try (ObjectInputStream ois = new CustomObjectInputStream(bis, classLoader, logger,\n                        getSessionAttributeValueClassNamePattern(),\n                        getWarnOnSessionAttributeFilterFailure())) {\n                    Integer count = (Integer) ois.readObject();\n                    int n = count.intValue();\n                    if (log.isDebugEnabled())\n                        log.debug(\"Loading \" + n + \" persisted sessions\");\n                    for (int i = 0; i < n; i++) {\n                        StandardSession session = getNewSession();\n                        session.readObjectData(ois);\n                        session.setManager(this);\n                        sessions.put(session.getIdInternal(), session);\n                        session.activate();\n                        if (!session.isValidInternal()) {\n                            // If session is already invalid,\n                            // expire session to prevent memory leak.\n                            session.setValid(true);\n                            session.expire();\n                        }\n                        sessionCounter++;\n                    }\n                } finally {\n                    // Delete the persistent storage file\n                    if (file.exists()) {\n                        file.delete();\n                    }\n                }\n            }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setValidateClientProvidedNewSessionId(boolean validateClientProvidedNewSessionId) {\n        //NO-OP\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setValidateClientProvidedNewSessionId(boolean validateClientProvidedNewSessionId) {\n        // NO-OP\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public SendfileState processSendfile(SelectionKey sk, KeyAttachment attachment,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, attachment, sk.readyOps());\n                SendfileData sd = attachment.getSendfileData();\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n\n                if (sd.fchannel == null) {\n                    // Setup the file channel\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        cancelledKey(sk,SocketStatus.ERROR);\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\") // Closed when channel is closed\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n\n                // Configure output channel\n                sc = attachment.getSocket();\n                // TLS/SSL channel is slightly different\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                // We still have data in the buffer\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    // For calls from outside the Poller, the caller is\n                    // responsible for registering the socket for the\n                    // appropriate event(s) if sendfile completes.\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,attachment,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            cancelledKey(sk,SocketStatus.STOP);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(attachment.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR);\n                return SendfileState.ERROR;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR);\n                return SendfileState.ERROR;\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public SendfileState processSendfile(SelectionKey sk, KeyAttachment attachment,\n                boolean calledByProcessor) {\n            NioChannel sc = null;\n            try {\n                unreg(sk, attachment, sk.readyOps());\n                SendfileData sd = attachment.getSendfileData();\n\n                if (log.isTraceEnabled()) {\n                    log.trace(\"Processing send file for: \" + sd.fileName);\n                }\n\n                if (sd.fchannel == null) {\n                    // Setup the file channel\n                    File f = new File(sd.fileName);\n                    if (!f.exists()) {\n                        cancelledKey(sk,SocketStatus.ERROR);\n                        return SendfileState.ERROR;\n                    }\n                    @SuppressWarnings(\"resource\") // Closed when channel is closed\n                    FileInputStream fis = new FileInputStream(f);\n                    sd.fchannel = fis.getChannel();\n                }\n\n                // Configure output channel\n                sc = attachment.getSocket();\n                // TLS/SSL channel is slightly different\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n\n                // We still have data in the buffer\n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if (written > 0) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if (sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for: \"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {\n                        sd.fchannel.close();\n                    } catch (Exception ignore) {\n                    }\n                    // For calls from outside the Poller, the caller is\n                    // responsible for registering the socket for the\n                    // appropriate event(s) if sendfile completes.\n                    if (!calledByProcessor) {\n                        if (sd.keepAlive) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            reg(sk,attachment,SelectionKey.OP_READ);\n                        } else {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Send file connection is being closed\");\n                            }\n                            cancelledKey(sk,SocketStatus.STOP);\n                        }\n                    }\n                    return SendfileState.DONE;\n                } else {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendfile: \" + sd.fileName);\n                    }\n                    if (calledByProcessor) {\n                        add(attachment.getSocket(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                    return SendfileState.PENDING;\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                if (!calledByProcessor) {\n                    cancelledKey(sk,SocketStatus.ERROR);\n                }\n                return SendfileState.ERROR;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                if (!calledByProcessor) {\n                    cancelledKey(sk, SocketStatus.ERROR);\n                }\n                return SendfileState.ERROR;\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public MultipartStream(InputStream input,\n            byte[] boundary,\n            int bufSize,\n            ProgressNotifier pNotifier) {\n\n        if (boundary == null) {\n            throw new IllegalArgumentException(\"boundary may not be null\");\n        }\n\n        this.input = input;\n        this.bufSize = bufSize;\n        this.buffer = new byte[bufSize];\n        this.notifier = pNotifier;\n\n        // We prepend CR/LF to the boundary to chop trailing CR/LF from\n        // body-data tokens.\n        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n        if (bufSize < this.boundaryLength + 1) {\n            throw new IllegalArgumentException(\n                    \"The buffer size specified for the MultipartStream is too small\");\n        }\n        this.boundary = new byte[this.boundaryLength];\n        this.keepRegion = this.boundary.length;\n\n        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0,\n                BOUNDARY_PREFIX.length);\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n\n        head = 0;\n        tail = 0;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public MultipartStream(InputStream input,\n            byte[] boundary,\n            int bufSize,\n            ProgressNotifier pNotifier) {\n\n        if (boundary == null) {\n            throw new IllegalArgumentException(\"boundary may not be null\");\n        }\n        // We prepend CR/LF to the boundary to chop trailing CR/LF from\n        // body-data tokens.\n        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n        if (bufSize < this.boundaryLength + 1) {\n            throw new IllegalArgumentException(\n                    \"The buffer size specified for the MultipartStream is too small\");\n        }\n\n        this.input = input;\n        this.bufSize = Math.max(bufSize, boundaryLength*2);\n        this.buffer = new byte[this.bufSize];\n        this.notifier = pNotifier;\n\n        this.boundary = new byte[this.boundaryLength];\n        this.keepRegion = this.boundary.length;\n\n        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0,\n                BOUNDARY_PREFIX.length);\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n\n        head = 0;\n        tail = 0;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Object instantiate(Class type, Configuration conf, boolean fatal) {\n        Object obj = newInstance(_name, type, conf, fatal);\n        Configurations.configureInstance(obj, conf, _props,\n            (fatal) ? getProperty() : null);\n        if (_singleton)\n            set(obj, true);\n        return obj;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Object instantiate(Class type, Configuration conf, boolean fatal) {\n        Object obj = newInstance(_name, type, conf, fatal);\n        \n        // ensure plugin value is compatible with plugin type\n        if (obj != null && !type.isAssignableFrom(obj.getClass())) {\n            Log log = (conf == null) ? null : conf.getConfigurationLog();\n            String msg = getIncompatiblePluginMessage(obj, type);\n            if (log != null && log.isErrorEnabled()) {\n            \tlog.error(msg);\n            }\n            if (fatal) {\n            \tthrow new ParseException(msg);\n            }\n            return null;\n        }\n        \n        Configurations.configureInstance(obj, conf, _props,\n            (fatal) ? getProperty() : null);\n        if (_singleton)\n            set(obj, true);\n        return obj;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "int getType() {\n        return type;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "int             getType() {\n        return type;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Object getArg() {\n        return arg;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Object                getArg()  {return arg;}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setReceiver(Receiver r) {\n        if(receiver != null && r != null)\n            log.warn(\"%s: receiver already set\");\n        receiver=r;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setReceiver(Receiver r) {\n        if(receiver != null && r != null)\n            log.warn(\"%s: receiver already set\", getAddress());\n        receiver=r;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setConfig(IGerritHudsonTriggerConfig config) {\n        this.config = config;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setConfig(IGerritHudsonTriggerConfig config) {\n        checkPermission();\n        this.config = config;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void start() {\n        logger.info(\"Starting GerritServer: \" + name);\n\n        //do not try to connect to gerrit unless there is a URL or a hostname in the text fields\n        List<VerdictCategory> categories = config.getCategories();\n        if (categories == null) {\n            categories = new LinkedList<VerdictCategory>();\n        }\n        if (categories.isEmpty()) {\n            categories.add(new VerdictCategory(\"Code-Review\", \"Code Review\"));\n            categories.add(new VerdictCategory(\"Verified\", \"Verified\"));\n        }\n        config.setCategories(categories);\n        gerritEventManager = PluginImpl.getHandler_();\n\n        if (missedEventsPlaybackManager == null) {\n            missedEventsPlaybackManager = new GerritMissedEventsPlaybackManager(name);\n        }\n\n        initializeConnectionListener();\n\n        projectListUpdater =\n                new GerritProjectListUpdater(name);\n        projectListUpdater.start();\n\n        missedEventsPlaybackManager.checkIfEventsLogPluginSupported();\n        addListener((GerritEventListener)missedEventsPlaybackManager);\n\n        logger.info(name + \" started\");\n        started = true;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void start() {\n        checkPermission();\n        logger.info(\"Starting GerritServer: \" + name);\n\n        //do not try to connect to gerrit unless there is a URL or a hostname in the text fields\n        List<VerdictCategory> categories = config.getCategories();\n        if (categories == null) {\n            categories = new LinkedList<VerdictCategory>();\n        }\n        if (categories.isEmpty()) {\n            categories.add(new VerdictCategory(\"Code-Review\", \"Code Review\"));\n            categories.add(new VerdictCategory(\"Verified\", \"Verified\"));\n        }\n        config.setCategories(categories);\n        gerritEventManager = PluginImpl.getHandler_();\n\n        if (missedEventsPlaybackManager == null) {\n            missedEventsPlaybackManager = new GerritMissedEventsPlaybackManager(name);\n        }\n\n        initializeConnectionListener();\n\n        projectListUpdater =\n                new GerritProjectListUpdater(name);\n        projectListUpdater.start();\n\n        missedEventsPlaybackManager.checkIfEventsLogPluginSupported();\n        addListener((GerritEventListener)missedEventsPlaybackManager);\n\n        logger.info(name + \" started\");\n        started = true;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void stop() {\n        logger.info(\"Stopping GerritServer \" + name);\n\n        if (projectListUpdater != null) {\n            projectListUpdater.shutdown();\n            try {\n                projectListUpdater.join();\n            } catch (InterruptedException ie) {\n                logger.error(\"project list updater of \" + name + \"interrupted\", ie);\n            }\n            projectListUpdater = null;\n        }\n\n        if (missedEventsPlaybackManager != null) {\n            missedEventsPlaybackManager.shutdown();\n            missedEventsPlaybackManager = null;\n        }\n\n        if (gerritConnection != null) {\n            gerritConnection.shutdown(false);\n            gerritConnection = null;\n        }\n\n        logger.info(name + \" stopped\");\n        started = false;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void stop() {\n        checkPermission();\n        logger.info(\"Stopping GerritServer \" + name);\n\n        if (projectListUpdater != null) {\n            projectListUpdater.shutdown();\n            try {\n                projectListUpdater.join();\n            } catch (InterruptedException ie) {\n                logger.error(\"project list updater of \" + name + \"interrupted\", ie);\n            }\n            projectListUpdater = null;\n        }\n\n        if (missedEventsPlaybackManager != null) {\n            missedEventsPlaybackManager.shutdown();\n            missedEventsPlaybackManager = null;\n        }\n\n        if (gerritConnection != null) {\n            gerritConnection.shutdown(false);\n            gerritConnection = null;\n        }\n\n        logger.info(name + \" stopped\");\n        started = false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "void startConnection() {\n        if (!config.hasDefaultValues()) {\n            if (gerritConnection == null) {\n                logger.debug(\"Starting Gerrit connection...\");\n                gerritConnection = new GerritConnection(name, config);\n                gerritEventManager.setIgnoreEMail(name, config.getGerritEMail());\n                gerritConnection.setHandler(gerritEventManager);\n                gerritConnection.addListener(gerritConnectionListener);\n                gerritConnection.addListener(projectListUpdater);\n\n                missedEventsPlaybackManager.checkIfEventsLogPluginSupported();\n                gerritConnection.addListener(missedEventsPlaybackManager);\n\n                gerritConnection.start();\n            } else {\n                logger.warn(\"Already started!\");\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "void startConnection() {\n        checkPermission();\n        if (!config.hasDefaultValues()) {\n            if (gerritConnection == null) {\n                logger.debug(\"Starting Gerrit connection...\");\n                gerritConnection = new GerritConnection(name, config);\n                gerritEventManager.setIgnoreEMail(name, config.getGerritEMail());\n                gerritConnection.setHandler(gerritEventManager);\n                gerritConnection.addListener(gerritConnectionListener);\n                gerritConnection.addListener(projectListUpdater);\n\n                missedEventsPlaybackManager.checkIfEventsLogPluginSupported();\n                gerritConnection.addListener(missedEventsPlaybackManager);\n\n                gerritConnection.start();\n            } else {\n                logger.warn(\"Already started!\");\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "void stopConnection() {\n        if (gerritConnection != null) {\n            gerritConnection.shutdown(true);\n            gerritConnection.removeListener(gerritConnectionListener);\n            gerritConnection.removeListener(missedEventsPlaybackManager);\n            gerritConnection = null;\n            gerritEventManager.setIgnoreEMail(name, null);\n        } else {\n            logger.warn(\"Was told to shutdown again?\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "void stopConnection() {\n        checkPermission();\n        if (gerritConnection != null) {\n            gerritConnection.shutdown(true);\n            gerritConnection.removeListener(gerritConnectionListener);\n            gerritConnection.removeListener(missedEventsPlaybackManager);\n            gerritConnection = null;\n            gerritEventManager.setIgnoreEMail(name, null);\n        } else {\n            logger.warn(\"Was told to shutdown again?\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void rename(String newName) {\n        if (isConnected()) {\n            stopConnection();\n            stop();\n            String oldName = name;\n            name = newName;\n            start();\n            startConnection();\n            changeSelectedServerInJobs(oldName);\n        } else {\n            stop();\n            String oldName = name;\n            name = newName;\n            start();\n            changeSelectedServerInJobs(oldName);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void rename(String newName) {\n        checkPermission();\n        if (isConnected()) {\n            stopConnection();\n            stop();\n            String oldName = name;\n            name = newName;\n            start();\n            startConnection();\n            changeSelectedServerInJobs(oldName);\n        } else {\n            stop();\n            String oldName = name;\n            name = newName;\n            start();\n            changeSelectedServerInJobs(oldName);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public JSONObject doWakeup() {\n        Timer timer = new Timer();\n        try {\n            startConnection();\n\n            final CountDownLatch responseLatch = new CountDownLatch(RESPONSE_COUNT);\n            timer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    if (gerritConnectionListener != null && gerritConnectionListener.isConnected()) {\n                        responseLatch.countDown();\n                    }\n                }\n            }, RESPONSE_INTERVAL_MS, RESPONSE_INTERVAL_MS);\n\n            if (responseLatch.await(RESPONSE_TIMEOUT_S, TimeUnit.SECONDS)) {\n                timeoutWakeup = false;\n                setConnectionResponse(START_SUCCESS);\n            } else {\n                timeoutWakeup = true;\n                throw new InterruptedException(\"time out.\");\n            }\n        } catch (Exception ex) {\n            setConnectionResponse(START_FAILURE);\n            logger.error(\"Could not start connection. \", ex);\n        }\n        timer.cancel();\n\n        JSONObject obj = new JSONObject();\n        String status = \"down\";\n        if (gerritConnectionListener != null) {\n            if (gerritConnectionListener.isConnected()) {\n                status = \"up\";\n            }\n        }\n        obj.put(\"status\", status);\n        return obj;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public JSONObject doWakeup() {\n        checkPermission();\n        Timer timer = new Timer();\n        try {\n            startConnection();\n\n            final CountDownLatch responseLatch = new CountDownLatch(RESPONSE_COUNT);\n            timer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    if (gerritConnectionListener != null && gerritConnectionListener.isConnected()) {\n                        responseLatch.countDown();\n                    }\n                }\n            }, RESPONSE_INTERVAL_MS, RESPONSE_INTERVAL_MS);\n\n            if (responseLatch.await(RESPONSE_TIMEOUT_S, TimeUnit.SECONDS)) {\n                timeoutWakeup = false;\n                setConnectionResponse(START_SUCCESS);\n            } else {\n                timeoutWakeup = true;\n                throw new InterruptedException(\"time out.\");\n            }\n        } catch (Exception ex) {\n            setConnectionResponse(START_FAILURE);\n            logger.error(\"Could not start connection. \", ex);\n        }\n        timer.cancel();\n\n        JSONObject obj = new JSONObject();\n        String status = \"down\";\n        if (gerritConnectionListener != null) {\n            if (gerritConnectionListener.isConnected()) {\n                status = \"up\";\n            }\n        }\n        obj.put(\"status\", status);\n        return obj;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public JSONObject doSleep() {\n        Timer timer = new Timer();\n        try {\n            stopConnection();\n\n            final CountDownLatch responseLatch = new CountDownLatch(RESPONSE_COUNT);\n            timer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    if (gerritConnectionListener == null || !gerritConnectionListener.isConnected()) {\n                        responseLatch.countDown();\n                    }\n                }\n            }, RESPONSE_INTERVAL_MS, RESPONSE_INTERVAL_MS);\n\n            if (responseLatch.await(RESPONSE_TIMEOUT_S, TimeUnit.SECONDS)) {\n                setConnectionResponse(STOP_SUCCESS);\n            } else {\n                throw new InterruptedException(\"time out.\");\n            }\n        } catch (Exception ex) {\n            setConnectionResponse(STOP_FAILURE);\n            logger.error(\"Could not stop connection. \", ex);\n        }\n        timer.cancel();\n\n        JSONObject obj = new JSONObject();\n        String status = \"down\";\n        if (gerritConnectionListener != null) {\n            if (gerritConnectionListener.isConnected()) {\n                status = \"up\";\n            }\n        }\n        obj.put(\"status\", status);\n        return obj;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public JSONObject doSleep() {\n        checkPermission();\n        Timer timer = new Timer();\n        try {\n            stopConnection();\n\n            final CountDownLatch responseLatch = new CountDownLatch(RESPONSE_COUNT);\n            timer.schedule(new TimerTask() {\n                @Override\n                public void run() {\n                    if (gerritConnectionListener == null || !gerritConnectionListener.isConnected()) {\n                        responseLatch.countDown();\n                    }\n                }\n            }, RESPONSE_INTERVAL_MS, RESPONSE_INTERVAL_MS);\n\n            if (responseLatch.await(RESPONSE_TIMEOUT_S, TimeUnit.SECONDS)) {\n                setConnectionResponse(STOP_SUCCESS);\n            } else {\n                throw new InterruptedException(\"time out.\");\n            }\n        } catch (Exception ex) {\n            setConnectionResponse(STOP_FAILURE);\n            logger.error(\"Could not stop connection. \", ex);\n        }\n        timer.cancel();\n\n        JSONObject obj = new JSONObject();\n        String status = \"down\";\n        if (gerritConnectionListener != null) {\n            if (gerritConnectionListener.isConnected()) {\n                status = \"up\";\n            }\n        }\n        obj.put(\"status\", status);\n        return obj;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setServers(List<GerritServer> servers) {\n        if (this.servers != servers) {\n            this.servers.clear();\n            this.servers.addAll(servers);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setServers(List<GerritServer> servers) {\n        checkAdmin();\n        if (this.servers != servers) {\n            this.servers.clear();\n            this.servers.addAll(servers);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<GerritServer> addServer(GerritServer s) {\n        servers.add(s);\n        return servers;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<GerritServer> addServer(GerritServer s) {\n        checkAdmin();\n        servers.add(s);\n        return servers;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<GerritServer> removeServer(GerritServer s) {\n        servers.remove(s);\n        return servers;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<GerritServer> removeServer(GerritServer s) {\n        checkAdmin();\n        servers.remove(s);\n        return servers;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<GerritServer> getServers() {\n        PluginImpl plugin = PluginImpl.getInstance();\n        if (plugin == null) {\n            return Collections.emptyList();\n        }\n        return plugin.getServers();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<GerritServer> getServers() {\n        checkPermission();\n        PluginImpl plugin = PluginImpl.getInstance();\n        if (plugin == null) {\n            return Collections.emptyList();\n        }\n        return plugin.getServers();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public GerritServer getServer(String encodedServerName) {\n        String serverName;\n        try {\n            serverName = URLDecoder.decode(encodedServerName, CharEncoding.UTF_8);\n        } catch (Exception ex) {\n            serverName = URLDecoder.decode(encodedServerName);\n        }\n        PluginImpl plugin = PluginImpl.getInstance();\n        if (plugin == null) {\n            return null;\n        }\n        return plugin.getServer(serverName);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public GerritServer getServer(String encodedServerName) {\n        checkPermission();\n        String serverName;\n        try {\n            serverName = URLDecoder.decode(encodedServerName, CharEncoding.UTF_8);\n        } catch (Exception ex) {\n            serverName = URLDecoder.decode(encodedServerName);\n        }\n        PluginImpl plugin = PluginImpl.getInstance();\n        if (plugin == null) {\n            return null;\n        }\n        return plugin.getServer(serverName);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "void setSharedObject(Class<C> sharedType, C object) {\n\t\tthis.sharedObjects.put((Class<Object>) sharedType, object);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "void setSharedObject(Class<C> sharedType, C object) {\n\t\tthis.sharedObjects.put(sharedType, object);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "P postProcess(P object) {\n\t\treturn (P) this.objectPostProcessor.postProcess(object);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "P postProcess(P object) {\n\t\treturn this.objectPostProcessor.postProcess(object);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private IgnoredRequestConfigurer() {\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private IgnoredRequestConfigurer(ApplicationContext context) {\n\t\t\tsetApplicationContext(context);\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public HttpSecurity(ObjectPostProcessor<Object> objectPostProcessor,\n\t\t\tAuthenticationManagerBuilder authenticationBuilder,\n\t\t\tMap<Class<Object>, Object> sharedObjects) {\n\t\tsuper(objectPostProcessor);\n\t\tAssert.notNull(authenticationBuilder, \"authenticationBuilder cannot be null\");\n\t\tsetSharedObject(AuthenticationManagerBuilder.class, authenticationBuilder);\n\t\tfor (Map.Entry<Class<Object>, Object> entry : sharedObjects.entrySet()) {\n\t\t\tsetSharedObject(entry.getKey(), entry.getValue());\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public HttpSecurity(ObjectPostProcessor<Object> objectPostProcessor,\n\t\t\tAuthenticationManagerBuilder authenticationBuilder,\n\t\t\tMap<Class<? extends Object>, Object> sharedObjects) {\n\t\tsuper(objectPostProcessor);\n\t\tAssert.notNull(authenticationBuilder, \"authenticationBuilder cannot be null\");\n\t\tsetSharedObject(AuthenticationManagerBuilder.class, authenticationBuilder);\n\t\tfor (Map.Entry<Class<? extends Object>, Object> entry : sharedObjects\n\t\t\t\t.entrySet()) {\n\t\t\tsetSharedObject((Class<Object>) entry.getKey(), entry.getValue());\n\t\t}\n\t\tApplicationContext context = (ApplicationContext) sharedObjects\n\t\t\t\t.get(ApplicationContext.class);\n\t\tthis.requestMatcherConfigurer = new RequestMatcherConfigurer(context);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private RequestMatcherConfigurer() {\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private RequestMatcherConfigurer(ApplicationContext context) {\n\t\t\tsetApplicationContext(context);\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public ExpressionUrlAuthorizationConfigurer() {\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ExpressionUrlAuthorizationConfigurer(ApplicationContext context) {\n\t\tthis.REGISTRY = new ExpressionInterceptUrlRegistry(context);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public ChannelSecurityConfigurer() {\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ChannelSecurityConfigurer(ApplicationContext context) {\n\t\tthis.REGISTRY = new ChannelRequestMatcherRegistry(context);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private ChannelRequestMatcherRegistry() {\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private ChannelRequestMatcherRegistry(ApplicationContext context) {\n\t\t\tsetApplicationContext(context);\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public CsrfConfigurer() {\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public CsrfConfigurer(ApplicationContext context) {\n\t\tthis.context = context;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public CsrfConfigurer<H> ignoringAntMatchers(String... antPatterns) {\n\t\treturn new IgnoreCsrfProtectionRegistry().antMatchers(antPatterns).and();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public CsrfConfigurer<H> ignoringAntMatchers(String... antPatterns) {\n\t\treturn new IgnoreCsrfProtectionRegistry(this.context).antMatchers(antPatterns)\n\t\t\t\t.and();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder holder,\n\t\t\tParserContext parserContext) {\n\t\tBeanDefinition filterChainProxy = holder.getBeanDefinition();\n\n\t\tManagedList<BeanMetadataElement> securityFilterChains = new ManagedList<BeanMetadataElement>();\n\t\tElement elt = (Element) node;\n\n\t\tMatcherType matcherType = MatcherType.fromElement(elt);\n\n\t\tList<Element> filterChainElts = DomUtils.getChildElementsByTagName(elt,\n\t\t\t\tElements.FILTER_CHAIN);\n\n\t\tfor (Element chain : filterChainElts) {\n\t\t\tString path = chain\n\t\t\t\t\t.getAttribute(HttpSecurityBeanDefinitionParser.ATT_PATH_PATTERN);\n\t\t\tString filters = chain\n\t\t\t\t\t.getAttribute(HttpSecurityBeanDefinitionParser.ATT_FILTERS);\n\n\t\t\tif (!StringUtils.hasText(path)) {\n\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\"The attribute '\"\n\t\t\t\t\t\t\t\t+ HttpSecurityBeanDefinitionParser.ATT_PATH_PATTERN\n\t\t\t\t\t\t\t\t+ \"' must not be empty\", elt);\n\t\t\t}\n\n\t\t\tif (!StringUtils.hasText(filters)) {\n\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\"The attribute '\" + HttpSecurityBeanDefinitionParser.ATT_FILTERS\n\t\t\t\t\t\t\t\t+ \"'must not be empty\", elt);\n\t\t\t}\n\n\t\t\tBeanDefinition matcher = matcherType.createMatcher(path, null);\n\n\t\t\tif (filters.equals(HttpSecurityBeanDefinitionParser.OPT_FILTERS_NONE)) {\n\t\t\t\tsecurityFilterChains.add(createSecurityFilterChain(matcher,\n\t\t\t\t\t\tnew ManagedList(0)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] filterBeanNames = StringUtils\n\t\t\t\t\t\t.tokenizeToStringArray(filters, \",\");\n\t\t\t\tManagedList filterChain = new ManagedList(filterBeanNames.length);\n\n\t\t\t\tfor (String name : filterBeanNames) {\n\t\t\t\t\tfilterChain.add(new RuntimeBeanReference(name));\n\t\t\t\t}\n\n\t\t\t\tsecurityFilterChains.add(createSecurityFilterChain(matcher, filterChain));\n\t\t\t}\n\t\t}\n\n\t\tfilterChainProxy.getConstructorArgumentValues().addGenericArgumentValue(\n\t\t\t\tsecurityFilterChains);\n\n\t\treturn holder;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder holder,\n\t\t\tParserContext parserContext) {\n\t\tBeanDefinition filterChainProxy = holder.getBeanDefinition();\n\n\t\tManagedList<BeanMetadataElement> securityFilterChains = new ManagedList<BeanMetadataElement>();\n\t\tElement elt = (Element) node;\n\n\t\tMatcherType matcherType = MatcherType.fromElement(elt);\n\n\t\tList<Element> filterChainElts = DomUtils.getChildElementsByTagName(elt,\n\t\t\t\tElements.FILTER_CHAIN);\n\n\t\tfor (Element chain : filterChainElts) {\n\t\t\tString path = chain\n\t\t\t\t\t.getAttribute(HttpSecurityBeanDefinitionParser.ATT_PATH_PATTERN);\n\t\t\tString filters = chain\n\t\t\t\t\t.getAttribute(HttpSecurityBeanDefinitionParser.ATT_FILTERS);\n\n\t\t\tif (!StringUtils.hasText(path)) {\n\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\"The attribute '\"\n\t\t\t\t\t\t\t\t+ HttpSecurityBeanDefinitionParser.ATT_PATH_PATTERN\n\t\t\t\t\t\t\t\t+ \"' must not be empty\", elt);\n\t\t\t}\n\n\t\t\tif (!StringUtils.hasText(filters)) {\n\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\"The attribute '\" + HttpSecurityBeanDefinitionParser.ATT_FILTERS\n\t\t\t\t\t\t\t\t+ \"'must not be empty\", elt);\n\t\t\t}\n\n\t\t\tBeanDefinition matcher = matcherType.createMatcher(parserContext, path, null);\n\n\t\t\tif (filters.equals(HttpSecurityBeanDefinitionParser.OPT_FILTERS_NONE)) {\n\t\t\t\tsecurityFilterChains.add(createSecurityFilterChain(matcher,\n\t\t\t\t\t\tnew ManagedList(0)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString[] filterBeanNames = StringUtils\n\t\t\t\t\t\t.tokenizeToStringArray(filters, \",\");\n\t\t\t\tManagedList filterChain = new ManagedList(filterBeanNames.length);\n\n\t\t\t\tfor (String name : filterBeanNames) {\n\t\t\t\t\tfilterChain.add(new RuntimeBeanReference(name));\n\t\t\t\t}\n\n\t\t\t\tsecurityFilterChains.add(createSecurityFilterChain(matcher, filterChain));\n\t\t\t}\n\t\t}\n\n\t\tfilterChainProxy.getConstructorArgumentValues().addGenericArgumentValue(\n\t\t\t\tsecurityFilterChains);\n\n\t\treturn holder;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public BeanDefinition parse(Element elt, ParserContext pc) {\n\t\tMatcherType matcherType = MatcherType.fromElement(elt);\n\t\tString path = elt.getAttribute(HttpSecurityBeanDefinitionParser.ATT_PATH_PATTERN);\n\t\tString requestMatcher = elt.getAttribute(ATT_REQUEST_MATCHER_REF);\n\t\tString filters = elt.getAttribute(HttpSecurityBeanDefinitionParser.ATT_FILTERS);\n\n\t\tBeanDefinitionBuilder builder = BeanDefinitionBuilder\n\t\t\t\t.rootBeanDefinition(DefaultSecurityFilterChain.class);\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\tAssert.isTrue(!StringUtils.hasText(requestMatcher), \"\");\n\t\t\tbuilder.addConstructorArgValue(matcherType.createMatcher(path, null));\n\t\t}\n\t\telse {\n\t\t\tAssert.isTrue(StringUtils.hasText(requestMatcher), \"\");\n\t\t\tbuilder.addConstructorArgReference(requestMatcher);\n\t\t}\n\n\t\tif (filters.equals(HttpSecurityBeanDefinitionParser.OPT_FILTERS_NONE)) {\n\t\t\tbuilder.addConstructorArgValue(Collections.EMPTY_LIST);\n\t\t}\n\t\telse {\n\t\t\tString[] filterBeanNames = StringUtils.tokenizeToStringArray(filters, \",\");\n\t\t\tManagedList<RuntimeBeanReference> filterChain = new ManagedList<RuntimeBeanReference>(\n\t\t\t\t\tfilterBeanNames.length);\n\n\t\t\tfor (String name : filterBeanNames) {\n\t\t\t\tfilterChain.add(new RuntimeBeanReference(name));\n\t\t\t}\n\n\t\t\tbuilder.addConstructorArgValue(filterChain);\n\t\t}\n\n\t\treturn builder.getBeanDefinition();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public BeanDefinition parse(Element elt, ParserContext pc) {\n\t\tMatcherType matcherType = MatcherType.fromElement(elt);\n\t\tString path = elt.getAttribute(HttpSecurityBeanDefinitionParser.ATT_PATH_PATTERN);\n\t\tString requestMatcher = elt.getAttribute(ATT_REQUEST_MATCHER_REF);\n\t\tString filters = elt.getAttribute(HttpSecurityBeanDefinitionParser.ATT_FILTERS);\n\n\t\tBeanDefinitionBuilder builder = BeanDefinitionBuilder\n\t\t\t\t.rootBeanDefinition(DefaultSecurityFilterChain.class);\n\n\t\tif (StringUtils.hasText(path)) {\n\t\t\tAssert.isTrue(!StringUtils.hasText(requestMatcher), \"\");\n\t\t\tbuilder.addConstructorArgValue(matcherType.createMatcher(pc, path, null));\n\t\t}\n\t\telse {\n\t\t\tAssert.isTrue(StringUtils.hasText(requestMatcher), \"\");\n\t\t\tbuilder.addConstructorArgReference(requestMatcher);\n\t\t}\n\n\t\tif (filters.equals(HttpSecurityBeanDefinitionParser.OPT_FILTERS_NONE)) {\n\t\t\tbuilder.addConstructorArgValue(Collections.EMPTY_LIST);\n\t\t}\n\t\telse {\n\t\t\tString[] filterBeanNames = StringUtils.tokenizeToStringArray(filters, \",\");\n\t\t\tManagedList<RuntimeBeanReference> filterChain = new ManagedList<RuntimeBeanReference>(\n\t\t\t\t\tfilterBeanNames.length);\n\n\t\t\tfor (String name : filterBeanNames) {\n\t\t\t\tfilterChain.add(new RuntimeBeanReference(name));\n\t\t\t}\n\n\t\t\tbuilder.addConstructorArgValue(filterChain);\n\t\t}\n\n\t\treturn builder.getBeanDefinition();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "BeanDefinition> parseInterceptUrlsForFilterInvocationRequestMap(\n\t\t\tMatcherType matcherType, List<Element> urlElts, boolean useExpressions,\n\t\t\tboolean addAuthenticatedAll, ParserContext parserContext) {\n\n\t\tManagedMap<BeanDefinition, BeanDefinition> filterInvocationDefinitionMap = new ManagedMap<BeanDefinition, BeanDefinition>();\n\n\t\tfor (Element urlElt : urlElts) {\n\t\t\tString access = urlElt.getAttribute(ATT_ACCESS);\n\t\t\tif (!StringUtils.hasText(access)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString path = urlElt.getAttribute(ATT_PATTERN);\n\n\t\t\tif (!StringUtils.hasText(path)) {\n\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\"path attribute cannot be empty or null\", urlElt);\n\t\t\t}\n\n\t\t\tString method = urlElt.getAttribute(ATT_HTTP_METHOD);\n\t\t\tif (!StringUtils.hasText(method)) {\n\t\t\t\tmethod = null;\n\t\t\t}\n\n\t\t\tBeanDefinition matcher = matcherType.createMatcher(path, method);\n\t\t\tBeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder\n\t\t\t\t\t.rootBeanDefinition(SecurityConfig.class);\n\n\t\t\tif (useExpressions) {\n\t\t\t\tlogger.info(\"Creating access control expression attribute '\" + access\n\t\t\t\t\t\t+ \"' for \" + path);\n\t\t\t\t// The single expression will be parsed later by the\n\t\t\t\t// ExpressionFilterInvocationSecurityMetadataSource\n\t\t\t\tattributeBuilder.addConstructorArgValue(new String[] { access });\n\t\t\t\tattributeBuilder.setFactoryMethod(\"createList\");\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattributeBuilder.addConstructorArgValue(access);\n\t\t\t\tattributeBuilder.setFactoryMethod(\"createListFromCommaDelimitedString\");\n\t\t\t}\n\n\t\t\tif (filterInvocationDefinitionMap.containsKey(matcher)) {\n\t\t\t\tlogger.warn(\"Duplicate URL defined: \" + path\n\t\t\t\t\t\t+ \". The original attribute values will be overwritten\");\n\t\t\t}\n\n\t\t\tfilterInvocationDefinitionMap.put(matcher,\n\t\t\t\t\tattributeBuilder.getBeanDefinition());\n\t\t}\n\n\t\tif (addAuthenticatedAll && filterInvocationDefinitionMap.isEmpty()) {\n\n\t\t\tBeanDefinition matcher = matcherType.createMatcher(\"/**\", null);\n\t\t\tBeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder\n\t\t\t\t\t.rootBeanDefinition(SecurityConfig.class);\n\t\t\tattributeBuilder.addConstructorArgValue(new String[] { \"authenticated\" });\n\t\t\tattributeBuilder.setFactoryMethod(\"createList\");\n\t\t\tfilterInvocationDefinitionMap.put(matcher,\n\t\t\t\t\tattributeBuilder.getBeanDefinition());\n\t\t}\n\n\t\treturn filterInvocationDefinitionMap;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "BeanDefinition> parseInterceptUrlsForFilterInvocationRequestMap(\n\t\t\tMatcherType matcherType, List<Element> urlElts, boolean useExpressions,\n\t\t\tboolean addAuthenticatedAll, ParserContext parserContext) {\n\n\t\tManagedMap<BeanDefinition, BeanDefinition> filterInvocationDefinitionMap = new ManagedMap<BeanDefinition, BeanDefinition>();\n\n\t\tfor (Element urlElt : urlElts) {\n\t\t\tString access = urlElt.getAttribute(ATT_ACCESS);\n\t\t\tif (!StringUtils.hasText(access)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString path = urlElt.getAttribute(ATT_PATTERN);\n\n\t\t\tif (!StringUtils.hasText(path)) {\n\t\t\t\tparserContext.getReaderContext().error(\n\t\t\t\t\t\t\"path attribute cannot be empty or null\", urlElt);\n\t\t\t}\n\n\t\t\tString method = urlElt.getAttribute(ATT_HTTP_METHOD);\n\t\t\tif (!StringUtils.hasText(method)) {\n\t\t\t\tmethod = null;\n\t\t\t}\n\n\t\t\tBeanDefinition matcher = matcherType.createMatcher(parserContext, path,\n\t\t\t\t\tmethod);\n\t\t\tBeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder\n\t\t\t\t\t.rootBeanDefinition(SecurityConfig.class);\n\n\t\t\tif (useExpressions) {\n\t\t\t\tlogger.info(\"Creating access control expression attribute '\" + access\n\t\t\t\t\t\t+ \"' for \" + path);\n\t\t\t\t// The single expression will be parsed later by the\n\t\t\t\t// ExpressionFilterInvocationSecurityMetadataSource\n\t\t\t\tattributeBuilder.addConstructorArgValue(new String[] { access });\n\t\t\t\tattributeBuilder.setFactoryMethod(\"createList\");\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattributeBuilder.addConstructorArgValue(access);\n\t\t\t\tattributeBuilder.setFactoryMethod(\"createListFromCommaDelimitedString\");\n\t\t\t}\n\n\t\t\tif (filterInvocationDefinitionMap.containsKey(matcher)) {\n\t\t\t\tlogger.warn(\"Duplicate URL defined: \" + path\n\t\t\t\t\t\t+ \". The original attribute values will be overwritten\");\n\t\t\t}\n\n\t\t\tfilterInvocationDefinitionMap.put(matcher,\n\t\t\t\t\tattributeBuilder.getBeanDefinition());\n\t\t}\n\n\t\tif (addAuthenticatedAll && filterInvocationDefinitionMap.isEmpty()) {\n\n\t\t\tBeanDefinition matcher = matcherType.createMatcher(parserContext, \"/**\",\n\t\t\t\t\tnull);\n\t\t\tBeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder\n\t\t\t\t\t.rootBeanDefinition(SecurityConfig.class);\n\t\t\tattributeBuilder.addConstructorArgValue(new String[] { \"authenticated\" });\n\t\t\tattributeBuilder.setFactoryMethod(\"createList\");\n\t\t\tfilterInvocationDefinitionMap.put(matcher,\n\t\t\t\t\tattributeBuilder.getBeanDefinition());\n\t\t}\n\n\t\treturn filterInvocationDefinitionMap;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void enableDefaultTyping(ObjectMapper mapper) {\n\t\tif(mapper != null) {\n\t\t\tTypeResolverBuilder<?> typeBuilder = mapper.getDeserializationConfig().getDefaultTyper(null);\n\t\t\tif (typeBuilder == null) {\n\t\t\t\tmapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\t\t\t}\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void enableDefaultTyping(ObjectMapper mapper) {\n\t\tif(mapper != null) {\n\t\t\tTypeResolverBuilder<?> typeBuilder = mapper.getDeserializationConfig().getDefaultTyper(null);\n\t\t\tif (typeBuilder == null) {\n\t\t\t\tmapper.setDefaultTyping(createWhitelistedDefaultTyping());\n\t\t\t}\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public JwtIssuerValidator(String issuer) {\n\t\tAssert.notNull(issuer, \"issuer cannot be null\");\n\n\t\ttry {\n\t\t\tthis.issuer = new URL(issuer);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Invalid Issuer URL \" + issuer + \" : \" + ex.getMessage(),\n\t\t\t\t\tex);\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public JwtIssuerValidator(String issuer) {\n\t\tAssert.notNull(issuer, \"issuer cannot be null\");\n\n\t\ttry {\n\t\t\tthis.issuer = new URL(issuer).toString();\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Invalid Issuer URL \" + issuer + \" : \" + ex.getMessage(),\n\t\t\t\t\tex);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public OAuth2TokenValidatorResult validate(Jwt token) {\n\t\tAssert.notNull(token, \"token cannot be null\");\n\n\t\tif (this.issuer.equals(token.getIssuer())) {\n\t\t\treturn OAuth2TokenValidatorResult.success();\n\t\t} else {\n\t\t\treturn OAuth2TokenValidatorResult.failure(INVALID_ISSUER);\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public OAuth2TokenValidatorResult validate(Jwt token) {\n\t\tAssert.notNull(token, \"token cannot be null\");\n\n\t\tString tokenIssuer = token.getClaimAsString(JwtClaimNames.ISS);\n\t\tif (this.issuer.equals(tokenIssuer)) {\n\t\t\treturn OAuth2TokenValidatorResult.success();\n\t\t} else {\n\t\t\treturn OAuth2TokenValidatorResult.failure(INVALID_ISSUER);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (int i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (long i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public keys\n            for (int i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }",
    "is_vulnerable": true
  },
  {
    "function_code": "public keys\n            for (long i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getAuthorizationID() {\n        if (!isComplete())\n            throw new IllegalStateException(\"Authentication exchange has not completed\");\n        String authzId = clientFirstMessage.authorizationId();\n        return authzId == null || authzId.length() == 0 ? username : authzId;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getAuthorizationID() {\n        if (!isComplete())\n            throw new IllegalStateException(\"Authentication exchange has not completed\");\n        return username;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getAuthorizationID() {\n        if (!complete)\n            throw new IllegalStateException(\"Authentication exchange has not completed\");\n        return authorizationID;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getAuthorizationID() {\n        if (!complete)\n            throw new IllegalStateException(\"Authentication exchange has not completed\");\n        return authorizationId;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ModelAndView authorize(Map<String, Object> model, @RequestParam Map<String, String> parameters,\n\t\t\tSessionStatus sessionStatus, Principal principal) {\n\n\t\t// Pull out the authorization request first, using the OAuth2RequestFactory. All further logic should\n\t\t// query off of the authorization request instead of referring back to the parameters map. The contents of the\n\t\t// parameters map will be stored without change in the AuthorizationRequest object once it is created.\n\t\tAuthorizationRequest authorizationRequest = getOAuth2RequestFactory().createAuthorizationRequest(parameters);\n\n\t\tSet<String> responseTypes = authorizationRequest.getResponseTypes();\n\n\t\tif (!responseTypes.contains(\"token\") && !responseTypes.contains(\"code\")) {\n\t\t\tthrow new UnsupportedResponseTypeException(\"Unsupported response types: \" + responseTypes);\n\t\t}\n\n\t\tif (authorizationRequest.getClientId() == null) {\n\t\t\tthrow new InvalidClientException(\"A client id must be provided\");\n\t\t}\n\n\t\ttry {\n\n\t\t\tif (!(principal instanceof Authentication) || !((Authentication) principal).isAuthenticated()) {\n\t\t\t\tthrow new InsufficientAuthenticationException(\n\t\t\t\t\t\t\"User must be authenticated with Spring Security before authorization can be completed.\");\n\t\t\t}\n\n\t\t\tClientDetails client = getClientDetailsService().loadClientByClientId(authorizationRequest.getClientId());\n\n\t\t\t// The resolved redirect URI is either the redirect_uri from the parameters or the one from\n\t\t\t// clientDetails. Either way we need to store it on the AuthorizationRequest.\n\t\t\tString redirectUriParameter = authorizationRequest.getRequestParameters().get(OAuth2Utils.REDIRECT_URI);\n\t\t\tString resolvedRedirect = redirectResolver.resolveRedirect(redirectUriParameter, client);\n\t\t\tif (!StringUtils.hasText(resolvedRedirect)) {\n\t\t\t\tthrow new RedirectMismatchException(\n\t\t\t\t\t\t\"A redirectUri must be either supplied or preconfigured in the ClientDetails\");\n\t\t\t}\n\t\t\tauthorizationRequest.setRedirectUri(resolvedRedirect);\n\n\t\t\t// We intentionally only validate the parameters requested by the client (ignoring any data that may have\n\t\t\t// been added to the request by the manager).\n\t\t\toauth2RequestValidator.validateScope(authorizationRequest, client);\n\n\t\t\t// Some systems may allow for approval decisions to be remembered or approved by default. Check for\n\t\t\t// such logic here, and set the approved flag on the authorization request accordingly.\n\t\t\tauthorizationRequest = userApprovalHandler.checkForPreApproval(authorizationRequest,\n\t\t\t\t\t(Authentication) principal);\n\t\t\t// TODO: is this call necessary?\n\t\t\tboolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);\n\t\t\tauthorizationRequest.setApproved(approved);\n\n\t\t\t// Validation is all done, so we can check for auto approval...\n\t\t\tif (authorizationRequest.isApproved()) {\n\t\t\t\tif (responseTypes.contains(\"token\")) {\n\t\t\t\t\treturn getImplicitGrantResponse(authorizationRequest);\n\t\t\t\t}\n\t\t\t\tif (responseTypes.contains(\"code\")) {\n\t\t\t\t\treturn new ModelAndView(getAuthorizationCodeResponse(authorizationRequest,\n\t\t\t\t\t\t\t(Authentication) principal));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Place auth request into the model so that it is stored in the session\n\t\t\t// for approveOrDeny to use. That way we make sure that auth request comes from the session,\n\t\t\t// so any auth request parameters passed to approveOrDeny will be ignored and retrieved from the session.\n\t\t\tmodel.put(\"authorizationRequest\", authorizationRequest);\n\n\t\t\treturn getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal);\n\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t\tsessionStatus.setComplete();\n\t\t\tthrow e;\n\t\t}\n\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ModelAndView authorize(Map<String, Object> model, @RequestParam Map<String, String> parameters,\n\t\t\tSessionStatus sessionStatus, Principal principal) {\n\n\t\t// Pull out the authorization request first, using the OAuth2RequestFactory. All further logic should\n\t\t// query off of the authorization request instead of referring back to the parameters map. The contents of the\n\t\t// parameters map will be stored without change in the AuthorizationRequest object once it is created.\n\t\tAuthorizationRequest authorizationRequest = getOAuth2RequestFactory().createAuthorizationRequest(parameters);\n\n\t\tSet<String> responseTypes = authorizationRequest.getResponseTypes();\n\n\t\tif (!responseTypes.contains(\"token\") && !responseTypes.contains(\"code\")) {\n\t\t\tthrow new UnsupportedResponseTypeException(\"Unsupported response types: \" + responseTypes);\n\t\t}\n\n\t\tif (authorizationRequest.getClientId() == null) {\n\t\t\tthrow new InvalidClientException(\"A client id must be provided\");\n\t\t}\n\n\t\ttry {\n\n\t\t\tif (!(principal instanceof Authentication) || !((Authentication) principal).isAuthenticated()) {\n\t\t\t\tthrow new InsufficientAuthenticationException(\n\t\t\t\t\t\t\"User must be authenticated with Spring Security before authorization can be completed.\");\n\t\t\t}\n\n\t\t\tClientDetails client = getClientDetailsService().loadClientByClientId(authorizationRequest.getClientId());\n\n\t\t\t// The resolved redirect URI is either the redirect_uri from the parameters or the one from\n\t\t\t// clientDetails. Either way we need to store it on the AuthorizationRequest.\n\t\t\tString redirectUriParameter = authorizationRequest.getRequestParameters().get(OAuth2Utils.REDIRECT_URI);\n\t\t\tString resolvedRedirect = redirectResolver.resolveRedirect(redirectUriParameter, client);\n\t\t\tif (!StringUtils.hasText(resolvedRedirect)) {\n\t\t\t\tthrow new RedirectMismatchException(\n\t\t\t\t\t\t\"A redirectUri must be either supplied or preconfigured in the ClientDetails\");\n\t\t\t}\n\t\t\tauthorizationRequest.setRedirectUri(resolvedRedirect);\n\n\t\t\t// We intentionally only validate the parameters requested by the client (ignoring any data that may have\n\t\t\t// been added to the request by the manager).\n\t\t\toauth2RequestValidator.validateScope(authorizationRequest, client);\n\n\t\t\t// Some systems may allow for approval decisions to be remembered or approved by default. Check for\n\t\t\t// such logic here, and set the approved flag on the authorization request accordingly.\n\t\t\tauthorizationRequest = userApprovalHandler.checkForPreApproval(authorizationRequest,\n\t\t\t\t\t(Authentication) principal);\n\t\t\t// TODO: is this call necessary?\n\t\t\tboolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);\n\t\t\tauthorizationRequest.setApproved(approved);\n\n\t\t\t// Validation is all done, so we can check for auto approval...\n\t\t\tif (authorizationRequest.isApproved()) {\n\t\t\t\tif (responseTypes.contains(\"token\")) {\n\t\t\t\t\treturn getImplicitGrantResponse(authorizationRequest);\n\t\t\t\t}\n\t\t\t\tif (responseTypes.contains(\"code\")) {\n\t\t\t\t\treturn new ModelAndView(getAuthorizationCodeResponse(authorizationRequest,\n\t\t\t\t\t\t\t(Authentication) principal));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Store authorizationRequest AND an immutable Map of authorizationRequest in session\n\t\t\t// which will be used to validate against in approveOrDeny()\n\t\t\tmodel.put(AUTHORIZATION_REQUEST_ATTR_NAME, authorizationRequest);\n\t\t\tmodel.put(ORIGINAL_AUTHORIZATION_REQUEST_ATTR_NAME, unmodifiableMap(authorizationRequest));\n\n\t\t\treturn getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal);\n\n\t\t}\n\t\tcatch (RuntimeException e) {\n\t\t\tsessionStatus.setComplete();\n\t\t\tthrow e;\n\t\t}\n\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public View approveOrDeny(@RequestParam Map<String, String> approvalParameters, Map<String, ?> model,\n\t\t\tSessionStatus sessionStatus, Principal principal) {\n\n\t\tif (!(principal instanceof Authentication)) {\n\t\t\tsessionStatus.setComplete();\n\t\t\tthrow new InsufficientAuthenticationException(\n\t\t\t\t\t\"User must be authenticated with Spring Security before authorizing an access token.\");\n\t\t}\n\n\t\tAuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get(\"authorizationRequest\");\n\n\t\tif (authorizationRequest == null) {\n\t\t\tsessionStatus.setComplete();\n\t\t\tthrow new InvalidRequestException(\"Cannot approve uninitialized authorization request.\");\n\t\t}\n\n\t\ttry {\n\t\t\tSet<String> responseTypes = authorizationRequest.getResponseTypes();\n\n\t\t\tauthorizationRequest.setApprovalParameters(approvalParameters);\n\t\t\tauthorizationRequest = userApprovalHandler.updateAfterApproval(authorizationRequest,\n\t\t\t\t\t(Authentication) principal);\n\t\t\tboolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);\n\t\t\tauthorizationRequest.setApproved(approved);\n\n\t\t\tif (authorizationRequest.getRedirectUri() == null) {\n\t\t\t\tsessionStatus.setComplete();\n\t\t\t\tthrow new InvalidRequestException(\"Cannot approve request when no redirect URI is provided.\");\n\t\t\t}\n\n\t\t\tif (!authorizationRequest.isApproved()) {\n\t\t\t\treturn new RedirectView(getUnsuccessfulRedirect(authorizationRequest,\n\t\t\t\t\t\tnew UserDeniedAuthorizationException(\"User denied access\"), responseTypes.contains(\"token\")),\n\t\t\t\t\t\tfalse, true, false);\n\t\t\t}\n\n\t\t\tif (responseTypes.contains(\"token\")) {\n\t\t\t\treturn getImplicitGrantResponse(authorizationRequest).getView();\n\t\t\t}\n\n\t\t\treturn getAuthorizationCodeResponse(authorizationRequest, (Authentication) principal);\n\t\t}\n\t\tfinally {\n\t\t\tsessionStatus.setComplete();\n\t\t}\n\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public View approveOrDeny(@RequestParam Map<String, String> approvalParameters, Map<String, ?> model,\n\t\t\tSessionStatus sessionStatus, Principal principal) {\n\n\t\tif (!(principal instanceof Authentication)) {\n\t\t\tsessionStatus.setComplete();\n\t\t\tthrow new InsufficientAuthenticationException(\n\t\t\t\t\t\"User must be authenticated with Spring Security before authorizing an access token.\");\n\t\t}\n\n\t\tAuthorizationRequest authorizationRequest = (AuthorizationRequest) model.get(AUTHORIZATION_REQUEST_ATTR_NAME);\n\n\t\tif (authorizationRequest == null) {\n\t\t\tsessionStatus.setComplete();\n\t\t\tthrow new InvalidRequestException(\"Cannot approve uninitialized authorization request.\");\n\t\t}\n\n\t\t// Check to ensure the Authorization Request was not modified during the user approval step\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tMap<String, Object> originalAuthorizationRequest = (Map<String, Object>) model.get(ORIGINAL_AUTHORIZATION_REQUEST_ATTR_NAME);\n\t\tif (isAuthorizationRequestModified(authorizationRequest, originalAuthorizationRequest)) {\n\t\t\tthrow new InvalidRequestException(\"Changes were detected from the original authorization request.\");\n\t\t}\n\n\t\ttry {\n\t\t\tSet<String> responseTypes = authorizationRequest.getResponseTypes();\n\n\t\t\tauthorizationRequest.setApprovalParameters(approvalParameters);\n\t\t\tauthorizationRequest = userApprovalHandler.updateAfterApproval(authorizationRequest,\n\t\t\t\t\t(Authentication) principal);\n\t\t\tboolean approved = userApprovalHandler.isApproved(authorizationRequest, (Authentication) principal);\n\t\t\tauthorizationRequest.setApproved(approved);\n\n\t\t\tif (authorizationRequest.getRedirectUri() == null) {\n\t\t\t\tsessionStatus.setComplete();\n\t\t\t\tthrow new InvalidRequestException(\"Cannot approve request when no redirect URI is provided.\");\n\t\t\t}\n\n\t\t\tif (!authorizationRequest.isApproved()) {\n\t\t\t\treturn new RedirectView(getUnsuccessfulRedirect(authorizationRequest,\n\t\t\t\t\t\tnew UserDeniedAuthorizationException(\"User denied access\"), responseTypes.contains(\"token\")),\n\t\t\t\t\t\tfalse, true, false);\n\t\t\t}\n\n\t\t\tif (responseTypes.contains(\"token\")) {\n\t\t\t\treturn getImplicitGrantResponse(authorizationRequest).getView();\n\t\t\t}\n\n\t\t\treturn getAuthorizationCodeResponse(authorizationRequest, (Authentication) principal);\n\t\t}\n\t\tfinally {\n\t\t\tsessionStatus.setComplete();\n\t\t}\n\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private AuthorizationRequest getAuthorizationRequestForError(ServletWebRequest webRequest) {\n\n\t\t// If it's already there then we are in the approveOrDeny phase and we can use the saved request\n\t\tAuthorizationRequest authorizationRequest = (AuthorizationRequest) sessionAttributeStore.retrieveAttribute(\n\t\t\t\twebRequest, \"authorizationRequest\");\n\t\tif (authorizationRequest != null) {\n\t\t\treturn authorizationRequest;\n\t\t}\n\n\t\tMap<String, String> parameters = new HashMap<String, String>();\n\t\tMap<String, String[]> map = webRequest.getParameterMap();\n\t\tfor (String key : map.keySet()) {\n\t\t\tString[] values = map.get(key);\n\t\t\tif (values != null && values.length > 0) {\n\t\t\t\tparameters.put(key, values[0]);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\treturn getOAuth2RequestFactory().createAuthorizationRequest(parameters);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn getDefaultOAuth2RequestFactory().createAuthorizationRequest(parameters);\n\t\t}\n\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private AuthorizationRequest getAuthorizationRequestForError(ServletWebRequest webRequest) {\n\n\t\t// If it's already there then we are in the approveOrDeny phase and we can use the saved request\n\t\tAuthorizationRequest authorizationRequest = (AuthorizationRequest) sessionAttributeStore.retrieveAttribute(\n\t\t\t\twebRequest, AUTHORIZATION_REQUEST_ATTR_NAME);\n\t\tif (authorizationRequest != null) {\n\t\t\treturn authorizationRequest;\n\t\t}\n\n\t\tMap<String, String> parameters = new HashMap<String, String>();\n\t\tMap<String, String[]> map = webRequest.getParameterMap();\n\t\tfor (String key : map.keySet()) {\n\t\t\tString[] values = map.get(key);\n\t\t\tif (values != null && values.length > 0) {\n\t\t\t\tparameters.put(key, values[0]);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\treturn getOAuth2RequestFactory().createAuthorizationRequest(parameters);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn getDefaultOAuth2RequestFactory().createAuthorizationRequest(parameters);\n\t\t}\n\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {\n\n\t\tif (!path.endsWith(\"-\")) {\n\t\t\treturn super.evaluateValueFromTarget(targetObject, entityType);\n\t\t}\n\n\t\tString pathSource = Arrays.stream(path.split(\"/\"))//\n\t\t\t\t.filter(it -> !it.matches(\"\\\\d\")) // no digits\n\t\t\t\t.filter(it -> !it.equals(\"-\")) // no \"last element\"s\n\t\t\t\t.filter(it -> !it.isEmpty()) //\n\t\t\t\t.collect(Collectors.joining(\".\"));\n\n\t\tPropertyPath propertyPath = PropertyPath.from(pathSource, entityType);\n\n\t\treturn value instanceof LateObjectEvaluator ? ((LateObjectEvaluator) value).evaluate(propertyPath.getType())\n\t\t\t\t: value;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {\n\n\t\tif (!path.endsWith(\"-\")) {\n\t\t\treturn super.evaluateValueFromTarget(targetObject, entityType);\n\t\t}\n\n\t\treturn evaluate(verifyPath(entityType).<Class<?>> map(it -> it.getType()).orElse(entityType));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {\n\n\t\treturn value instanceof LateObjectEvaluator\n\t\t\t\t? ((LateObjectEvaluator) value).evaluate(spelExpression.getValueType(targetObject)) : value;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {\n\n\t\tverifyPath(entityType);\n\n\t\treturn evaluate(spelExpression.getValueType(targetObject));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getIconFileName() {\n        // TODO\n        return null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getIconFileName() {\n        // TODO\n        return null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "String getWindowOpenJavaScript()\n\t{\n\t\tAppendingStringBuffer buffer = new AppendingStringBuffer(500);\n\n\t\tif (isCustomComponent() == true)\n\t\t{\n\t\t\tbuffer.append(\"var element = document.getElementById(\\\"\");\n\t\t\tbuffer.append(getContentMarkupId());\n\t\t\tbuffer.append(\"\\\");\\n\");\n\t\t}\n\n\t\tbuffer.append(\"var settings = new Object();\\n\");\n\n\t\tappendAssignment(buffer, \"settings.minWidth\", getMinimalWidth());\n\t\tappendAssignment(buffer, \"settings.minHeight\", getMinimalHeight());\n\t\tappendAssignment(buffer, \"settings.className\", getCssClassName());\n\t\tappendAssignment(buffer, \"settings.width\", getInitialWidth());\n\n\t\tif ((isUseInitialHeight() == true) || (isCustomComponent() == false))\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.height\", getInitialHeight());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.height=null;\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.resizable\", isResizable());\n\n\t\tif (isResizable() == false)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.widthUnit\", getWidthUnit());\n\t\t\tappendAssignment(buffer, \"settings.heightUnit\", getHeightUnit());\n\t\t}\n\n\t\tif (isCustomComponent() == false)\n\t\t{\n\t\t\tPage page = createPage();\n\t\t\tif (page == null)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\"Error creating page for modal dialog.\");\n\t\t\t}\n\t\t\tCharSequence pageUrl;\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\n\n\t\t\tpage.getSession().getPageManager().touchPage(page);\n\t\t\tif (page.isPageStateless())\n\t\t\t{\n\t\t\t\tpageUrl = requestCycle.urlFor(page.getClass(), page.getPageParameters());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\n\t\t\t\tpageUrl = requestCycle.urlFor(handler);\n\t\t\t}\n\n\t\t\tappendAssignment(buffer, \"settings.src\", pageUrl);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.element=element;\\n\");\n\t\t}\n\n\t\tif (getCookieName() != null)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.cookieId\", getCookieName());\n\t\t}\n\n\t\tObject title = getTitle() != null ? getTitle().getObject() : null;\n\t\tif (title != null)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.title\", escapeQuotes(title.toString()));\n\t\t}\n\n\t\tif (getMaskType() == MaskType.TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"transparent\\\";\\n\");\n\t\t}\n\t\telse if (getMaskType() == MaskType.SEMI_TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"semi-transparent\\\";\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.autoSize\", autoSize);\n\n\t\tappendAssignment(buffer, \"settings.unloadConfirmation\", showUnloadConfirmation());\n\n\t\t// set true if we set a windowclosedcallback\n\t\tboolean haveCloseCallback = false;\n\n\t\t// in case user is interested in window close callback or we have a pagemap to clean attach\n\t\t// notification request\n\t\tif (windowClosedCallback != null)\n\t\t{\n\t\t\tWindowClosedBehavior behavior = getBehaviors(WindowClosedBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onClose = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\" };\\n\");\n\n\t\t\thaveCloseCallback = true;\n\t\t}\n\n\t\t// in case we didn't set windowclosecallback, we need at least callback on close button, to\n\t\t// close window property (thus cleaning the shown flag)\n\t\tif ((closeButtonCallback != null) || (haveCloseCallback == false))\n\t\t{\n\t\t\tCloseButtonBehavior behavior = getBehaviors(CloseButtonBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onCloseButton = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\";return false;};\\n\");\n\t\t}\n\n\t\tpostProcessSettings(buffer);\n\n\t\tbuffer.append(getShowJavaScript());\n\t\treturn buffer.toString();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "String getWindowOpenJavaScript()\n\t{\n\t\tAppendingStringBuffer buffer = new AppendingStringBuffer(500);\n\n\t\tif (isCustomComponent() == true)\n\t\t{\n\t\t\tbuffer.append(\"var element = document.getElementById(\\\"\");\n\t\t\tbuffer.append(getContentMarkupId());\n\t\t\tbuffer.append(\"\\\");\\n\");\n\t\t}\n\n\t\tbuffer.append(\"var settings = new Object();\\n\");\n\n\t\tappendAssignment(buffer, \"settings.minWidth\", getMinimalWidth());\n\t\tappendAssignment(buffer, \"settings.minHeight\", getMinimalHeight());\n\t\tappendAssignment(buffer, \"settings.className\", getCssClassName());\n\t\tappendAssignment(buffer, \"settings.width\", getInitialWidth());\n\n\t\tif ((isUseInitialHeight() == true) || (isCustomComponent() == false))\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.height\", getInitialHeight());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.height=null;\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.resizable\", isResizable());\n\n\t\tif (isResizable() == false)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.widthUnit\", getWidthUnit());\n\t\t\tappendAssignment(buffer, \"settings.heightUnit\", getHeightUnit());\n\t\t}\n\n\t\tif (isCustomComponent() == false)\n\t\t{\n\t\t\tPage page = createPage();\n\t\t\tif (page == null)\n\t\t\t{\n\t\t\t\tthrow new WicketRuntimeException(\"Error creating page for modal dialog.\");\n\t\t\t}\n\t\t\tCharSequence pageUrl;\n\t\t\tRequestCycle requestCycle = RequestCycle.get();\n\n\t\t\tpage.getSession().getPageManager().touchPage(page);\n\t\t\tif (page.isPageStateless())\n\t\t\t{\n\t\t\t\tpageUrl = requestCycle.urlFor(page.getClass(), page.getPageParameters());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIRequestHandler handler = new RenderPageRequestHandler(new PageProvider(page));\n\t\t\t\tpageUrl = requestCycle.urlFor(handler);\n\t\t\t}\n\n\t\t\tappendAssignment(buffer, \"settings.src\", pageUrl);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbuffer.append(\"settings.element=element;\\n\");\n\t\t}\n\n\t\tif (getCookieName() != null)\n\t\t{\n\t\t\tappendAssignment(buffer, \"settings.cookieId\", getCookieName());\n\t\t}\n\n\t\tString title = getTitle() != null ? getTitle().getObject() : null;\n\t\tif (title != null)\n\t\t{\n\t\t\tString escaped = getDefaultModelObjectAsString(title);\n\t\t\tappendAssignment(buffer, \"settings.title\", escaped);\n\t\t}\n\n\t\tif (getMaskType() == MaskType.TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"transparent\\\";\\n\");\n\t\t}\n\t\telse if (getMaskType() == MaskType.SEMI_TRANSPARENT)\n\t\t{\n\t\t\tbuffer.append(\"settings.mask=\\\"semi-transparent\\\";\\n\");\n\t\t}\n\n\t\tappendAssignment(buffer, \"settings.autoSize\", autoSize);\n\n\t\tappendAssignment(buffer, \"settings.unloadConfirmation\", showUnloadConfirmation());\n\n\t\t// set true if we set a windowclosedcallback\n\t\tboolean haveCloseCallback = false;\n\n\t\t// in case user is interested in window close callback or we have a pagemap to clean attach\n\t\t// notification request\n\t\tif (windowClosedCallback != null)\n\t\t{\n\t\t\tWindowClosedBehavior behavior = getBehaviors(WindowClosedBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onClose = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\" };\\n\");\n\n\t\t\thaveCloseCallback = true;\n\t\t}\n\n\t\t// in case we didn't set windowclosecallback, we need at least callback on close button, to\n\t\t// close window property (thus cleaning the shown flag)\n\t\tif ((closeButtonCallback != null) || (haveCloseCallback == false))\n\t\t{\n\t\t\tCloseButtonBehavior behavior = getBehaviors(CloseButtonBehavior.class).get(0);\n\t\t\tbuffer.append(\"settings.onCloseButton = function() { \");\n\t\t\tbuffer.append(behavior.getCallbackScript());\n\t\t\tbuffer.append(\";return false;};\\n\");\n\t\t}\n\n\t\tpostProcessSettings(buffer);\n\n\t\tbuffer.append(getShowJavaScript());\n\t\treturn buffer.toString();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static String applySorting(String query, Sort sort, String alias) {\n\n\t\tAssert.hasText(query);\n\n\t\tif (null == sort || !sort.iterator().hasNext()) {\n\t\t\treturn query;\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder(query);\n\n\t\tif (!ORDER_BY.matcher(query).matches()) {\n\t\t\tbuilder.append(\" order by \");\n\t\t} else {\n\t\t\tbuilder.append(\", \");\n\t\t}\n\n\t\tSet<String> aliases = getOuterJoinAliases(query);\n\n\t\tfor (Order order : sort) {\n\t\t\tbuilder.append(getOrderClause(aliases, alias, order)).append(\", \");\n\t\t}\n\n\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\treturn builder.toString();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static String applySorting(String query, Sort sort, String alias) {\n\n\t\tAssert.hasText(query);\n\n\t\tif (null == sort || !sort.iterator().hasNext()) {\n\t\t\treturn query;\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder(query);\n\n\t\tif (!ORDER_BY.matcher(query).matches()) {\n\t\t\tbuilder.append(\" order by \");\n\t\t} else {\n\t\t\tbuilder.append(\", \");\n\t\t}\n\n\t\tSet<String> aliases = getOuterJoinAliases(query);\n\t\tSet<String> functionAliases = getFunctionAliases(query);\n\n\t\tfor (Order order : sort) {\n\t\t\tbuilder.append(getOrderClause(aliases, functionAliases, alias, order)).append(\", \");\n\t\t}\n\n\t\tbuilder.delete(builder.length() - 2, builder.length());\n\n\t\treturn builder.toString();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private static String getOrderClause(Set<String> joinAliases, String alias, Order order) {\n\n\t\tString property = order.getProperty();\n\t\tboolean qualifyReference = !property.contains(\"(\"); // ( indicates a function\n\n\t\tfor (String joinAlias : joinAliases) {\n\t\t\tif (property.startsWith(joinAlias.concat(\".\"))) {\n\t\t\t\tqualifyReference = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tString reference = qualifyReference && StringUtils.hasText(alias) ? String.format(\"%s.%s\", alias, property)\n\t\t\t\t: property;\n\t\tString wrapped = order.isIgnoreCase() ? String.format(\"lower(%s)\", reference) : reference;\n\n\t\treturn String.format(\"%s %s\", wrapped, toJpaDirection(order));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private static String getOrderClause(Set<String> joinAliases, Set<String> functionAlias, String alias, Order order) {\n\n\t\tString property = order.getProperty();\n\n\t\tcheckSortExpression(order);\n\n\t\tif (functionAlias.contains(property)) {\n\t\t\treturn String.format(\"%s %s\", property, toJpaDirection(order));\n\t\t}\n\n\t\tboolean qualifyReference = !property.contains(\"(\"); // ( indicates a function\n\n\t\tfor (String joinAlias : joinAliases) {\n\t\t\tif (property.startsWith(joinAlias.concat(\".\"))) {\n\t\t\t\tqualifyReference = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tString reference = qualifyReference && StringUtils.hasText(alias) ? String.format(\"%s.%s\", alias, property)\n\t\t\t\t: property;\n\t\tString wrapped = order.isIgnoreCase() ? String.format(\"lower(%s)\", reference) : reference;\n\n\t\treturn String.format(\"%s %s\", wrapped, toJpaDirection(order));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private JpaSort(List<Order> orders, Direction direction, List<Path<?, ?>> paths) {\n\t\tsuper(combine(orders, direction, paths));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private JpaSort(List<Order> orders) {\n\t\tsuper(orders);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private String getResponseToken(ServletRequest request) {\n        if (request.getParameter(FederationConstants.PARAM_RESULT) != null) {\n            return request.getParameter(FederationConstants.PARAM_RESULT);\n        } else if (request.getParameter(SAMLSSOConstants.SAML_RESPONSE) != null) {\n            return request.getParameter(SAMLSSOConstants.SAML_RESPONSE);\n        }\n        \n        return null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private String getResponseToken(ServletRequest request) {\n        if (request.getParameter(FederationConstants.PARAM_RESULT) != null) {\n            return request.getParameter(FederationConstants.PARAM_RESULT);\n        } else if (request.getParameter(SAMLSSOConstants.SAML_RESPONSE) != null) {\n            return request.getParameter(SAMLSSOConstants.SAML_RESPONSE);\n        }\n        \n        return null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void testIfTransformer() {\n        final Transformer<Object, String> a = TransformerUtils.constantTransformer(\"A\");\n        final Transformer<Object, String> b = TransformerUtils.constantTransformer(\"B\");\n        final Transformer<Object, String> c = TransformerUtils.constantTransformer(\"C\");\n\n        assertEquals(\"A\", TransformerUtils.ifTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n        assertEquals(\"B\", TransformerUtils.ifTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n\n        Predicate<Integer> lessThanFivePredicate = new Predicate<Integer>() {\n            public boolean evaluate(Integer value) {\n                return value < 5;\n            }\n        };\n        // if/else tests\n        assertEquals(\"A\", TransformerUtils.<Integer, String>ifTransformer(lessThanFivePredicate, a, b).transform(1));\n        assertEquals(\"B\", TransformerUtils.<Integer, String>ifTransformer(lessThanFivePredicate, a, b).transform(5));\n        \n        // if tests\n        Predicate<String> equalsAPredicate = EqualPredicate.equalPredicate(\"A\");\n        assertEquals(\"C\", TransformerUtils.<String>ifTransformer(equalsAPredicate, c).transform(\"A\"));\n        assertEquals(\"B\", TransformerUtils.<String>ifTransformer(equalsAPredicate, c).transform(\"B\"));\n\n        try {\n            TransformerUtils.ifTransformer(null, null);\n            fail();\n        } catch (final NullPointerException ex) {}\n        try {\n            TransformerUtils.ifTransformer(TruePredicate.truePredicate(), null);\n            fail();\n        } catch (final NullPointerException ex) {}\n        try {\n            TransformerUtils.ifTransformer(null, ConstantTransformer.constantTransformer(\"A\"));\n            fail();\n        } catch (final NullPointerException ex) {}\n        try {\n            TransformerUtils.ifTransformer(null, null, null);\n            fail();\n        } catch (final NullPointerException ex) {}\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void testIfTransformer() {\n        final Transformer<Object, String> a = TransformerUtils.constantTransformer(\"A\");\n        final Transformer<Object, String> b = TransformerUtils.constantTransformer(\"B\");\n        final Transformer<Object, String> c = TransformerUtils.constantTransformer(\"C\");\n\n        assertEquals(\"A\", TransformerUtils.ifTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n        assertEquals(\"B\", TransformerUtils.ifTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n\n        Predicate<Integer> lessThanFivePredicate = new Predicate<Integer>() {\n            @Override\n            public boolean evaluate(Integer value) {\n                return value < 5;\n            }\n        };\n        // if/else tests\n        assertEquals(\"A\", TransformerUtils.<Integer, String>ifTransformer(lessThanFivePredicate, a, b).transform(1));\n        assertEquals(\"B\", TransformerUtils.<Integer, String>ifTransformer(lessThanFivePredicate, a, b).transform(5));\n        \n        // if tests\n        Predicate<String> equalsAPredicate = EqualPredicate.equalPredicate(\"A\");\n        assertEquals(\"C\", TransformerUtils.<String>ifTransformer(equalsAPredicate, c).transform(\"A\"));\n        assertEquals(\"B\", TransformerUtils.<String>ifTransformer(equalsAPredicate, c).transform(\"B\"));\n\n        try {\n            TransformerUtils.ifTransformer(null, null);\n            fail();\n        } catch (final NullPointerException ex) {}\n        try {\n            TransformerUtils.ifTransformer(TruePredicate.truePredicate(), null);\n            fail();\n        } catch (final NullPointerException ex) {}\n        try {\n            TransformerUtils.ifTransformer(null, ConstantTransformer.constantTransformer(\"A\"));\n            fail();\n        } catch (final NullPointerException ex) {}\n        try {\n            TransformerUtils.ifTransformer(null, null, null);\n            fail();\n        } catch (final NullPointerException ex) {}\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void testSingletonPatternInSerialization() {\n        final Object[] singletones = new Object[] {\n                CloneTransformer.INSTANCE,\n                ExceptionTransformer.INSTANCE,\n                NOPTransformer.INSTANCE,\n                StringValueTransformer.stringValueTransformer(),\n        };\n\n        for (final Object original : singletones) {\n            TestUtils.assertSameAfterSerialization(\"Singleton pattern broken for \" + original.getClass(), original);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void testSingletonPatternInSerialization() {\n        final Object[] singletones = new Object[] {\n                ExceptionTransformer.INSTANCE,\n                NOPTransformer.INSTANCE,\n                StringValueTransformer.stringValueTransformer(),\n        };\n\n        for (final Object original : singletones) {\n            TestUtils.assertSameAfterSerialization(\"Singleton pattern broken for \" + original.getClass(), original);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "V>> nextIterator(int count) {\n                if ( ! keyIterator.hasNext() ) {\n                    return null;\n                }\n                final K key = keyIterator.next();\n                final Transformer<V, Entry<K, V>> transformer = new Transformer<V, Entry<K, V>>() {\n                    public Entry<K, V> transform(final V input) {\n                        return new Entry<K, V>() {\n                            public K getKey() {\n                                return key;\n                            }\n                            public V getValue() {\n                                return input;\n                            }\n                            public V setValue(V value) {\n                                throw new UnsupportedOperationException();\n                            }\n                        };\n                    }\n                };\n                return new TransformIterator<V, Entry<K, V>>(new ValuesIterator(key), transformer);\n            }",
    "is_vulnerable": true
  },
  {
    "function_code": "V>> nextIterator(int count) {\n                if ( ! keyIterator.hasNext() ) {\n                    return null;\n                }\n                final K key = keyIterator.next();\n                final Transformer<V, Entry<K, V>> transformer = new Transformer<V, Entry<K, V>>() {\n                    @Override\n                    public Entry<K, V> transform(final V input) {\n                        return new Entry<K, V>() {\n                            @Override\n                            public K getKey() {\n                                return key;\n                            }\n                            @Override\n                            public V getValue() {\n                                return input;\n                            }\n                            @Override\n                            public V setValue(V value) {\n                                throw new UnsupportedOperationException();\n                            }\n                        };\n                    }\n                };\n                return new TransformIterator<V, Entry<K, V>>(new ValuesIterator(key), transformer);\n            }",
    "is_vulnerable": false
  },
  {
    "function_code": "V> transform(final V input) {\n                        return new Entry<K, V>() {\n                            public K getKey() {\n                                return key;\n                            }\n                            public V getValue() {\n                                return input;\n                            }\n                            public V setValue(V value) {\n                                throw new UnsupportedOperationException();\n                            }\n                        };\n                    }",
    "is_vulnerable": true
  },
  {
    "function_code": "V> transform(final V input) {\n                        return new Entry<K, V>() {\n                            @Override\n                            public K getKey() {\n                                return key;\n                            }\n                            @Override\n                            public V getValue() {\n                                return input;\n                            }\n                            @Override\n                            public V setValue(V value) {\n                                throw new UnsupportedOperationException();\n                            }\n                        };\n                    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                MultiValueMap.this.remove(key);\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean hasNext() {\n            return iterator.hasNext();\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean hasNext() {\n            return iterator.hasNext();\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public V next() {\n            return iterator.next();\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public V next() {\n            return iterator.next();\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public T create() {\n            try {\n                return clazz.newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public T create() {\n            try {\n                return clazz.newInstance();\n            } catch (final Exception ex) {\n                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "T> cloneTransformer() {\n        return (Transformer<T, T>) INSTANCE;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "T> cloneTransformer() {\n        return INSTANCE;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public EdgeOperation(String sourceJobName, String targetJobName) {\n        this.source = Jenkins.getInstance().getItemByFullName(sourceJobName.trim(), AbstractProject.class);\n        this.target = Jenkins.getInstance().getItemByFullName(targetJobName, AbstractProject.class);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public EdgeOperation(String sourceJobName, String targetJobName) {\n        this.source = Jenkins.getInstance().getItemByFullName(sourceJobName.trim(), AbstractProject.class);\n        this.target = Jenkins.getInstance().getItemByFullName(targetJobName, AbstractProject.class);\n        source.checkPermission(Permission.CONFIGURE);\n        target.checkPermission(Permission.CONFIGURE);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HierarchicalStreamReader createReader(File in) {\n        try {\n            SAXBuilder builder = new SAXBuilder();\n            Document document = builder.build(in);\n            return new JDomReader(document, getNameCoder());\n        } catch (IOException e) {\n            throw new StreamException(e);\n        } catch (JDOMException e) {\n            throw new StreamException(e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HierarchicalStreamReader createReader(File in) {\n        try {\n            final SAXBuilder builder = createBuilder();\n            final Document document = builder.build(in);\n            return new JDomReader(document, getNameCoder());\n        } catch (IOException e) {\n            throw new StreamException(e);\n        } catch (JDOMException e) {\n            throw new StreamException(e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HierarchicalStreamReader createReader(File in) {\n        try {\n            SAXReader reader = new SAXReader();\n            Document document = reader.read(in);\n            return new Dom4JReader(document, getNameCoder());\n        } catch (DocumentException e) {\n            throw new StreamException(e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HierarchicalStreamReader createReader(File in) {\n        try {\n            final Document document = createReader().read(in);\n            return new Dom4JReader(document, getNameCoder());\n        } catch (DocumentException e) {\n            throw new StreamException(e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HierarchicalStreamReader createReader(File in) {\n        try {\n            SAXBuilder builder = new SAXBuilder();\n            Document document = builder.build(in);\n            return new JDom2Reader(document, getNameCoder());\n        } catch (IOException e) {\n            throw new StreamException(e);\n        } catch (JDOMException e) {\n            throw new StreamException(e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HierarchicalStreamReader createReader(File in) {\n        try {\n            final SAXBuilder builder = createBuilder();\n            final Document document = builder.build(in);\n            return new JDom2Reader(document, getNameCoder());\n        } catch (IOException e) {\n            throw new StreamException(e);\n        } catch (JDOMException e) {\n            throw new StreamException(e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Object newInstance(final Class<?> type) {\n        if (exception != null) {\n            final ObjectAccessException ex = new ObjectAccessException(\"Cannot construct type\", exception);\n            ex.add(\"construction-type\", type.getName());\n            throw ex;\n        }\n        ErrorWritingException ex = null;\n        try {\n            return unsafe.allocateInstance(type);\n        } catch (final SecurityException e) {\n            ex = new ObjectAccessException(\"Cannot construct type\", e);\n        } catch (final InstantiationException e) {\n            ex = new ConversionException(\"Cannot construct type\", e);\n        } catch (final IllegalArgumentException e) {\n            ex = new ObjectAccessException(\"Cannot construct type\", e);\n        }\n        ex.add(\"construction-type\", type.getName());\n        throw ex;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Object newInstance(final Class<?> type) {\n        if (exception != null) {\n            final ObjectAccessException ex = new ObjectAccessException(\"Cannot construct type\", exception);\n            ex.add(\"construction-type\", type.getName());\n            throw ex;\n        }\n        ErrorWritingException ex = null;\n        if (type == void.class || type == Void.class) {\n            ex = new ConversionException(\"Type void cannot have an instance\");\n        } else {\n            try {\n                return unsafe.allocateInstance(type);\n            } catch (final SecurityException e) {\n                ex = new ObjectAccessException(\"Cannot construct type\", e);\n            } catch (final InstantiationException e) {\n                ex = new ConversionException(\"Cannot construct type\", e);\n            } catch (final IllegalArgumentException e) {\n                ex = new ObjectAccessException(\"Cannot construct type\", e);\n            }\n        }\n        ex.add(\"construction-type\", type.getName());\n        throw ex;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean allows(Class<?> type) {\n        return type != null && type.isPrimitive() || Primitives.isBoxed(type);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean allows(Class<?> type) {\n        return type != null && type != void.class && type != Void.class && type.isPrimitive()\n            || Primitives.isBoxed(type);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean shouldEncodeRelativePath(Resource location) {\n\t\treturn location instanceof UrlResource &&\n\t\t\t\tthis.urlPathHelper != null && this.urlPathHelper.isUrlDecode();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean shouldEncodeRelativePath(Resource location) {\n\t\treturn (location instanceof UrlResource && this.urlPathHelper != null && this.urlPathHelper.isUrlDecode());\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private String cleanLeadingSlash(String path) {\n\t\tboolean slash = false;\n\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\tif (path.charAt(i) == '/') {\n\t\t\t\tslash = true;\n\t\t\t}\n\t\t\telse if (path.charAt(i) > ' ' && path.charAt(i) != 127) {\n\t\t\t\tif (i == 0 || (i == 1 && slash)) {\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\tpath = slash ? \"/\" + path.substring(i) : path.substring(i);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Path after trimming leading '/' and control characters: \" + path);\n\t\t\t\t}\n\t\t\t\treturn path;\n\t\t\t}\n\t\t}\n\t\treturn (slash ? \"/\" : \"\");\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private String cleanLeadingSlash(String path) {\n\t\tboolean slash = false;\n\t\tfor (int i = 0; i < path.length(); i++) {\n\t\t\tif (path.charAt(i) == '/') {\n\t\t\t\tslash = true;\n\t\t\t}\n\t\t\telse if (path.charAt(i) > ' ' && path.charAt(i) != 127) {\n\t\t\t\tif (i == 0 || (i == 1 && slash)) {\n\t\t\t\t\treturn path;\n\t\t\t\t}\n\t\t\t\tpath = (slash ? \"/\" + path.substring(i) : path.substring(i));\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Path after trimming leading '/' and control characters: [\" + path + \"]\");\n\t\t\t\t}\n\t\t\t\treturn path;\n\t\t\t}\n\t\t}\n\t\treturn (slash ? \"/\" : \"\");\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean isInvalidPath(String path) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Applying \\\"invalid path\\\" checks to path: \" + path);\n\t\t}\n\t\tif (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Path contains \\\"WEB-INF\\\" or \\\"META-INF\\\".\");\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (path.contains(\":/\")) {\n\t\t\tString relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n\t\t\tif (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Path represents URL or has \\\"url:\\\" prefix.\");\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (path.contains(\"..\")) {\n\t\t\tpath = StringUtils.cleanPath(path);\n\t\t\tif (path.contains(\"../\")) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Path contains \\\"../\\\" after call to StringUtils#cleanPath.\");\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean isInvalidPath(String path) {\n\t\tif (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n\t\t\tlogger.trace(\"Path contains \\\"WEB-INF\\\" or \\\"META-INF\\\".\");\n\t\t\treturn true;\n\t\t}\n\t\tif (path.contains(\":/\")) {\n\t\t\tString relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n\t\t\tif (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n\t\t\t\tlogger.trace(\"Path represents URL or has \\\"url:\\\" prefix.\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif (path.contains(\"..\")) {\n\t\t\tpath = StringUtils.cleanPath(path);\n\t\t\tif (path.contains(\"../\")) {\n\t\t\t\tlogger.trace(\"Path contains \\\"../\\\" after call to StringUtils#cleanPath.\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected SimpleBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel) {\n\t\tSimpleBrokerMessageHandler handler = new SimpleBrokerMessageHandler(getClientInboundChannel(),\n\t\t\t\tgetClientOutboundChannel(), brokerChannel, getDestinationPrefixes());\n\t\tif (this.taskScheduler != null) {\n\t\t\thandler.setTaskScheduler(this.taskScheduler);\n\t\t}\n\t\tif (this.heartbeat != null) {\n\t\t\thandler.setHeartbeatValue(this.heartbeat);\n\t\t}\n\t\treturn handler;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected SimpleBrokerMessageHandler getMessageHandler(SubscribableChannel brokerChannel) {\n\t\tSimpleBrokerMessageHandler handler = new SimpleBrokerMessageHandler(getClientInboundChannel(),\n\t\t\t\tgetClientOutboundChannel(), brokerChannel, getDestinationPrefixes());\n\t\tif (this.taskScheduler != null) {\n\t\t\thandler.setTaskScheduler(this.taskScheduler);\n\t\t}\n\t\tif (this.heartbeat != null) {\n\t\t\thandler.setHeartbeatValue(this.heartbeat);\n\t\t}\n\t\thandler.setSelectorHeaderName(this.selectorHeaderName);\n\t\treturn handler;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setSelectorHeaderName(String selectorHeaderName) {\n\t\tAssert.notNull(selectorHeaderName, \"'selectorHeaderName' must not be null\");\n\t\tthis.selectorHeaderName = selectorHeaderName;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setSelectorHeaderName(String selectorHeaderName) {\n\t\tthis.selectorHeaderName = StringUtils.hasText(selectorHeaderName) ? selectorHeaderName : null;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void addSubscriptionInternal(\n\t\t\tString sessionId, String subsId, String destination, Message<?> message) {\n\n\t\tExpression expression = null;\n\t\tMessageHeaders headers = message.getHeaders();\n\t\tString selector = SimpMessageHeaderAccessor.getFirstNativeHeader(getSelectorHeaderName(), headers);\n\t\tif (selector != null) {\n\t\t\ttry {\n\t\t\t\texpression = this.expressionParser.parseExpression(selector);\n\t\t\t\tthis.selectorHeaderInUse = true;\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Subscription selector: [\" + selector + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to parse selector: \" + selector, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);\n\t\tthis.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void addSubscriptionInternal(\n\t\t\tString sessionId, String subsId, String destination, Message<?> message) {\n\n\t\tExpression expression = getSelectorExpression(message.getHeaders());\n\t\tthis.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression);\n\t\tthis.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setSubscriptionRegistry(SubscriptionRegistry subscriptionRegistry) {\n\t\tAssert.notNull(subscriptionRegistry, \"SubscriptionRegistry must not be null\");\n\t\tthis.subscriptionRegistry = subscriptionRegistry;\n\t\tinitPathMatcherToUse();\n\t\tinitCacheLimitToUse();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setSubscriptionRegistry(SubscriptionRegistry subscriptionRegistry) {\n\t\tAssert.notNull(subscriptionRegistry, \"SubscriptionRegistry must not be null\");\n\t\tthis.subscriptionRegistry = subscriptionRegistry;\n\t\tinitPathMatcherToUse();\n\t\tinitCacheLimitToUse();\n\t\tinitSelectorHeaderNameToUse();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "new FilterChain() {\n\n\t\t\t@Override\n\t\t\tpublic void doFilter(ServletRequest filterRequest,\n\t\t\t\t\tServletResponse filterResponse) throws IOException, ServletException {\n\t\t\t\tassertEquals(\"Invalid method\", \"POST\",\n\t\t\t\t\t\t((HttpServletRequest) filterRequest).getMethod());\n\t\t\t}\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "new FilterChain() {\n\n\t\t\t@Override\n\t\t\tpublic void doFilter(ServletRequest filterRequest,\n\t\t\t\t\tServletResponse filterResponse) throws IOException, ServletException {\n\t\t\t\tassertEquals(\"Invalid method\", expectedMethod,\n\t\t\t\t\t\t((HttpServletRequest) filterRequest).getMethod());\n\t\t\t}\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setUp() {\n\t\tconverter = new Jaxb2CollectionHttpMessageConverter<Collection<Object>>();\n\t\trootElementListType = new ParameterizedTypeReference<List<RootElement>>() {}.getType();\n\t\trootElementSetType = new ParameterizedTypeReference<Set<RootElement>>() {}.getType();\n\t\ttypeListType = new ParameterizedTypeReference<List<TestType>>() {}.getType();\n\t\ttypeSetType = new ParameterizedTypeReference<Set<TestType>>() {}.getType();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setUp() {\n\t\tconverter = new Jaxb2CollectionHttpMessageConverter<>();\n\t\trootElementListType = new ParameterizedTypeReference<List<RootElement>>() {}.getType();\n\t\trootElementSetType = new ParameterizedTypeReference<Set<RootElement>>() {}.getType();\n\t\ttypeListType = new ParameterizedTypeReference<List<TestType>>() {}.getType();\n\t\ttypeSetType = new ParameterizedTypeReference<Set<TestType>>() {}.getType();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public HttpMethodRequestWrapper(HttpServletRequest request, String method) {\n\t\t\tsuper(request);\n\t\t\tthis.method = method.toUpperCase(Locale.ENGLISH);\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public HttpMethodRequestWrapper(HttpServletRequest request, String method) {\n\t\t\tsuper(request);\n\t\t\tthis.method = method;\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public ResourceRegion toResourceRegion(Resource resource) {\n\t\t// Don't try to determine contentLength on InputStreamResource - cannot be read afterwards...\n\t\t// Note: custom InputStreamResource subclasses could provide a pre-calculated content length!\n\t\tAssert.isTrue(resource.getClass() != InputStreamResource.class,\n\t\t\t\t\"Cannot convert an InputStreamResource to a ResourceRegion\");\n\t\ttry {\n\t\t\tlong contentLength = resource.contentLength();\n\t\t\tAssert.isTrue(contentLength > 0, \"Resource content length should be > 0\");\n\t\t\tlong start = getRangeStart(contentLength);\n\t\t\tlong end = getRangeEnd(contentLength);\n\t\t\treturn new ResourceRegion(resource, start, end - start + 1);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Failed to convert Resource to ResourceRegion\", ex);\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ResourceRegion toResourceRegion(Resource resource) {\n\t\t// Don't try to determine contentLength on InputStreamResource - cannot be read afterwards...\n\t\t// Note: custom InputStreamResource subclasses could provide a pre-calculated content length!\n\t\tAssert.isTrue(resource.getClass() != InputStreamResource.class,\n\t\t\t\t\"Cannot convert an InputStreamResource to a ResourceRegion\");\n\t\tlong contentLength = getLengthFor(resource);\n\t\tlong start = getRangeStart(contentLength);\n\t\tlong end = getRangeEnd(contentLength);\n\t\treturn new ResourceRegion(resource, start, end - start + 1);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static List<HttpRange> parseRanges(@Nullable String ranges) {\n\t\tif (!StringUtils.hasLength(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tif (!ranges.startsWith(BYTE_RANGE_PREFIX)) {\n\t\t\tthrow new IllegalArgumentException(\"Range '\" + ranges + \"' does not start with 'bytes='\");\n\t\t}\n\t\tranges = ranges.substring(BYTE_RANGE_PREFIX.length());\n\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(ranges, \",\");\n\t\tList<HttpRange> result = new ArrayList<>(tokens.length);\n\t\tfor (String token : tokens) {\n\t\t\tresult.add(parseRange(token));\n\t\t}\n\t\treturn result;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static List<HttpRange> parseRanges(@Nullable String ranges) {\n\t\tif (!StringUtils.hasLength(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tif (!ranges.startsWith(BYTE_RANGE_PREFIX)) {\n\t\t\tthrow new IllegalArgumentException(\"Range '\" + ranges + \"' does not start with 'bytes='\");\n\t\t}\n\t\tranges = ranges.substring(BYTE_RANGE_PREFIX.length());\n\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(ranges, \",\");\n\t\tAssert.isTrue(tokens.length <= MAX_RANGES, () -> \"Too many ranges \" + tokens.length);\n\t\tList<HttpRange> result = new ArrayList<>(tokens.length);\n\t\tfor (String token : tokens) {\n\t\t\tresult.add(parseRange(token));\n\t\t}\n\t\treturn result;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource) {\n\t\tif (CollectionUtils.isEmpty(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<ResourceRegion> regions = new ArrayList<>(ranges.size());\n\t\tfor (HttpRange range : ranges) {\n\t\t\tregions.add(range.toResourceRegion(resource));\n\t\t}\n\t\treturn regions;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource) {\n\t\tif (CollectionUtils.isEmpty(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<ResourceRegion> regions = new ArrayList<>(ranges.size());\n\t\tfor (HttpRange range : ranges) {\n\t\t\tregions.add(range.toResourceRegion(resource));\n\t\t}\n\t\tif (ranges.size() > 1) {\n\t\t\tlong length = getLengthFor(resource);\n\t\t\tlong total = regions.stream().map(ResourceRegion::getCount).reduce(0L, (count, sum) -> sum + count);\n\t\t\tAssert.isTrue(total < length,\n\t\t\t\t\t() -> \"The sum of all ranges (\" + total + \") \" +\n\t\t\t\t\t\t\t\"should be less than the resource length (\" + length + \")\");\n\t\t}\n\t\treturn regions;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t\tif (processExternalEntities) {\n\t\t\tsetSupportDtd(true);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t\tif (processExternalEntities) {\n\t\t\tsetSupportDtd(true);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Source processSource(Source source) {\n\t\tif (source instanceof StreamSource) {\n\t\t\tStreamSource streamSource = (StreamSource) source;\n\t\t\tInputSource inputSource = new InputSource(streamSource.getInputStream());\n\t\t\ttry {\n\t\t\t\tXMLReader xmlReader = XMLReaderFactory.createXMLReader();\n\t\t\t\tString featureName = \"http://xml.org/sax/features/external-general-entities\";\n\t\t\t\txmlReader.setFeature(featureName, isProcessExternalEntities());\n\t\t\t\tif (!isProcessExternalEntities()) {\n\t\t\t\t\txmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n\t\t\t\t}\n\t\t\t\treturn new SAXSource(xmlReader, inputSource);\n\t\t\t}\n\t\t\tcatch (SAXException ex) {\n\t\t\t\tlogger.warn(\"Processing of external entities could not be disabled\", ex);\n\t\t\t\treturn source;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn source;\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Source processSource(Source source) {\n\t\tif (source instanceof StreamSource) {\n\t\t\tStreamSource streamSource = (StreamSource) source;\n\t\t\tInputSource inputSource = new InputSource(streamSource.getInputStream());\n\t\t\ttry {\n\t\t\t\tXMLReader xmlReader = XMLReaderFactory.createXMLReader();\n\t\t\t\txmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", !isSupportDtd());\n\t\t\t\tString featureName = \"http://xml.org/sax/features/external-general-entities\";\n\t\t\t\txmlReader.setFeature(featureName, isProcessExternalEntities());\n\t\t\t\tif (!isProcessExternalEntities()) {\n\t\t\t\t\txmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n\t\t\t\t}\n\t\t\t\treturn new SAXSource(xmlReader, inputSource);\n\t\t\t}\n\t\t\tcatch (SAXException ex) {\n\t\t\t\tlogger.warn(\"Processing of external entities could not be disabled\", ex);\n\t\t\t\treturn source;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn source;\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected XMLInputFactory createXmlInputFactory() {\n\t\tXMLInputFactory inputFactory = XMLInputFactory.newInstance();\n\t\tinputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n\t\tinputFactory.setXMLResolver(NO_OP_XML_RESOLVER);\n\t\treturn inputFactory;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected XMLInputFactory createXmlInputFactory() {\n\t\tXMLInputFactory inputFactory = XMLInputFactory.newInstance();\n\t\tinputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n\t\tinputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n\t\tinputFactory.setXMLResolver(NO_OP_XML_RESOLVER);\n\t\treturn inputFactory;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void failsWhenSettingContextForExpression_SPR12326() {\n\t\tSpelExpressionParser parser = new SpelExpressionParser(\n\t\t\t\tnew SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, getClass().getClassLoader()));\n\t\tPerson3 person = new Person3(\"foo\", 1);\n\t\tSpelExpression expression = parser.parseRaw(\"#it?.age?.equals([0])\");\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(new Object[] {1});\n\t\tcontext.setVariable(\"it\", person);\n\t\texpression.setEvaluationContext(context);\n\t\tassertTrue(expression.getValue(Boolean.class));\n\t\tassertTrue(expression.getValue(Boolean.class));\n\t\tassertCanCompile(expression);\n\t\tassertTrue(expression.getValue(Boolean.class));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void failsWhenSettingContextForExpression_SPR12326() {\n\t\tSpelExpressionParser parser = new SpelExpressionParser(\n\t\t\t\tnew SpelParserConfiguration(SpelCompilerMode.OFF, getClass().getClassLoader()));\n\t\tPerson3 person = new Person3(\"foo\", 1);\n\t\tSpelExpression expression = parser.parseRaw(\"#it?.age?.equals([0])\");\n\t\tStandardEvaluationContext context = new StandardEvaluationContext(new Object[] {1});\n\t\tcontext.setVariable(\"it\", person);\n\t\texpression.setEvaluationContext(context);\n\t\tassertTrue(expression.getValue(Boolean.class));\n\t\t// This will trigger compilation (second usage)\n\t\tassertTrue(expression.getValue(Boolean.class));\n\t\tcontext.setVariable(\"it\", null);\n\t\tassertNull(expression.getValue(Boolean.class));\n\t\t\n\t\tassertCanCompile(expression);\n\t\t\n\t\tcontext.setVariable(\"it\", person);\n\t\tassertTrue(expression.getValue(Boolean.class));\n\t\tcontext.setVariable(\"it\", null);\n\t\tassertNull(expression.getValue(Boolean.class));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tPropertyAccessor accessorToUse = this.cachedReadAccessor;\n\t\tif (!(accessorToUse instanceof CompilablePropertyAccessor)) {\n\t\t\tthrow new IllegalStateException(\"Property accessor is not compilable: \" + accessorToUse);\n\t\t}\n\t\t((CompilablePropertyAccessor) accessorToUse).generateCode(this.name, mv, cf);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tPropertyAccessor accessorToUse = this.cachedReadAccessor;\n\t\tif (!(accessorToUse instanceof CompilablePropertyAccessor)) {\n\t\t\tthrow new IllegalStateException(\"Property accessor is not compilable: \" + accessorToUse);\n\t\t}\n\t\tLabel skipIfNull = null;\n\t\tif (nullSafe) {\n\t\t\tmv.visitInsn(DUP);\n\t\t\tskipIfNull = new Label();\n\t\t\tLabel continueLabel = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL,continueLabel);\n\t\t\tCodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);\n\t\t\tmv.visitJumpInsn(GOTO, skipIfNull);\n\t\t\tmv.visitLabel(continueLabel);\n\t\t}\n\t\t((CompilablePropertyAccessor) accessorToUse).generateCode(this.name, mv, cf);\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t\tif (originalPrimitiveExitTypeDescriptor != null) {\n\t\t\t// The output of the accessor is a primitive but from the block above it might be null,\n\t\t\t// so to have a common stack element type at skipIfNull target it is necessary\n\t\t\t// to box the primitive\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, originalPrimitiveExitTypeDescriptor);\n\t\t}\n\t\tif (skipIfNull != null) {\n\t\t\tmv.visitLabel(skipIfNull);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public TypedValue getValue() {\n\t\t\tTypedValue value =\n\t\t\t\t\tthis.ref.getValueInternal(this.contextObject, this.evalContext, this.autoGrowNullReferences);\n\t\t\tPropertyAccessor accessorToUse = this.ref.cachedReadAccessor;\n\t\t\tif (accessorToUse instanceof CompilablePropertyAccessor) {\n\t\t\t\tthis.ref.exitTypeDescriptor =\n\t\t\t\t\t\tCodeFlow.toDescriptor(((CompilablePropertyAccessor) accessorToUse).getPropertyType());\n\t\t\t}\n\t\t\treturn value;\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public TypedValue getValue() {\n\t\t\tTypedValue value =\n\t\t\t\t\tthis.ref.getValueInternal(this.contextObject, this.evalContext, this.autoGrowNullReferences);\n\t\t\tPropertyAccessor accessorToUse = this.ref.cachedReadAccessor;\n\t\t\tif (accessorToUse instanceof CompilablePropertyAccessor) {\n\t\t\t\tthis.ref.setExitTypeDescriptor(CodeFlow.toDescriptor(((CompilablePropertyAccessor) accessorToUse).getPropertyType()));\n\t\t\t}\n\t\t\treturn value;\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private void updateExitTypeDescriptor() {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor) {\n\t\t\tMethod method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();\n\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private void updateExitTypeDescriptor() {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor) {\n\t\t\tMethod method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();\n\t\t\tString descriptor = CodeFlow.toDescriptor(method.getReturnType());\n\t\t\tif (this.nullSafe && CodeFlow.isPrimitive(descriptor)) {\n\t\t\t\toriginalPrimitiveExitTypeDescriptor = descriptor;\n\t\t\t\tthis.exitTypeDescriptor = CodeFlow.toBoxedDescriptor(descriptor);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.exitTypeDescriptor = descriptor;\n\t\t\t}\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\tthrow new IllegalStateException(\"No applicable cached executor found: \" + executorToCheck);\n\t\t}\n\n\t\tReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get();\n\t\tMethod method = methodExecutor.getMethod();\n\t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n\t\tString descriptor = cf.lastDescriptor();\n\n\t\tif (descriptor == null) {\n\t\t\tif (!isStaticMethod) {\n\t\t\t\t// Nothing on the stack but something is needed\n\t\t\t\tcf.loadTarget(mv);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (isStaticMethod) {\n\t\t\t\t// Something on the stack when nothing is needed\n\t\t\t\tmv.visitInsn(POP);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (CodeFlow.isPrimitive(descriptor)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\n\t\tString classDesc = null;\n\t\tif (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\tclassDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\t}\n\t\telse {\n\t\t\tClass<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass();\n\t\t\tAssert.state(publicDeclaringClass != null, \"No public declaring class\");\n\t\t\tclassDesc = publicDeclaringClass.getName().replace('.', '/');\n\t\t}\n\n\t\tif (!isStaticMethod) {\n\t\t\tif (descriptor == null || !descriptor.substring(1).equals(classDesc)) {\n\t\t\t\tCodeFlow.insertCheckCast(mv, \"L\" + classDesc);\n\t\t\t}\n\t\t}\n\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),\n\t\t\t\tCodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void generateCode(MethodVisitor mv, CodeFlow cf) {\n\t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n\t\tif (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {\n\t\t\tthrow new IllegalStateException(\"No applicable cached executor found: \" + executorToCheck);\n\t\t}\n\n\t\tReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get();\n\t\tMethod method = methodExecutor.getMethod();\n\t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n\t\tString descriptor = cf.lastDescriptor();\n\n\t\tLabel skipIfNull = null;\n\t\tif (descriptor == null && !isStaticMethod) {\n\t\t\t// Nothing on the stack but something is needed\n\t\t\tcf.loadTarget(mv);\n\t\t}\n\t\tif ((descriptor != null || !isStaticMethod) && nullSafe) {\n\t\t\tmv.visitInsn(DUP);\n\t\t\tskipIfNull = new Label();\n\t\t\tLabel continueLabel = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL,continueLabel);\n\t\t\tCodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);\n\t\t\tmv.visitJumpInsn(GOTO, skipIfNull);\n\t\t\tmv.visitLabel(continueLabel);\n\t\t}\n\t\tif (descriptor != null && isStaticMethod) {\n\t\t\t// Something on the stack when nothing is needed\n\t\t\tmv.visitInsn(POP);\n\t\t}\n\t\t\n\t\tif (CodeFlow.isPrimitive(descriptor)) {\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));\n\t\t}\n\n\t\tString classDesc = null;\n\t\tif (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n\t\t\tclassDesc = method.getDeclaringClass().getName().replace('.', '/');\n\t\t}\n\t\telse {\n\t\t\tClass<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass();\n\t\t\tAssert.state(publicDeclaringClass != null, \"No public declaring class\");\n\t\t\tclassDesc = publicDeclaringClass.getName().replace('.', '/');\n\t\t}\n\n\t\tif (!isStaticMethod) {\n\t\t\tif (descriptor == null || !descriptor.substring(1).equals(classDesc)) {\n\t\t\t\tCodeFlow.insertCheckCast(mv, \"L\" + classDesc);\n\t\t\t}\n\t\t}\n\n\t\tgenerateCodeForArguments(mv, cf, method, this.children);\n\t\tmv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),\n\t\t\t\tCodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());\n\t\tcf.pushDescriptor(this.exitTypeDescriptor);\n\t\tif (originalPrimitiveExitTypeDescriptor != null) {\n\t\t\t// The output of the accessor will be a primitive but from the block above it might be null,\n\t\t\t// so to have a 'common stack' element at skipIfNull target we need to box the primitive\n\t\t\tCodeFlow.insertBoxIfNecessary(mv, originalPrimitiveExitTypeDescriptor);\n\t\t}\n\t\tif (skipIfNull != null) {\n\t\t\tmv.visitLabel(skipIfNull);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public int getMajorVersion() {\n\t\treturn 2;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public int getMajorVersion() {\n\t\treturn this.majorVersion;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setMinorVersion(int minorVersion) {\n\t\tif (minorVersion < 3 || minorVersion > 5) {\n\t\t\tthrow new IllegalArgumentException(\"Only Servlet minor versions between 3 and 5 are supported\");\n\t\t}\n\t\tthis.minorVersion = minorVersion;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setMinorVersion(int minorVersion) {\n\t\tthis.minorVersion = minorVersion;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public int getEffectiveMajorVersion() {\n\t\tthrow new UnsupportedOperationException();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public int getEffectiveMajorVersion() {\n\t\treturn this.effectiveMajorVersion;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public int getEffectiveMinorVersion() {\n\t\tthrow new UnsupportedOperationException();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public int getEffectiveMinorVersion() {\n\t\treturn this.effectiveMinorVersion;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t\tif (processExternalEntities) {\n\t\t\tsetSupportDtd(true);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private Source processSource(Source source) {\n\t\tif (StaxUtils.isStaxSource(source) || source instanceof DOMSource) {\n\t\t\treturn source;\n\t\t}\n\n\t\tXMLReader xmlReader = null;\n\t\tInputSource inputSource = null;\n\n\t\tif (source instanceof SAXSource) {\n\t\t\tSAXSource saxSource = (SAXSource) source;\n\t\t\txmlReader = saxSource.getXMLReader();\n\t\t\tinputSource = saxSource.getInputSource();\n\t\t}\n\t\telse if (source instanceof StreamSource) {\n\t\t\tStreamSource streamSource = (StreamSource) source;\n\t\t\tif (streamSource.getInputStream() != null) {\n\t\t\t\tinputSource = new InputSource(streamSource.getInputStream());\n\t\t\t}\n\t\t\telse if (streamSource.getReader() != null) {\n\t\t\t\tinputSource = new InputSource(streamSource.getReader());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinputSource = new InputSource(streamSource.getSystemId());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (xmlReader == null) {\n\t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n\t\t\t}\n\t\t\tString name = \"http://xml.org/sax/features/external-general-entities\";\n\t\t\txmlReader.setFeature(name, isProcessExternalEntities());\n\t\t\tif (!isProcessExternalEntities()) {\n\t\t\t\txmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n\t\t\t}\n\t\t\treturn new SAXSource(xmlReader, inputSource);\n\t\t}\n\t\tcatch (SAXException ex) {\n\t\t\tlogger.warn(\"Processing of external entities could not be disabled\", ex);\n\t\t\treturn source;\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private Source processSource(Source source) {\n\t\tif (StaxUtils.isStaxSource(source) || source instanceof DOMSource) {\n\t\t\treturn source;\n\t\t}\n\n\t\tXMLReader xmlReader = null;\n\t\tInputSource inputSource = null;\n\n\t\tif (source instanceof SAXSource) {\n\t\t\tSAXSource saxSource = (SAXSource) source;\n\t\t\txmlReader = saxSource.getXMLReader();\n\t\t\tinputSource = saxSource.getInputSource();\n\t\t}\n\t\telse if (source instanceof StreamSource) {\n\t\t\tStreamSource streamSource = (StreamSource) source;\n\t\t\tif (streamSource.getInputStream() != null) {\n\t\t\t\tinputSource = new InputSource(streamSource.getInputStream());\n\t\t\t}\n\t\t\telse if (streamSource.getReader() != null) {\n\t\t\t\tinputSource = new InputSource(streamSource.getReader());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinputSource = new InputSource(streamSource.getSystemId());\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tif (xmlReader == null) {\n\t\t\t\txmlReader = XMLReaderFactory.createXMLReader();\n\t\t\t}\n\t\t\txmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", !isSupportDtd());\n\t\t\tString name = \"http://xml.org/sax/features/external-general-entities\";\n\t\t\txmlReader.setFeature(name, isProcessExternalEntities());\n\t\t\tif (!isProcessExternalEntities()) {\n\t\t\t\txmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);\n\t\t\t}\n\t\t\treturn new SAXSource(xmlReader, inputSource);\n\t\t}\n\t\tcatch (SAXException ex) {\n\t\t\tlogger.warn(\"Processing of external entities could not be disabled\", ex);\n\t\t\treturn source;\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setProcessExternalEntities(boolean processExternalEntities) {\n\t\tthis.processExternalEntities = processExternalEntities;\n\t\tif (processExternalEntities) {\n\t\t\tsetSupportDtd(true);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate,\n\t\t\tRuntimeBeanReference userRegistry, ParserContext context, Object source) {\n\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n\n\t\tConstructorArgumentValues cavs = new ConstructorArgumentValues();\n\t\tcavs.addIndexedArgumentValue(0, inChannel);\n\t\tcavs.addIndexedArgumentValue(1, outChannel);\n\t\tcavs.addIndexedArgumentValue(2, brokerChannel);\n\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cavs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<String, Object>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cavs, values);\n\t\t}\n\t\telse {\n\t\t\t// Should not happen\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private RootBeanDefinition registerMessageBroker(Element brokerElement,\n\t\t\tRuntimeBeanReference inChannel, RuntimeBeanReference outChannel, RuntimeBeanReference brokerChannel,\n\t\t\tObject userDestHandler, RuntimeBeanReference brokerTemplate,\n\t\t\tRuntimeBeanReference userRegistry, ParserContext context, Object source) {\n\n\t\tElement simpleBrokerElem = DomUtils.getChildElementByTagName(brokerElement, \"simple-broker\");\n\t\tElement brokerRelayElem = DomUtils.getChildElementByTagName(brokerElement, \"stomp-broker-relay\");\n\n\t\tConstructorArgumentValues cavs = new ConstructorArgumentValues();\n\t\tcavs.addIndexedArgumentValue(0, inChannel);\n\t\tcavs.addIndexedArgumentValue(1, outChannel);\n\t\tcavs.addIndexedArgumentValue(2, brokerChannel);\n\n\t\tRootBeanDefinition brokerDef;\n\t\tif (simpleBrokerElem != null) {\n\t\t\tString prefix = simpleBrokerElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\t\t\tbrokerDef = new RootBeanDefinition(SimpleBrokerMessageHandler.class, cavs, null);\n\t\t\tif (brokerElement.hasAttribute(\"path-matcher\")) {\n\t\t\t\tString pathMatcherRef = brokerElement.getAttribute(\"path-matcher\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"pathMatcher\", new RuntimeBeanReference(pathMatcherRef));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"scheduler\")) {\n\t\t\t\tString scheduler = simpleBrokerElem.getAttribute(\"scheduler\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"taskScheduler\", new RuntimeBeanReference(scheduler));\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"heartbeat\")) {\n\t\t\t\tString heartbeatValue = simpleBrokerElem.getAttribute(\"heartbeat\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"heartbeatValue\", heartbeatValue);\n\t\t\t}\n\t\t\tif (simpleBrokerElem.hasAttribute(\"selector-header\")) {\n\t\t\t\tString headerName = simpleBrokerElem.getAttribute(\"selector-header\");\n\t\t\t\tbrokerDef.getPropertyValues().add(\"selectorHeaderName\", headerName);\n\t\t\t}\n\t\t}\n\t\telse if (brokerRelayElem != null) {\n\t\t\tString prefix = brokerRelayElem.getAttribute(\"prefix\");\n\t\t\tcavs.addIndexedArgumentValue(3, Arrays.asList(StringUtils.tokenizeToStringArray(prefix, \",\")));\n\n\t\t\tMutablePropertyValues values = new MutablePropertyValues();\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-host\")) {\n\t\t\t\tvalues.add(\"relayHost\", brokerRelayElem.getAttribute(\"relay-host\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"relay-port\")) {\n\t\t\t\tvalues.add(\"relayPort\", brokerRelayElem.getAttribute(\"relay-port\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-login\")) {\n\t\t\t\tvalues.add(\"clientLogin\", brokerRelayElem.getAttribute(\"client-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"client-passcode\")) {\n\t\t\t\tvalues.add(\"clientPasscode\", brokerRelayElem.getAttribute(\"client-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-login\")) {\n\t\t\t\tvalues.add(\"systemLogin\", brokerRelayElem.getAttribute(\"system-login\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"system-passcode\")) {\n\t\t\t\tvalues.add(\"systemPasscode\", brokerRelayElem.getAttribute(\"system-passcode\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-send-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatSendInterval\", brokerRelayElem.getAttribute(\"heartbeat-send-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"heartbeat-receive-interval\")) {\n\t\t\t\tvalues.add(\"systemHeartbeatReceiveInterval\", brokerRelayElem.getAttribute(\"heartbeat-receive-interval\"));\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"virtual-host\")) {\n\t\t\t\tvalues.add(\"virtualHost\", brokerRelayElem.getAttribute(\"virtual-host\"));\n\t\t\t}\n\t\t\tManagedMap<String, Object> map = new ManagedMap<String, Object>();\n\t\t\tmap.setSource(source);\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-destination-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-destination-broadcast\");\n\t\t\t\tmap.put(destination, userDestHandler);\n\t\t\t}\n\t\t\tif (brokerRelayElem.hasAttribute(\"user-registry-broadcast\")) {\n\t\t\t\tString destination = brokerRelayElem.getAttribute(\"user-registry-broadcast\");\n\t\t\t\tmap.put(destination, registerUserRegistryMessageHandler(userRegistry,\n\t\t\t\t\t\tbrokerTemplate, destination, context, source));\n\t\t\t}\n\t\t\tif (!map.isEmpty()) {\n\t\t\t\tvalues.add(\"systemSubscriptions\", map);\n\t\t\t}\n\t\t\tClass<?> handlerType = StompBrokerRelayMessageHandler.class;\n\t\t\tbrokerDef = new RootBeanDefinition(handlerType, cavs, values);\n\t\t}\n\t\telse {\n\t\t\t// Should not happen\n\t\t\tthrow new IllegalStateException(\"Neither <simple-broker> nor <stomp-broker-relay> elements found.\");\n\t\t}\n\t\tregisterBeanDef(brokerDef, context, source);\n\t\treturn brokerDef;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public Set<ControllerServiceNode> getControllerServices(final boolean recursive) {\n        readLock.lock();\n        try {\n            final Set<ControllerServiceNode> services = new HashSet<>();\n            services.addAll(controllerServices.values());\n\n            if (recursive && parent.get() != null) {\n                services.addAll(parent.get().getControllerServices(true));\n            }\n\n            return services;\n        } finally {\n            readLock.unlock();\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Set<ControllerServiceNode> getControllerServices(final boolean recursive) {\n        final Set<ControllerServiceNode> services = new HashSet<>();\n\n        readLock.lock();\n        try {\n            services.addAll(controllerServices.values());\n        } finally {\n            readLock.unlock();\n        }\n\n        if (recursive) {\n            final ProcessGroup parentGroup = parent.get();\n            if (parentGroup != null) {\n                services.addAll(parentGroup.getControllerServices(true));\n            }\n        }\n\n        return services;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public PreparedRequest prepareRequest(final String method, final Map<String, String> headers, final Object entity) {\n        final boolean gzip = isUseGzip(headers);\n        final RequestBody requestBody = createRequestBody(headers, entity, gzip);\n\n        final Map<String, String> updatedHeaders = gzip ? updateHeadersForGzip(headers) : headers;\n        return new OkHttpPreparedRequest(method, updatedHeaders, entity, requestBody);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public PreparedRequest prepareRequest(final String method, final Map<String, String> headers, final Object entity) {\n        final boolean gzip = isUseGzip(headers);\n        checkContentLengthHeader(method, headers);\n        final RequestBody requestBody = createRequestBody(headers, entity, gzip);\n\n        final Map<String, String> updatedHeaders = gzip ? updateHeadersForGzip(headers) : headers;\n        return new OkHttpPreparedRequest(method, updatedHeaders, entity, requestBody);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private HttpUrl buildUrl(final OkHttpPreparedRequest request, final String uri) {\n        HttpUrl.Builder urlBuilder = HttpUrl.parse(uri.toString()).newBuilder();\n        switch (request.getMethod().toUpperCase()) {\n            case HttpMethod.DELETE:\n            case HttpMethod.HEAD:\n            case HttpMethod.GET:\n            case HttpMethod.OPTIONS:\n                if (request.getEntity() instanceof MultivaluedMap) {\n                    final MultivaluedMap<String, String> entityMap = (MultivaluedMap<String, String>) request.getEntity();\n\n                    for (final Entry<String, List<String>> queryEntry : entityMap.entrySet()) {\n                        final String queryName = queryEntry.getKey();\n                        for (final String queryValue : queryEntry.getValue()) {\n                            urlBuilder = urlBuilder.addQueryParameter(queryName, queryValue);\n                        }\n                    }\n                }\n\n                break;\n        }\n\n        return urlBuilder.build();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private HttpUrl buildUrl(final OkHttpPreparedRequest request, final String uri) {\n        HttpUrl.Builder urlBuilder = HttpUrl.parse(uri).newBuilder();\n        switch (request.getMethod().toUpperCase()) {\n            case HttpMethod.DELETE:\n            case HttpMethod.HEAD:\n            case HttpMethod.GET:\n            case HttpMethod.OPTIONS:\n                if (request.getEntity() instanceof MultivaluedMap) {\n                    final MultivaluedMap<String, String> entityMap = (MultivaluedMap<String, String>) request.getEntity();\n\n                    for (final Entry<String, List<String>> queryEntry : entityMap.entrySet()) {\n                        final String queryName = queryEntry.getKey();\n                        for (final String queryValue : queryEntry.getValue()) {\n                            urlBuilder = urlBuilder.addQueryParameter(queryName, queryValue);\n                        }\n                    }\n                }\n\n                break;\n        }\n\n        return urlBuilder.build();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private byte[] serializeEntity(final Object entity, final String contentType, final boolean gzip) {\n        try (final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            final OutputStream out = gzip ? new GZIPOutputStream(baos, 1) : baos) {\n\n            getSerializer(contentType).serialize(entity, out);\n            out.close();\n\n            return baos.toByteArray();\n        } catch (final IOException e) {\n            // This should never happen with a ByteArrayOutputStream\n            throw new RuntimeException(\"Failed to serialize entity for cluster replication\", e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private byte[] serializeEntity(final Object entity, final String contentType, final boolean gzip) {\n        try (final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n             final OutputStream out = gzip ? new GZIPOutputStream(baos, 1) : baos) {\n\n            getSerializer(contentType).serialize(entity, out);\n            out.close();\n\n            return baos.toByteArray();\n        } catch (final IOException e) {\n            // This should never happen with a ByteArrayOutputStream\n            throw new RuntimeException(\"Failed to serialize entity for cluster replication\", e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean isUseGzip(final Map<String, String> headers) {\n        final String rawAcceptEncoding = headers.get(HttpHeaders.ACCEPT_ENCODING);\n\n        if (rawAcceptEncoding == null) {\n            return false;\n        } else {\n            final String[] acceptEncodingTokens = rawAcceptEncoding.split(\",\");\n            return Stream.of(acceptEncodingTokens)\n                .map(String::trim)\n                .filter(StringUtils::isNotEmpty)\n                .map(String::toLowerCase)\n                .anyMatch(gzipEncodings::contains);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean isUseGzip(final Map<String, String> headers) {\n        final String rawAcceptEncoding = headers.get(HttpHeaders.ACCEPT_ENCODING);\n\n        if (rawAcceptEncoding == null) {\n            return false;\n        } else {\n            final String[] acceptEncodingTokens = rawAcceptEncoding.split(\",\");\n            return Stream.of(acceptEncodingTokens)\n                    .map(String::trim)\n                    .filter(StringUtils::isNotEmpty)\n                    .map(String::toLowerCase)\n                    .anyMatch(gzipEncodings::contains);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DirectoryFileStream(SolrParams solrParams) {\n      params = solrParams;\n      delPolicy = core.getDeletionPolicy();\n\n      fileName = params.get(FILE);\n      cfileName = params.get(CONF_FILE_SHORT);\n      tlogFileName = params.get(TLOG_FILE);\n      sOffset = params.get(OFFSET);\n      sLen = params.get(LEN);\n      compress = params.get(COMPRESSION);\n      useChecksum = params.getBool(CHECKSUM, false);\n      indexGen = params.getLong(GENERATION);\n      if (useChecksum) {\n        checksum = new Adler32();\n      }\n      //No throttle if MAX_WRITE_PER_SECOND is not specified\n      double maxWriteMBPerSec = params.getDouble(MAX_WRITE_PER_SECOND, Double.MAX_VALUE);\n      rateLimiter = new RateLimiter.SimpleRateLimiter(maxWriteMBPerSec);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DirectoryFileStream(SolrParams solrParams) {\n      params = solrParams;\n      delPolicy = core.getDeletionPolicy();\n\n      fileName = validateFilenameOrError(params.get(FILE));\n      cfileName = validateFilenameOrError(params.get(CONF_FILE_SHORT));\n      tlogFileName = validateFilenameOrError(params.get(TLOG_FILE));\n      \n      sOffset = params.get(OFFSET);\n      sLen = params.get(LEN);\n      compress = params.get(COMPRESSION);\n      useChecksum = params.getBool(CHECKSUM, false);\n      indexGen = params.getLong(GENERATION);\n      if (useChecksum) {\n        checksum = new Adler32();\n      }\n      //No throttle if MAX_WRITE_PER_SECOND is not specified\n      double maxWriteMBPerSec = params.getDouble(MAX_WRITE_PER_SECOND, Double.MAX_VALUE);\n      rateLimiter = new RateLimiter.SimpleRateLimiter(maxWriteMBPerSec);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public XMLLoader init(SolrParams args) {\n    inputFactory = XMLInputFactory.newInstance();\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    }\n    catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    inputFactory.setXMLReporter(xmllog);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public XMLLoader init(SolrParams args) {\n    // Init StAX parser:\n    inputFactory = XMLInputFactory.newInstance();\n    EmptyEntityResolver.configureXMLInputFactory(inputFactory);\n    inputFactory.setXMLReporter(xmllog);\n    try {\n      // The java 1.6 bundled stax parser (sjsxp) does not currently have a thread-safe\n      // XMLInputFactory, as that implementation tries to cache and reuse the\n      // XMLStreamReader.  Setting the parser-specific \"reuse-instance\" property to false\n      // prevents this.\n      // All other known open-source stax parsers (and the bea ref impl)\n      // have thread-safe factories.\n      inputFactory.setProperty(\"reuse-instance\", Boolean.FALSE);\n    } catch (IllegalArgumentException ex) {\n      // Other implementations will likely throw this exception since \"reuse-instance\"\n      // isimplementation specific.\n      log.debug(\"Unable to set the 'reuse-instance' property for the input chain: \" + inputFactory);\n    }\n    \n    // Init SAX parser (for XSL):\n    saxFactory = SAXParserFactory.newInstance();\n    saxFactory.setNamespaceAware(true); // XSL needs this!\n    EmptyEntityResolver.configureSAXParserFactory(saxFactory);\n    \n    xsltCacheLifetimeSeconds = XSLT_CACHE_DEFAULT;\n    if(args != null) {\n      xsltCacheLifetimeSeconds = args.getInt(XSLT_CACHE_PARAM,XSLT_CACHE_DEFAULT);\n      log.info(\"xsltCacheLifetimeSeconds=\" + xsltCacheLifetimeSeconds);\n    }\n    return this;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void init(Map<String,Object> pluginConfig) {\n    try {\n      String delegationTokenEnabled = (String)pluginConfig.getOrDefault(DELEGATION_TOKEN_ENABLED_PROPERTY, \"false\");\n      authFilter = (Boolean.parseBoolean(delegationTokenEnabled)) ? new HadoopAuthFilter() : new AuthenticationFilter();\n\n      // Initialize kerberos before initializing curator instance.\n      boolean initKerberosZk = Boolean.parseBoolean((String)pluginConfig.getOrDefault(INIT_KERBEROS_ZK, \"false\"));\n      if (initKerberosZk) {\n        (new Krb5HttpClientBuilder()).getBuilder();\n      }\n\n      FilterConfig conf = getInitFilterConfig(pluginConfig);\n      authFilter.init(conf);\n\n    } catch (ServletException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error initializing \" + getClass().getName() + \": \"+e);\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void init(Map<String,Object> pluginConfig) {\n    try {\n      String delegationTokenEnabled = (String)pluginConfig.getOrDefault(DELEGATION_TOKEN_ENABLED_PROPERTY, \"false\");\n      authFilter = (Boolean.parseBoolean(delegationTokenEnabled)) ? new HadoopAuthFilter() : new AuthenticationFilter();\n\n      // Initialize kerberos before initializing curator instance.\n      boolean initKerberosZk = Boolean.parseBoolean((String)pluginConfig.getOrDefault(INIT_KERBEROS_ZK, \"false\"));\n      if (initKerberosZk) {\n        (new Krb5HttpClientBuilder()).getBuilder();\n      }\n\n      FilterConfig conf = getInitFilterConfig(pluginConfig);\n      authFilter.init(conf);\n\n    } catch (ServletException e) {\n      log.error(\"Error initializing \" + getClass().getSimpleName(), e);\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error initializing \" + getClass().getName() + \": \"+e);\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public SolrZkToCuratorCredentialsACLs(SolrZkClient zkClient) {\n      this.aclProvider = createACLProvider(zkClient);\n      this.authInfos = createAuthInfo(zkClient);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public SolrZkToCuratorCredentialsACLs(SolrZkClient zkClient) {\n      this.aclProvider = createACLProvider(zkClient);\n      this.authInfos = createAuthInfo(zkClient);\n      String zkHost = zkClient.getZkServerAddress();\n      this.zkChroot = zkHost.contains(\"/\")? zkHost.substring(zkHost.indexOf(\"/\")): null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private ACLProvider createACLProvider(SolrZkClient zkClient) {\n      final ZkACLProvider zkACLProvider = zkClient.getZkACLProvider();\n      return new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n           List<ACL> acls = zkACLProvider.getACLsToAdd(path);\n           return acls;\n        }\n      };\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private ACLProvider createACLProvider(SolrZkClient zkClient) {\n      final ZkACLProvider zkACLProvider = zkClient.getZkACLProvider();\n      return new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n          List<ACL> acls = null;\n\n          // The logic in SecurityAwareZkACLProvider does not work when\n          // the Solr zkPath is chrooted (e.g. /solr instead of /). This\n          // due to the fact that the getACLsToAdd(..) callback provides\n          // an absolute path (instead of relative path to the chroot) and\n          // the string comparison in SecurityAwareZkACLProvider fails.\n          if (zkACLProvider instanceof SecurityAwareZkACLProvider && zkChroot != null) {\n            acls = zkACLProvider.getACLsToAdd(path.replace(zkChroot, \"\"));\n          } else {\n            acls = zkACLProvider.getACLsToAdd(path);\n          }\n\n          return acls;\n        }\n      };\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n           List<ACL> acls = zkACLProvider.getACLsToAdd(path);\n           return acls;\n        }\n      }",
    "is_vulnerable": true
  },
  {
    "function_code": "new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n          List<ACL> acls = null;\n\n          // The logic in SecurityAwareZkACLProvider does not work when\n          // the Solr zkPath is chrooted (e.g. /solr instead of /). This\n          // due to the fact that the getACLsToAdd(..) callback provides\n          // an absolute path (instead of relative path to the chroot) and\n          // the string comparison in SecurityAwareZkACLProvider fails.\n          if (zkACLProvider instanceof SecurityAwareZkACLProvider && zkChroot != null) {\n            acls = zkACLProvider.getACLsToAdd(path.replace(zkChroot, \"\"));\n          } else {\n            acls = zkACLProvider.getACLsToAdd(path);\n          }\n\n          return acls;\n        }\n      }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<ACL> getAclForPath(String path) {\n           List<ACL> acls = zkACLProvider.getACLsToAdd(path);\n           return acls;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<ACL> getAclForPath(String path) {\n          List<ACL> acls = null;\n\n          // The logic in SecurityAwareZkACLProvider does not work when\n          // the Solr zkPath is chrooted (e.g. /solr instead of /). This\n          // due to the fact that the getACLsToAdd(..) callback provides\n          // an absolute path (instead of relative path to the chroot) and\n          // the string comparison in SecurityAwareZkACLProvider fails.\n          if (zkACLProvider instanceof SecurityAwareZkACLProvider && zkChroot != null) {\n            acls = zkACLProvider.getACLsToAdd(path.replace(zkChroot, \"\"));\n          } else {\n            acls = zkACLProvider.getACLsToAdd(path);\n          }\n\n          return acls;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public SolrZkToCuratorCredentialsACLs(SolrZkClient zkClient) {\n      this.aclProvider = createACLProvider(zkClient);\n      this.authInfos = createAuthInfo(zkClient);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public SolrZkToCuratorCredentialsACLs(SolrZkClient zkClient) {\n      this.aclProvider = createACLProvider(zkClient);\n      this.authInfos = createAuthInfo(zkClient);\n      String zkHost = zkClient.getZkServerAddress();\n      this.zkChroot = zkHost.contains(\"/\")? zkHost.substring(zkHost.indexOf(\"/\")): null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private ACLProvider createACLProvider(SolrZkClient zkClient) {\n      final ZkACLProvider zkACLProvider = zkClient.getZkACLProvider();\n      return new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n           List<ACL> acls = zkACLProvider.getACLsToAdd(path);\n           return acls;\n        }\n      };\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private ACLProvider createACLProvider(SolrZkClient zkClient) {\n      final ZkACLProvider zkACLProvider = zkClient.getZkACLProvider();\n      return new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n          List<ACL> acls = null;\n\n          // The logic in SecurityAwareZkACLProvider does not work when\n          // the Solr zkPath is chrooted (e.g. /solr instead of /). This\n          // due to the fact that the getACLsToAdd(..) callback provides\n          // an absolute path (instead of relative path to the chroot) and\n          // the string comparison in SecurityAwareZkACLProvider fails.\n          if (zkACLProvider instanceof SecurityAwareZkACLProvider && zkChroot != null) {\n            acls = zkACLProvider.getACLsToAdd(path.replace(zkChroot, \"\"));\n          } else {\n            acls = zkACLProvider.getACLsToAdd(path);\n          }\n\n          return acls;\n        }\n      };\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n           List<ACL> acls = zkACLProvider.getACLsToAdd(path);\n           return acls;\n        }\n      }",
    "is_vulnerable": true
  },
  {
    "function_code": "new ACLProvider() {\n        @Override\n        public List<ACL> getDefaultAcl() {\n          return zkACLProvider.getACLsToAdd(null);\n        }\n\n        @Override\n        public List<ACL> getAclForPath(String path) {\n          List<ACL> acls = null;\n\n          // The logic in SecurityAwareZkACLProvider does not work when\n          // the Solr zkPath is chrooted (e.g. /solr instead of /). This\n          // due to the fact that the getACLsToAdd(..) callback provides\n          // an absolute path (instead of relative path to the chroot) and\n          // the string comparison in SecurityAwareZkACLProvider fails.\n          if (zkACLProvider instanceof SecurityAwareZkACLProvider && zkChroot != null) {\n            acls = zkACLProvider.getACLsToAdd(path.replace(zkChroot, \"\"));\n          } else {\n            acls = zkACLProvider.getACLsToAdd(path);\n          }\n\n          return acls;\n        }\n      }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<ACL> getAclForPath(String path) {\n           List<ACL> acls = zkACLProvider.getACLsToAdd(path);\n           return acls;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<ACL> getAclForPath(String path) {\n          List<ACL> acls = null;\n\n          // The logic in SecurityAwareZkACLProvider does not work when\n          // the Solr zkPath is chrooted (e.g. /solr instead of /). This\n          // due to the fact that the getACLsToAdd(..) callback provides\n          // an absolute path (instead of relative path to the chroot) and\n          // the string comparison in SecurityAwareZkACLProvider fails.\n          if (zkACLProvider instanceof SecurityAwareZkACLProvider && zkChroot != null) {\n            acls = zkACLProvider.getACLsToAdd(path.replace(zkChroot, \"\"));\n          } else {\n            acls = zkACLProvider.getACLsToAdd(path);\n          }\n\n          return acls;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void loadAndInit(InputSource configFile) {\n    config = loadDataConfig(configFile);\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "void loadAndInit(InputSource configFile) {\n    config = loadDataConfig(configFile);\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DIHConfiguration loadDataConfig(InputSource configFile) {\n\n    DIHConfiguration dihcfg = null;\n    try {\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      \n      // only enable xinclude, if a a SolrCore and SystemId is present (makes no sense otherwise)\n      if (core != null && configFile.getSystemId() != null) {\n        try {\n          dbf.setXIncludeAware(true);\n          dbf.setNamespaceAware(true);\n        } catch( UnsupportedOperationException e ) {\n          LOG.warn( \"XML parser doesn't support XInclude option\" );\n        }\n      }\n      \n      DocumentBuilder builder = dbf.newDocumentBuilder();\n      if (core != null)\n        builder.setEntityResolver(new SystemIdResolver(core.getResourceLoader()));\n      builder.setErrorHandler(XMLLOG);\n      Document document;\n      try {\n        document = builder.parse(configFile);\n      } finally {\n        // some XML parsers are broken and don't close the byte stream (but they should according to spec)\n        IOUtils.closeQuietly(configFile.getByteStream());\n      }\n\n      dihcfg = readFromXml(document);\n      LOG.info(\"Data Configuration loaded successfully\");\n    } catch (Exception e) {\n      throw new DataImportHandlerException(SEVERE,\n              \"Data Config problem: \" + e.getMessage(), e);\n    }\n    for (Entity e : dihcfg.getEntities()) {\n      if (e.getAllAttributes().containsKey(SqlEntityProcessor.DELTA_QUERY)) {\n        isDeltaImportSupported = true;\n        break;\n      }\n    }\n    return dihcfg;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DIHConfiguration loadDataConfig(InputSource configFile) {\n\n    DIHConfiguration dihcfg = null;\n    try {\n      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n      dbf.setValidating(false);\n      \n      // only enable xinclude, if XML is coming from safe source (local file)\n      // and a a SolrCore and SystemId is present (makes no sense otherwise):\n      if (core != null && configFile.getSystemId() != null) {\n        try {\n          dbf.setXIncludeAware(true);\n          dbf.setNamespaceAware(true);\n        } catch( UnsupportedOperationException e ) {\n          LOG.warn( \"XML parser doesn't support XInclude option\" );\n        }\n      }\n      \n      DocumentBuilder builder = dbf.newDocumentBuilder();\n      // only enable xinclude / external entities, if XML is coming from\n      // safe source (local file) and a a SolrCore and SystemId is present:\n      if (core != null && configFile.getSystemId() != null) {\n        builder.setEntityResolver(new SystemIdResolver(core.getResourceLoader()));\n      } else {\n        // Don't allow external entities without having a system ID:\n        builder.setEntityResolver(EmptyEntityResolver.SAX_INSTANCE);\n      }\n      builder.setErrorHandler(XMLLOG);\n      Document document;\n      try {\n        document = builder.parse(configFile);\n      } finally {\n        // some XML parsers are broken and don't close the byte stream (but they should according to spec)\n        IOUtils.closeQuietly(configFile.getByteStream());\n      }\n\n      dihcfg = readFromXml(document);\n      LOG.info(\"Data Configuration loaded successfully\");\n    } catch (Exception e) {\n      throw new DataImportHandlerException(SEVERE,\n              \"Data Config problem: \" + e.getMessage(), e);\n    }\n    for (Entity e : dihcfg.getEntities()) {\n      if (e.getAllAttributes().containsKey(SqlEntityProcessor.DELTA_QUERY)) {\n        isDeltaImportSupported = true;\n        break;\n      }\n    }\n    return dihcfg;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<VariantInfo> getVariants(Class<?> source) {\n        List<VariantInfo> result = null;\n\n        if (source != null) {\n\n            if (String.class.isAssignableFrom(source)\n                    || StringRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (File.class.isAssignableFrom(source)\n                    || FileRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (InputStream.class.isAssignableFrom(source)\n                    || InputRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (Reader.class.isAssignableFrom(source)\n                    || ReaderRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (Representation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (Form.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_FORM);\n            } else if (Serializable.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_OBJECT);\n                result = addVariant(result, VARIANT_OBJECT_XML);\n            }\n        }\n\n        return result;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<VariantInfo> getVariants(Class<?> source) {\n        List<VariantInfo> result = null;\n\n        if (source != null) {\n\n            if (String.class.isAssignableFrom(source)\n                    || StringRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (File.class.isAssignableFrom(source)\n                    || FileRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (InputStream.class.isAssignableFrom(source)\n                    || InputRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (Reader.class.isAssignableFrom(source)\n                    || ReaderRepresentation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (Representation.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_ALL);\n            } else if (Form.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_FORM);\n            } else if (Serializable.class.isAssignableFrom(source)) {\n                result = addVariant(result, VARIANT_OBJECT);\n                if (VARIANT_OBJECT_XML_SUPPORTED) {\n                    result = addVariant(result, VARIANT_OBJECT_XML);\n                }\n            }\n        }\n\n        return result;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "float score(Representation source, Class<T> target,\n            UniformResource resource) {\n        float result = -1.0F;\n\n        if (target != null) {\n            if (target.isAssignableFrom(source.getClass())) {\n                result = 1.0F;\n            } else if (String.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (StringRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (EmptyRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (File.class.isAssignableFrom(target)) {\n                if (source instanceof FileRepresentation) {\n                    result = 1.0F;\n                }\n            } else if (Form.class.isAssignableFrom(target)) {\n                if (MediaType.APPLICATION_WWW_FORM.isCompatible(source\n                        .getMediaType())) {\n                    result = 1.0F;\n                } else {\n                    result = 0.5F;\n                }\n            } else if (InputStream.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (InputRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (Reader.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (ReaderRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (Serializable.class.isAssignableFrom(target)\n                    || target.isPrimitive()) {\n                if (MediaType.APPLICATION_JAVA_OBJECT.equals(source\n                        .getMediaType())) {\n                    result = 1.0F;\n                } else if (MediaType.APPLICATION_JAVA_OBJECT\n                        .isCompatible(source.getMediaType())) {\n                    result = 0.6F;\n                } else if (MediaType.APPLICATION_JAVA_OBJECT_XML.equals(source\n                        .getMediaType())) {\n                    result = 1.0F;\n                } else if (MediaType.APPLICATION_JAVA_OBJECT_XML\n                        .isCompatible(source.getMediaType())) {\n                    result = 0.6F;\n                } else {\n                    result = 0.5F;\n                }\n            }\n        } else if (source instanceof ObjectRepresentation<?>) {\n            result = 1.0F;\n        }\n\n        return result;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "float score(Representation source, Class<T> target,\n            UniformResource resource) {\n        float result = -1.0F;\n\n        if (target != null) {\n            if (target.isAssignableFrom(source.getClass())) {\n                result = 1.0F;\n            } else if (String.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (StringRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (EmptyRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (File.class.isAssignableFrom(target)) {\n                if (source instanceof FileRepresentation) {\n                    result = 1.0F;\n                }\n            } else if (Form.class.isAssignableFrom(target)) {\n                if (MediaType.APPLICATION_WWW_FORM.isCompatible(source\n                        .getMediaType())) {\n                    result = 1.0F;\n                } else {\n                    result = 0.5F;\n                }\n            } else if (InputStream.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (InputRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (Reader.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (ReaderRepresentation.class.isAssignableFrom(target)) {\n                result = 1.0F;\n            } else if (Serializable.class.isAssignableFrom(target)\n                    || target.isPrimitive()) {\n                if (MediaType.APPLICATION_JAVA_OBJECT.equals(source\n                        .getMediaType())) {\n                    result = 1.0F;\n                } else if (MediaType.APPLICATION_JAVA_OBJECT\n                        .isCompatible(source.getMediaType())) {\n                    result = 0.6F;\n                } else if (VARIANT_OBJECT_XML_SUPPORTED\n                        && MediaType.APPLICATION_JAVA_OBJECT_XML.equals(source\n                                .getMediaType())) {\n                    result = 1.0F;\n                } else if (VARIANT_OBJECT_XML_SUPPORTED\n                        && MediaType.APPLICATION_JAVA_OBJECT_XML\n                                .isCompatible(source.getMediaType())) {\n                    result = 0.6F;\n                } else {\n                    result = 0.5F;\n                }\n            }\n        } else if (source instanceof ObjectRepresentation<?>) {\n            result = 1.0F;\n        }\n\n        return result;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "void updatePreferences(List<Preference<MediaType>> preferences,\n            Class<T> entity) {\n        if (Form.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.APPLICATION_WWW_FORM, 1.0F);\n        } else if (Serializable.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.APPLICATION_JAVA_OBJECT,\n                    1.0F);\n            updatePreferences(preferences,\n                    MediaType.APPLICATION_JAVA_OBJECT_XML, 1.0F);\n        } else if (String.class.isAssignableFrom(entity)\n                || Reader.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.TEXT_PLAIN, 1.0F);\n            updatePreferences(preferences, MediaType.TEXT_ALL, 0.5F);\n        } else if (InputStream.class.isAssignableFrom(entity)\n                || ReadableByteChannel.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.APPLICATION_OCTET_STREAM,\n                    1.0F);\n            updatePreferences(preferences, MediaType.APPLICATION_ALL, 0.5F);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "void updatePreferences(List<Preference<MediaType>> preferences,\n            Class<T> entity) {\n        if (Form.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.APPLICATION_WWW_FORM, 1.0F);\n        } else if (Serializable.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.APPLICATION_JAVA_OBJECT,\n                    1.0F);\n            if (VARIANT_OBJECT_XML_SUPPORTED) {\n                updatePreferences(preferences,\n                        MediaType.APPLICATION_JAVA_OBJECT_XML, 1.0F);\n            }\n        } else if (String.class.isAssignableFrom(entity)\n                || Reader.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.TEXT_PLAIN, 1.0F);\n            updatePreferences(preferences, MediaType.TEXT_ALL, 0.5F);\n        } else if (InputStream.class.isAssignableFrom(entity)\n                || ReadableByteChannel.class.isAssignableFrom(entity)) {\n            updatePreferences(preferences, MediaType.APPLICATION_OCTET_STREAM,\n                    1.0F);\n            updatePreferences(preferences, MediaType.APPLICATION_ALL, 0.5F);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private static void addHeadersToRequest(URLConnection connection, JSONObject headers) {\n        try {\n            for (Iterator<?> iter = headers.keys(); iter.hasNext(); ) {\n                /* RFC 2616 says that non-ASCII characters and control\n                 * characters are not allowed in header names or values.\n                 * Additionally, spaces are not allowed in header names.\n                 * RFC 2046 Quoted-printable encoding may be used to encode\n                 * arbitrary characters, but we donon- not do that encoding here.\n                 */\n                String headerKey = iter.next().toString();\n                headerKey = headerKey.replaceAll(\"\\\\n\",\"\")\n                        .replaceAll(\"\\\\s+\",\"\")\n                        .replaceAll(\"[^\\\\x20-\\\\x7E]+\", \"\");\n\n                JSONArray headerValues = headers.optJSONArray(headerKey);\n                if (headerValues == null) {\n                    headerValues = new JSONArray();\n\n                     /* RFC 2616 also says that any amount of consecutive linear\n                      * whitespace within a header value can be replaced with a\n                      * single space character, without affecting the meaning of\n                      * that value.\n                      */\n\n                    String headerValue = headers.getString(headerKey);\n                    String finalValue = headerValue.replaceAll(\"\\\\s+\", \" \").replaceAll(\"\\\\n\",\" \").replaceAll(\"[^\\\\x20-\\\\x7E]+\", \" \");\n                    headerValues.put(finalValue);\n                }\n\n                connection.setRequestProperty(headerKey, headerValues.getString(0));\n                for (int i = 1; i < headerValues.length(); ++i) {\n                    connection.addRequestProperty(headerKey, headerValues.getString(i));\n                }\n            }\n        } catch (JSONException e1) {\n          // No headers to be manipulated!\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private static void addHeadersToRequest(URLConnection connection, JSONObject headers) {\n        try {\n            for (Iterator<?> iter = headers.keys(); iter.hasNext(); ) {\n                /* RFC 2616 says that non-ASCII characters and control\n                 * characters are not allowed in header names or values.\n                 * Additionally, spaces are not allowed in header names.\n                 * RFC 2046 Quoted-printable encoding may be used to encode\n                 * arbitrary characters, but we donon- not do that encoding here.\n                 */\n                String headerKey = iter.next().toString();\n                headerKey = headerKey.replaceAll(\"\\\\n\",\"\")\n                        .replaceAll(\"\\\\s+\",\"\")\n                        .replaceAll(\":\", \"\")\n                        .replaceAll(\"[^\\\\x20-\\\\x7E]+\", \"\");\n\n                JSONArray headerValues = headers.optJSONArray(headerKey);\n                if (headerValues == null) {\n                    headerValues = new JSONArray();\n\n                     /* RFC 2616 also says that any amount of consecutive linear\n                      * whitespace within a header value can be replaced with a\n                      * single space character, without affecting the meaning of\n                      * that value.\n                      */\n\n                    String headerValue = headers.getString(headerKey);\n                    String finalValue = headerValue.replaceAll(\"\\\\s+\", \" \").replaceAll(\"\\\\n\",\" \").replaceAll(\"[^\\\\x20-\\\\x7E]+\", \" \");\n                    headerValues.put(finalValue);\n                }\n\n                connection.setRequestProperty(headerKey, headerValues.getString(0));\n                for (int i = 1; i < headerValues.length(); ++i) {\n                    connection.addRequestProperty(headerKey, headerValues.getString(i));\n                }\n            }\n        } catch (JSONException e1) {\n          // No headers to be manipulated!\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setWorkDir(File workDir) {\n        this.loaderDir = new File(workDir, \"loader\");\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setWorkDir(File workDir) {\n        this.loaderDir = new File(workDir, \"loader\");\n        if (loaderDir == null) {\n            canonicalLoaderDir = null;\n        } else { \n            try {\n                canonicalLoaderDir = loaderDir.getCanonicalPath();\n                if (!canonicalLoaderDir.endsWith(File.separator)) {\n                    canonicalLoaderDir += File.separator;\n                }\n            } catch (IOException ioe) {\n                canonicalLoaderDir = null;\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected ResourceEntry findResourceInternal(String name, String path) {\n\n        if (!started) {\n            log.info(sm.getString(\"webappClassLoader.stopped\", name));\n            return null;\n        }\n\n        if ((name == null) || (path == null))\n            return null;\n\n        ResourceEntry entry = resourceEntries.get(name);\n        if (entry != null)\n            return entry;\n\n        int contentLength = -1;\n        InputStream binaryStream = null;\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        Resource resource = null;\n\n        boolean fileNeedConvert = false;\n\n        for (i = 0; (entry == null) && (i < repositoriesLength); i++) {\n            try {\n\n                String fullPath = repositories[i] + path;\n\n                Object lookupResult = resources.lookup(fullPath);\n                if (lookupResult instanceof Resource) {\n                    resource = (Resource) lookupResult;\n                }\n\n                // Note : Not getting an exception here means the resource was\n                // found\n                entry = findResourceInternal(files[i], path);\n\n                ResourceAttributes attributes =\n                    (ResourceAttributes) resources.getAttributes(fullPath);\n                contentLength = (int) attributes.getContentLength();\n                entry.lastModified = attributes.getLastModified();\n\n                if (resource != null) {\n\n\n                    try {\n                        binaryStream = resource.streamContent();\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    if (needConvert) {\n                        if (path.endsWith(\".properties\")) {\n                            fileNeedConvert = true;\n                        }\n                    }\n\n                    // Register the full path for modification checking\n                    // Note: Only syncing on a 'constant' object is needed\n                    synchronized (allPermission) {\n\n                        int j;\n\n                        long[] result2 = \n                            new long[lastModifiedDates.length + 1];\n                        for (j = 0; j < lastModifiedDates.length; j++) {\n                            result2[j] = lastModifiedDates[j];\n                        }\n                        result2[lastModifiedDates.length] = entry.lastModified;\n                        lastModifiedDates = result2;\n\n                        String[] result = new String[paths.length + 1];\n                        for (j = 0; j < paths.length; j++) {\n                            result[j] = paths[j];\n                        }\n                        result[paths.length] = fullPath;\n                        paths = result;\n\n                    }\n\n                }\n\n            } catch (NamingException e) {\n            }\n        }\n\n        if ((entry == null) && (notFoundResources.containsKey(name)))\n            return null;\n\n        JarEntry jarEntry = null;\n\n        synchronized (jarFiles) {\n\n            if (!openJARs()) {\n                return null;\n            }\n            for (i = 0; (entry == null) && (i < jarFilesLength); i++) {\n\n                jarEntry = jarFiles[i].getJarEntry(path);\n\n                if (jarEntry != null) {\n\n                    entry = new ResourceEntry();\n                    try {\n                        entry.codeBase = getURL(jarRealFiles[i], false);\n                        String jarFakeUrl = getURI(jarRealFiles[i]).toString();\n                        jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + path;\n                        entry.source = new URL(jarFakeUrl);\n                        entry.lastModified = jarRealFiles[i].lastModified();\n                    } catch (MalformedURLException e) {\n                        return null;\n                    }\n                    contentLength = (int) jarEntry.getSize();\n                    try {\n                        entry.manifest = jarFiles[i].getManifest();\n                        binaryStream = jarFiles[i].getInputStream(jarEntry);\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    // Extract resources contained in JAR to the workdir\n                    if (antiJARLocking && !(path.endsWith(\".class\"))) {\n                        byte[] buf = new byte[1024];\n                        File resourceFile = new File\n                            (loaderDir, jarEntry.getName());\n                        if (!resourceFile.exists()) {\n                            Enumeration<JarEntry> entries =\n                                jarFiles[i].entries();\n                            while (entries.hasMoreElements()) {\n                                JarEntry jarEntry2 =  entries.nextElement();\n                                if (!(jarEntry2.isDirectory()) \n                                    && (!jarEntry2.getName().endsWith\n                                        (\".class\"))) {\n                                    resourceFile = new File\n                                        (loaderDir, jarEntry2.getName());\n                                    resourceFile.getParentFile().mkdirs();\n                                    FileOutputStream os = null;\n                                    InputStream is = null;\n                                    try {\n                                        is = jarFiles[i].getInputStream\n                                            (jarEntry2);\n                                        os = new FileOutputStream\n                                            (resourceFile);\n                                        while (true) {\n                                            int n = is.read(buf);\n                                            if (n <= 0) {\n                                                break;\n                                            }\n                                            os.write(buf, 0, n);\n                                        }\n                                    } catch (IOException e) {\n                                        // Ignore\n                                    } finally {\n                                        try {\n                                            if (is != null) {\n                                                is.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                        try {\n                                            if (os != null) {\n                                                os.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n            }\n\n            if (entry == null) {\n                synchronized (notFoundResources) {\n                    notFoundResources.put(name, name);\n                }\n                return null;\n            }\n\n            if (binaryStream != null) {\n\n                byte[] binaryContent = new byte[contentLength];\n\n                int pos = 0;\n                try {\n\n                    while (true) {\n                        int n = binaryStream.read(binaryContent, pos,\n                                                  binaryContent.length - pos);\n                        if (n <= 0)\n                            break;\n                        pos += n;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\"webappClassLoader.readError\", name), e);\n                    return null;\n                } finally {\n                    try {\n                        binaryStream.close();\n                    } catch (IOException e) {}\n                }\n                if (fileNeedConvert) {\n                    // Workaround for certain files on platforms that use\n                    // EBCDIC encoding, when they are read through FileInputStream.\n                    // See commit message of rev.303915 for details\n                    // http://svn.apache.org/viewvc?view=revision&revision=303915\n                    String str = new String(binaryContent,0,pos);\n                    try {\n                        binaryContent = str.getBytes(\"UTF-8\");\n                    } catch (Exception e) {\n                        return null;\n                    }\n                }\n                entry.binaryContent = binaryContent;\n\n                // The certificates are only available after the JarEntry \n                // associated input stream has been fully read\n                if (jarEntry != null) {\n                    entry.certificates = jarEntry.getCertificates();\n                }\n\n            }\n\n        }\n\n        // Add the entry in the local resource repository\n        synchronized (resourceEntries) {\n            // Ensures that all the threads which may be in a race to load\n            // a particular class all end up with the same ResourceEntry\n            // instance\n            ResourceEntry entry2 = resourceEntries.get(name);\n            if (entry2 == null) {\n                resourceEntries.put(name, entry);\n            } else {\n                entry = entry2;\n            }\n        }\n\n        return entry;\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected ResourceEntry findResourceInternal(String name, String path) {\n\n        if (!started) {\n            log.info(sm.getString(\"webappClassLoader.stopped\", name));\n            return null;\n        }\n\n        if ((name == null) || (path == null))\n            return null;\n\n        ResourceEntry entry = resourceEntries.get(name);\n        if (entry != null)\n            return entry;\n\n        int contentLength = -1;\n        InputStream binaryStream = null;\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        Resource resource = null;\n\n        boolean fileNeedConvert = false;\n\n        for (i = 0; (entry == null) && (i < repositoriesLength); i++) {\n            try {\n\n                String fullPath = repositories[i] + path;\n\n                Object lookupResult = resources.lookup(fullPath);\n                if (lookupResult instanceof Resource) {\n                    resource = (Resource) lookupResult;\n                }\n\n                // Note : Not getting an exception here means the resource was\n                // found\n                entry = findResourceInternal(files[i], path);\n\n                ResourceAttributes attributes =\n                    (ResourceAttributes) resources.getAttributes(fullPath);\n                contentLength = (int) attributes.getContentLength();\n                entry.lastModified = attributes.getLastModified();\n\n                if (resource != null) {\n\n\n                    try {\n                        binaryStream = resource.streamContent();\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    if (needConvert) {\n                        if (path.endsWith(\".properties\")) {\n                            fileNeedConvert = true;\n                        }\n                    }\n\n                    // Register the full path for modification checking\n                    // Note: Only syncing on a 'constant' object is needed\n                    synchronized (allPermission) {\n\n                        int j;\n\n                        long[] result2 = \n                            new long[lastModifiedDates.length + 1];\n                        for (j = 0; j < lastModifiedDates.length; j++) {\n                            result2[j] = lastModifiedDates[j];\n                        }\n                        result2[lastModifiedDates.length] = entry.lastModified;\n                        lastModifiedDates = result2;\n\n                        String[] result = new String[paths.length + 1];\n                        for (j = 0; j < paths.length; j++) {\n                            result[j] = paths[j];\n                        }\n                        result[paths.length] = fullPath;\n                        paths = result;\n\n                    }\n\n                }\n\n            } catch (NamingException e) {\n            }\n        }\n\n        if ((entry == null) && (notFoundResources.containsKey(name)))\n            return null;\n\n        JarEntry jarEntry = null;\n\n        synchronized (jarFiles) {\n\n            if (!openJARs()) {\n                return null;\n            }\n            for (i = 0; (entry == null) && (i < jarFilesLength); i++) {\n\n                jarEntry = jarFiles[i].getJarEntry(path);\n\n                if (jarEntry != null) {\n\n                    entry = new ResourceEntry();\n                    try {\n                        entry.codeBase = getURL(jarRealFiles[i], false);\n                        String jarFakeUrl = getURI(jarRealFiles[i]).toString();\n                        jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + path;\n                        entry.source = new URL(jarFakeUrl);\n                        entry.lastModified = jarRealFiles[i].lastModified();\n                    } catch (MalformedURLException e) {\n                        return null;\n                    }\n                    contentLength = (int) jarEntry.getSize();\n                    try {\n                        entry.manifest = jarFiles[i].getManifest();\n                        binaryStream = jarFiles[i].getInputStream(jarEntry);\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    // Extract resources contained in JAR to the workdir\n                    if (antiJARLocking && !(path.endsWith(\".class\"))) {\n                        byte[] buf = new byte[1024];\n                        File resourceFile = new File\n                            (loaderDir, jarEntry.getName());\n                        if (!resourceFile.exists()) {\n                            Enumeration<JarEntry> entries =\n                                jarFiles[i].entries();\n                            while (entries.hasMoreElements()) {\n                                JarEntry jarEntry2 =  entries.nextElement();\n                                if (!(jarEntry2.isDirectory()) \n                                    && (!jarEntry2.getName().endsWith\n                                        (\".class\"))) {\n                                    resourceFile = new File\n                                        (loaderDir, jarEntry2.getName());\n                                    try {\n                                        if (!resourceFile.getCanonicalPath().startsWith(\n                                                canonicalLoaderDir)) {\n                                            throw new IllegalArgumentException(\n                                                    sm.getString(\"webappClassLoader.illegalJarPath\",\n                                                jarEntry2.getName()));\n                                        }\n                                    } catch (IOException ioe) {\n                                        throw new IllegalArgumentException(\n                                                sm.getString(\"webappClassLoader.validationErrorJarPath\",\n                                                        jarEntry2.getName()), ioe);\n                                    }                                 \n                                    resourceFile.getParentFile().mkdirs();\n                                    FileOutputStream os = null;\n                                    InputStream is = null;\n                                    try {\n                                        is = jarFiles[i].getInputStream\n                                            (jarEntry2);\n                                        os = new FileOutputStream\n                                            (resourceFile);\n                                        while (true) {\n                                            int n = is.read(buf);\n                                            if (n <= 0) {\n                                                break;\n                                            }\n                                            os.write(buf, 0, n);\n                                        }\n                                    } catch (IOException e) {\n                                        // Ignore\n                                    } finally {\n                                        try {\n                                            if (is != null) {\n                                                is.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                        try {\n                                            if (os != null) {\n                                                os.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n            }\n\n            if (entry == null) {\n                synchronized (notFoundResources) {\n                    notFoundResources.put(name, name);\n                }\n                return null;\n            }\n\n            if (binaryStream != null) {\n\n                byte[] binaryContent = new byte[contentLength];\n\n                int pos = 0;\n                try {\n\n                    while (true) {\n                        int n = binaryStream.read(binaryContent, pos,\n                                                  binaryContent.length - pos);\n                        if (n <= 0)\n                            break;\n                        pos += n;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\"webappClassLoader.readError\", name), e);\n                    return null;\n                } finally {\n                    try {\n                        binaryStream.close();\n                    } catch (IOException e) {}\n                }\n                if (fileNeedConvert) {\n                    // Workaround for certain files on platforms that use\n                    // EBCDIC encoding, when they are read through FileInputStream.\n                    // See commit message of rev.303915 for details\n                    // http://svn.apache.org/viewvc?view=revision&revision=303915\n                    String str = new String(binaryContent,0,pos);\n                    try {\n                        binaryContent = str.getBytes(\"UTF-8\");\n                    } catch (Exception e) {\n                        return null;\n                    }\n                }\n                entry.binaryContent = binaryContent;\n\n                // The certificates are only available after the JarEntry \n                // associated input stream has been fully read\n                if (jarEntry != null) {\n                    entry.certificates = jarEntry.getCertificates();\n                }\n\n            }\n\n        }\n\n        // Add the entry in the local resource repository\n        synchronized (resourceEntries) {\n            // Ensures that all the threads which may be in a race to load\n            // a particular class all end up with the same ResourceEntry\n            // instance\n            ResourceEntry entry2 = resourceEntries.get(name);\n            if (entry2 == null) {\n                resourceEntries.put(name, entry);\n            } else {\n                entry = entry2;\n            }\n        }\n\n        return entry;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected String parseUsername(String authorization) {\n\n        //System.out.println(\"Authorization token : \" + authorization);\n        // Validate the authorization credentials format\n        if (authorization == null)\n            return (null);\n        if (!authorization.startsWith(\"Digest \"))\n            return (null);\n        authorization = authorization.substring(7).trim();\n\n        StringTokenizer commaTokenizer =\n            new StringTokenizer(authorization, \",\");\n\n        while (commaTokenizer.hasMoreTokens()) {\n            String currentToken = commaTokenizer.nextToken();\n            int equalSign = currentToken.indexOf('=');\n            if (equalSign < 0)\n                return null;\n            String currentTokenName =\n                currentToken.substring(0, equalSign).trim();\n            String currentTokenValue =\n                currentToken.substring(equalSign + 1).trim();\n            if (\"username\".equals(currentTokenName))\n                return (removeQuotes(currentTokenValue));\n        }\n\n        return (null);\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected String parseUsername(String authorization) {\n\n        // Validate the authorization credentials format\n        if (authorization == null)\n            return (null);\n        if (!authorization.startsWith(\"Digest \"))\n            return (null);\n        authorization = authorization.substring(7).trim();\n\n        StringTokenizer commaTokenizer =\n            new StringTokenizer(authorization, \",\");\n\n        while (commaTokenizer.hasMoreTokens()) {\n            String currentToken = commaTokenizer.nextToken();\n            int equalSign = currentToken.indexOf('=');\n            if (equalSign < 0)\n                return null;\n            String currentTokenName =\n                currentToken.substring(0, equalSign).trim();\n            String currentTokenValue =\n                currentToken.substring(equalSign + 1).trim();\n            if (\"username\".equals(currentTokenName))\n                return (removeQuotes(currentTokenValue));\n        }\n\n        return (null);\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void setAuthenticateHeader(HttpServletRequest request,\n                                         HttpServletResponse response,\n                                         LoginConfig config,\n                                         String nOnce) {\n\n        // Get the realm name\n        String realmName = config.getRealmName();\n        if (realmName == null)\n            realmName = REALM_NAME;\n\n        byte[] buffer = null;\n        synchronized (md5Helper) {\n            buffer = md5Helper.digest(nOnce.getBytes());\n        }\n\n        String authenticateHeader = \"Digest realm=\\\"\" + realmName + \"\\\", \"\n            +  \"qop=\\\"auth\\\", nonce=\\\"\" + nOnce + \"\\\", \" + \"opaque=\\\"\"\n            + md5Encoder.encode(buffer) + \"\\\"\";\n        response.setHeader(AUTH_HEADER_NAME, authenticateHeader);\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void setAuthenticateHeader(HttpServletRequest request,\n                                         HttpServletResponse response,\n                                         LoginConfig config,\n                                         String nOnce,\n                                         boolean isNonceStale) {\n\n        // Get the realm name\n        String realmName = config.getRealmName();\n        if (realmName == null)\n            realmName = REALM_NAME;\n\n        String authenticateHeader;\n        if (isNonceStale) {\n            authenticateHeader = \"Digest realm=\\\"\" + realmName + \"\\\", \" +\n            \"qop=\\\"\" + QOP + \"\\\", nonce=\\\"\" + nOnce + \"\\\", \" + \"opaque=\\\"\" +\n            getOpaque() + \"\\\", stale=true\";\n        } else {\n            authenticateHeader = \"Digest realm=\\\"\" + realmName + \"\\\", \" +\n            \"qop=\\\"\" + QOP + \"\\\", nonce=\\\"\" + nOnce + \"\\\", \" + \"opaque=\\\"\" +\n            getOpaque() + \"\\\"\";\n        }\n\n        response.setHeader(AUTH_HEADER_NAME, authenticateHeader);\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "page\n        if (!loginAction) {\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Save request in session '\" + session.getIdInternal() + \"'\");\n            }\n            try {\n                saveRequest(request, session);\n            } catch (IOException ioe) {\n                log.debug(\"Request body too big to save during authentication\");\n                response.sendError(HttpServletResponse.SC_FORBIDDEN,\n                        sm.getString(\"authenticator.requestBodyTooBig\"));\n                return false;\n            }\n            forwardToLoginPage(request, response, config);\n            return false;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "page\n        if (!loginAction) {\n            // If this request was to the root of the context without a trailing\n            // '/', need to redirect to add it else the submit of the login form\n            // may not go to the correct web application\n            if (request.getServletPath().length() == 0 && request.getPathInfo() == null) {\n                StringBuilder location = new StringBuilder(requestURI);\n                location.append('/');\n                if (request.getQueryString() != null) {\n                    location.append('?');\n                    location.append(request.getQueryString());\n                }\n                response.sendRedirect(response.encodeRedirectURL(location.toString()));\n                return false;\n            }\n\n            session = request.getSessionInternal(true);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Save request in session '\" + session.getIdInternal() + \"'\");\n            }\n            try {\n                saveRequest(request, session);\n            } catch (IOException ioe) {\n                log.debug(\"Request body too big to save during authentication\");\n                response.sendError(HttpServletResponse.SC_FORBIDDEN,\n                        sm.getString(\"authenticator.requestBodyTooBig\"));\n                return false;\n            }\n            forwardToLoginPage(request, response, config);\n            return false;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void fireOnComplete() {\n        List<AsyncListenerWrapper> listenersCopy = new ArrayList<>();\n        listenersCopy.addAll(listeners);\n\n        ClassLoader oldCL = context.bind(Globals.IS_SECURITY_ENABLED, null);\n        try {\n            for (AsyncListenerWrapper listener : listenersCopy) {\n                try {\n                    listener.fireOnComplete(event);\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.warn(\"onComplete() failed for listener of type [\" +\n                            listener.getClass().getName() + \"]\", t);\n                }\n            }\n        } finally {\n            context.fireRequestDestroyEvent(request);\n            clearServletRequestResponse();\n            context.unbind(Globals.IS_SECURITY_ENABLED, oldCL);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void fireOnComplete() {\n        List<AsyncListenerWrapper> listenersCopy = new ArrayList<>();\n        listenersCopy.addAll(listeners);\n\n        ClassLoader oldCL = context.bind(Globals.IS_SECURITY_ENABLED, null);\n        try {\n            for (AsyncListenerWrapper listener : listenersCopy) {\n                try {\n                    listener.fireOnComplete(event);\n                } catch (Throwable t) {\n                    ExceptionUtils.handleThrowable(t);\n                    log.warn(\"onComplete() failed for listener of type [\" +\n                            listener.getClass().getName() + \"]\", t);\n                }\n            }\n        } finally {\n            context.fireRequestDestroyEvent(request.getRequest());\n            clearServletRequestResponse();\n            context.unbind(Globals.IS_SECURITY_ENABLED, oldCL);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "[] findSecurityConstraints(Request request,\n                                                         Context context) {\n\n        ArrayList<SecurityConstraint> results = null;\n        // Are there any defined security constraints?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n\n        // Check each defined security constraint\n        String uri = request.getRequestPathMB().toString();\n        // Bug47080 - in rare cases this may be null\n        // Mapper treats as '/' do the same to prevent NPE\n        if (uri == null) {\n            uri = \"/\";\n        }\n\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    if(uri.equals(patterns[k])) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            // No applicable security constraint was found\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "[] findSecurityConstraints(Request request,\n                                                         Context context) {\n\n        ArrayList<SecurityConstraint> results = null;\n        // Are there any defined security constraints?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n\n        // Check each defined security constraint\n        String uri = request.getRequestPathMB().toString();\n        // Bug47080 - in rare cases this may be null or \"\"\n        // Mapper treats as '/' do the same to prevent NPE\n        if (uri == null || uri.length() == 0) {\n            uri = \"/\";\n        }\n\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    // Exact match including special case for the context root.\n                    if(uri.equals(patterns[k]) || patterns[k].length() == 0 && uri.equals(\"/\")) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            // No applicable security constraint was found\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "Principal authenticate(Connection dbConnection,\n                                               String username,\n                                               String credentials) {\n        // No user or no credentials\n        // Can't possibly authenticate, don't bother the database then\n        if (username == null || credentials == null) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Look up the user's credentials\n        String dbCredentials = getPassword(username);\n\n        if (dbCredentials == null) {\n            // User was not found in the database.\n\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Validate the user's credentials\n        boolean validated = getCredentialHandler().matches(credentials, dbCredentials);\n\n        if (validated) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateSuccess\",\n                                                username));\n        } else {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        ArrayList<String> roles = getRoles(username);\n\n        // Create and return a suitable Principal for this user\n        return (new GenericPrincipal(username, credentials, roles));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "Principal authenticate(Connection dbConnection,\n                                               String username,\n                                               String credentials) {\n        // No user or no credentials\n        // Can't possibly authenticate, don't bother the database then\n        if (username == null || credentials == null) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Look up the user's credentials\n        String dbCredentials = getPassword(username);\n\n        if (dbCredentials == null) {\n            // User was not found in the database.\n            // Waste a bit of time as not to reveal that the user does not exist.\n            getCredentialHandler().mutate(credentials);\n\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Validate the user's credentials\n        boolean validated = getCredentialHandler().matches(credentials, dbCredentials);\n\n        if (validated) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateSuccess\",\n                                                username));\n        } else {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"jdbcRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        ArrayList<String> roles = getRoles(username);\n\n        // Create and return a suitable Principal for this user\n        return (new GenericPrincipal(username, credentials, roles));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Principal authenticate(String username, String credentials) {\n\n        // No user or no credentials\n        // Can't possibly authenticate, don't bother the database then\n        if (username == null || credentials == null) {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateFailure\", username));\n            return null;\n        }\n\n        GenericPrincipal principal = principals.get(username);\n\n        if(principal == null || principal.getPassword() == null) {\n            // User was not found in the database of the password was null\n\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateFailure\", username));\n            return null;\n        }\n\n        boolean validated = getCredentialHandler().matches(credentials, principal.getPassword());\n\n        if (validated) {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateSuccess\", username));\n            return principal;\n        } else {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateFailure\", username));\n            return null;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Principal authenticate(String username, String credentials) {\n\n        // No user or no credentials\n        // Can't possibly authenticate, don't bother the database then\n        if (username == null || credentials == null) {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateFailure\", username));\n            return null;\n        }\n\n        GenericPrincipal principal = principals.get(username);\n\n        if(principal == null || principal.getPassword() == null) {\n            // User was not found in the database or the password was null\n            // Waste a bit of time as not to reveal that the user does not exist.\n            getCredentialHandler().mutate(credentials);\n\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateFailure\", username));\n            return null;\n        }\n\n        boolean validated = getCredentialHandler().matches(credentials, principal.getPassword());\n\n        if (validated) {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateSuccess\", username));\n            return principal;\n        } else {\n            if (log.isDebugEnabled())\n                log.debug(sm.getString(\"memoryRealm.authenticateFailure\", username));\n            return null;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Principal authenticate(Connection dbConnection,\n                                     String username,\n                                     String credentials) {\n        // No user or no credentials\n        // Can't possibly authenticate, don't bother the database then\n        if (username == null || credentials == null) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Look up the user's credentials\n        String dbCredentials = getPassword(dbConnection, username);\n\n        if(dbCredentials == null) {\n            // User was not found in the database.\n\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Validate the user's credentials\n        boolean validated = getCredentialHandler().matches(credentials, dbCredentials);\n\n        if (validated) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateSuccess\",\n                                                username));\n        } else {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        ArrayList<String> list = getRoles(dbConnection, username);\n\n        // Create and return a suitable Principal for this user\n        return new GenericPrincipal(username, credentials, list);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Principal authenticate(Connection dbConnection,\n                                     String username,\n                                     String credentials) {\n        // No user or no credentials\n        // Can't possibly authenticate, don't bother the database then\n        if (username == null || credentials == null) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Look up the user's credentials\n        String dbCredentials = getPassword(dbConnection, username);\n\n        if(dbCredentials == null) {\n            // User was not found in the database.\n            // Waste a bit of time as not to reveal that the user does not exist.\n            getCredentialHandler().mutate(credentials);\n\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        // Validate the user's credentials\n        boolean validated = getCredentialHandler().matches(credentials, dbCredentials);\n\n        if (validated) {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateSuccess\",\n                                                username));\n        } else {\n            if (containerLog.isTraceEnabled())\n                containerLog.trace(sm.getString(\"dataSourceRealm.authenticateFailure\",\n                                                username));\n            return null;\n        }\n\n        ArrayList<String> list = getRoles(dbConnection, username);\n\n        // Create and return a suitable Principal for this user\n        return new GenericPrincipal(username, credentials, list);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String createGroup(String groupname, String description) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Group group = database.createGroup(groupname, description);\n        try {\n            MBeanUtils.createMBean(group);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception creating group \" + group + \" MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n        return (findGroup(groupname));\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String createGroup(String groupname, String description) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Group group = database.createGroup(groupname, description);\n        try {\n            MBeanUtils.createMBean(group);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception creating group [\" + groupname + \"] MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n        return (findGroup(groupname));\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String createRole(String rolename, String description) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Role role = database.createRole(rolename, description);\n        try {\n            MBeanUtils.createMBean(role);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception creating role \" + role + \" MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n        return (findRole(rolename));\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String createRole(String rolename, String description) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Role role = database.createRole(rolename, description);\n        try {\n            MBeanUtils.createMBean(role);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception creating role [\" + rolename + \"] MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n        return (findRole(rolename));\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String createUser(String username, String password,\n                             String fullName) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        User user = database.createUser(username, password, fullName);\n        try {\n            MBeanUtils.createMBean(user);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception creating user \" + user + \" MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n        return (findUser(username));\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String createUser(String username, String password,\n                             String fullName) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        User user = database.createUser(username, password, fullName);\n        try {\n            MBeanUtils.createMBean(user);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception creating user [\" + username + \"] MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n        return (findUser(username));\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String findGroup(String groupname) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Group group = database.findGroup(groupname);\n        if (group == null) {\n            return (null);\n        }\n        try {\n            ObjectName oname =\n                MBeanUtils.createObjectName(managedGroup.getDomain(), group);\n            return (oname.toString());\n        } catch (MalformedObjectNameException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Cannot create object name for group \" + group);\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String findGroup(String groupname) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Group group = database.findGroup(groupname);\n        if (group == null) {\n            return (null);\n        }\n        try {\n            ObjectName oname =\n                MBeanUtils.createObjectName(managedGroup.getDomain(), group);\n            return (oname.toString());\n        } catch (MalformedObjectNameException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Cannot create object name for group [\" + groupname + \"]\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String findRole(String rolename) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Role role = database.findRole(rolename);\n        if (role == null) {\n            return (null);\n        }\n        try {\n            ObjectName oname =\n                MBeanUtils.createObjectName(managedRole.getDomain(), role);\n            return (oname.toString());\n        } catch (MalformedObjectNameException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Cannot create object name for role \" + role);\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String findRole(String rolename) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Role role = database.findRole(rolename);\n        if (role == null) {\n            return (null);\n        }\n        try {\n            ObjectName oname =\n                MBeanUtils.createObjectName(managedRole.getDomain(), role);\n            return (oname.toString());\n        } catch (MalformedObjectNameException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Cannot create object name for role [\" + rolename + \"]\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String findUser(String username) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        User user = database.findUser(username);\n        if (user == null) {\n            return (null);\n        }\n        try {\n            ObjectName oname =\n                MBeanUtils.createObjectName(managedUser.getDomain(), user);\n            return (oname.toString());\n        } catch (MalformedObjectNameException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Cannot create object name for user \" + user);\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String findUser(String username) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        User user = database.findUser(username);\n        if (user == null) {\n            return (null);\n        }\n        try {\n            ObjectName oname =\n                MBeanUtils.createObjectName(managedUser.getDomain(), user);\n            return (oname.toString());\n        } catch (MalformedObjectNameException e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Cannot create object name for user [\" + username + \"]\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void removeGroup(String groupname) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Group group = database.findGroup(groupname);\n        if (group == null) {\n            return;\n        }\n        try {\n            MBeanUtils.destroyMBean(group);\n            database.removeGroup(group);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception destroying group \" + group + \" MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void removeGroup(String groupname) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Group group = database.findGroup(groupname);\n        if (group == null) {\n            return;\n        }\n        try {\n            MBeanUtils.destroyMBean(group);\n            database.removeGroup(group);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception destroying group [\" + groupname + \"] MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void removeRole(String rolename) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Role role = database.findRole(rolename);\n        if (role == null) {\n            return;\n        }\n        try {\n            MBeanUtils.destroyMBean(role);\n            database.removeRole(role);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception destroying role \" + role + \" MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void removeRole(String rolename) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        Role role = database.findRole(rolename);\n        if (role == null) {\n            return;\n        }\n        try {\n            MBeanUtils.destroyMBean(role);\n            database.removeRole(role);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception destroying role [\" + rolename + \"] MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void removeUser(String username) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        User user = database.findUser(username);\n        if (user == null) {\n            return;\n        }\n        try {\n            MBeanUtils.destroyMBean(user);\n            database.removeUser(user);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception destroying user \" + user + \" MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void removeUser(String username) {\n\n        UserDatabase database = (UserDatabase) this.resource;\n        User user = database.findUser(username);\n        if (user == null) {\n            return;\n        }\n        try {\n            MBeanUtils.destroyMBean(user);\n            database.removeUser(user);\n        } catch (Exception e) {\n            IllegalArgumentException iae = new IllegalArgumentException\n                (\"Exception destroying user [\" + username + \"] MBean\");\n            iae.initCause(e);\n            throw iae;\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static boolean normalize(MessageBytes uriMB) {\n\n        ByteChunk uriBC = uriMB.getByteChunk();\n        byte[] b = uriBC.getBytes();\n        int start = uriBC.getStart();\n        int end = uriBC.getEnd();\n\n        // URL * is acceptable\n        if ((end - start == 1) && b[start] == (byte) '*')\n          return true;\n\n        int pos = 0;\n        int index = 0;\n\n        // Replace '\\' with '/'\n        // Check for null byte\n        for (pos = start; pos < end; pos++) {\n            if (b[pos] == (byte) '\\\\')\n                b[pos] = (byte) '/';\n            if (b[pos] == (byte) 0)\n                return false;\n        }\n\n        // The URL must start with '/'\n        if (b[start] != (byte) '/') {\n            return false;\n        }\n\n        // Replace \"//\" with \"/\"\n        for (pos = start; pos < (end - 1); pos++) {\n            if (b[pos] == (byte) '/') {\n                while ((pos + 1 < end) && (b[pos + 1] == (byte) '/')) {\n                    copyBytes(b, pos, pos + 1, end - pos - 1);\n                    end--;\n                }\n            }\n        }\n\n        // If the URI ends with \"/.\" or \"/..\", then we append an extra \"/\"\n        // Note: It is possible to extend the URI by 1 without any side effect\n        // as the next character is a non-significant WS.\n        if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {\n            if ((b[end - 2] == (byte) '/') \n                || ((b[end - 2] == (byte) '.') \n                    && (b[end - 3] == (byte) '/'))) {\n                b[end] = (byte) '/';\n                end++;\n            }\n        }\n\n        uriBC.setEnd(end);\n\n        index = 0;\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/./\", 0, 3, index);\n            if (index < 0)\n                break;\n            copyBytes(b, start + index, start + index + 2, \n                      end - start - index - 2);\n            end = end - 2;\n            uriBC.setEnd(end);\n        }\n\n        index = 0;\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/../\", 0, 4, index);\n            if (index < 0)\n                break;\n            // Prevent from going outside our context\n            if (index == 0)\n                return false;\n            int index2 = -1;\n            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {\n                if (b[pos] == (byte) '/') {\n                    index2 = pos;\n                }\n            }\n            copyBytes(b, start + index2, start + index + 3,\n                      end - start - index - 3);\n            end = end + index2 - index - 3;\n            uriBC.setEnd(end);\n            index = index2;\n        }\n\n        uriBC.setBytes(b, start, end);\n\n        return true;\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static boolean normalize(MessageBytes uriMB) {\n\n        ByteChunk uriBC = uriMB.getByteChunk();\n        byte[] b = uriBC.getBytes();\n        int start = uriBC.getStart();\n        int end = uriBC.getEnd();\n\n        // URL * is acceptable\n        if ((end - start == 1) && b[start] == (byte) '*')\n          return true;\n\n        int pos = 0;\n        int index = 0;\n\n        // Replace '\\' with '/'\n        // Check for null byte\n        for (pos = start; pos < end; pos++) {\n            if (b[pos] == (byte) '\\\\') {\n                if (ALLOW_BACKSLASH) {\n                    b[pos] = (byte) '/';\n                } else {\n                    return false;\n                }\n            }\n            if (b[pos] == (byte) 0) {\n                return false;\n            }\n        }\n\n        // The URL must start with '/'\n        if (b[start] != (byte) '/') {\n            return false;\n        }\n\n        // Replace \"//\" with \"/\"\n        for (pos = start; pos < (end - 1); pos++) {\n            if (b[pos] == (byte) '/') {\n                while ((pos + 1 < end) && (b[pos + 1] == (byte) '/')) {\n                    copyBytes(b, pos, pos + 1, end - pos - 1);\n                    end--;\n                }\n            }\n        }\n\n        // If the URI ends with \"/.\" or \"/..\", then we append an extra \"/\"\n        // Note: It is possible to extend the URI by 1 without any side effect\n        // as the next character is a non-significant WS.\n        if (((end - start) >= 2) && (b[end - 1] == (byte) '.')) {\n            if ((b[end - 2] == (byte) '/') \n                || ((b[end - 2] == (byte) '.') \n                    && (b[end - 3] == (byte) '/'))) {\n                b[end] = (byte) '/';\n                end++;\n            }\n        }\n\n        uriBC.setEnd(end);\n\n        index = 0;\n\n        // Resolve occurrences of \"/./\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/./\", 0, 3, index);\n            if (index < 0)\n                break;\n            copyBytes(b, start + index, start + index + 2, \n                      end - start - index - 2);\n            end = end - 2;\n            uriBC.setEnd(end);\n        }\n\n        index = 0;\n\n        // Resolve occurrences of \"/../\" in the normalized path\n        while (true) {\n            index = uriBC.indexOf(\"/../\", 0, 4, index);\n            if (index < 0)\n                break;\n            // Prevent from going outside our context\n            if (index == 0)\n                return false;\n            int index2 = -1;\n            for (pos = start + index - 1; (pos >= 0) && (index2 < 0); pos --) {\n                if (b[pos] == (byte) '/') {\n                    index2 = pos;\n                }\n            }\n            copyBytes(b, start + index2, start + index + 3,\n                      end - start - index - 3);\n            end = end + index2 - index - 3;\n            uriBC.setEnd(end);\n            index = index2;\n        }\n\n        uriBC.setBytes(b, start, end);\n\n        return true;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "byte\n        for (pos = start; pos < end; pos++) {\n            if (b[pos] == (byte) '\\\\')\n                b[pos] = (byte) '/';\n            if (b[pos] == (byte) 0)\n                return false;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "byte\n        for (pos = start; pos < end; pos++) {\n            if (b[pos] == (byte) '\\\\') {\n                if (ALLOW_BACKSLASH) {\n                    b[pos] = (byte) '/';\n                } else {\n                    return false;\n                }\n            }\n            if (b[pos] == (byte) 0) {\n                return false;\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String toString() {\n\n        StringBuilder sb = new StringBuilder(\"<user username=\\\"\");\n        sb.append(RequestUtil.filter(username));\n        sb.append(\"\\\" password=\\\"\");\n        sb.append(RequestUtil.filter(password));\n        sb.append(\"\\\"\");\n        if (fullName != null) {\n            sb.append(\" fullName=\\\"\");\n            sb.append(RequestUtil.filter(fullName));\n            sb.append(\"\\\"\");\n        }\n        synchronized (groups) {\n            if (groups.size() > 0) {\n                sb.append(\" groups=\\\"\");\n                int n = 0;\n                Iterator<Group> values = groups.iterator();\n                while (values.hasNext()) {\n                    if (n > 0) {\n                        sb.append(',');\n                    }\n                    n++;\n                    sb.append(RequestUtil.filter(values.next().getGroupname()));\n                }\n                sb.append(\"\\\"\");\n            }\n        }\n        synchronized (roles) {\n            if (roles.size() > 0) {\n                sb.append(\" roles=\\\"\");\n                int n = 0;\n                Iterator<Role> values = roles.iterator();\n                while (values.hasNext()) {\n                    if (n > 0) {\n                        sb.append(',');\n                    }\n                    n++;\n                    sb.append(RequestUtil.filter(values.next().getRolename()));\n                }\n                sb.append(\"\\\"\");\n            }\n        }\n        sb.append(\"/>\");\n        return (sb.toString());\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String toString() {\n\n        StringBuilder sb = new StringBuilder(\"User username=\\\"\");\n        sb.append(RequestUtil.filter(username));\n        sb.append(\"\\\"\");\n        if (fullName != null) {\n            sb.append(\", fullName=\\\"\");\n            sb.append(RequestUtil.filter(fullName));\n            sb.append(\"\\\"\");\n        }\n        synchronized (groups) {\n            if (groups.size() > 0) {\n                sb.append(\", groups=\\\"\");\n                int n = 0;\n                Iterator<Group> values = groups.iterator();\n                while (values.hasNext()) {\n                    if (n > 0) {\n                        sb.append(',');\n                    }\n                    n++;\n                    sb.append(RequestUtil.filter(values.next().getGroupname()));\n                }\n                sb.append(\"\\\"\");\n            }\n        }\n        synchronized (roles) {\n            if (roles.size() > 0) {\n                sb.append(\", roles=\\\"\");\n                int n = 0;\n                Iterator<Role> values = roles.iterator();\n                while (values.hasNext()) {\n                    if (n > 0) {\n                        sb.append(',');\n                    }\n                    n++;\n                    sb.append(RequestUtil.filter(values.next().getRolename()));\n                }\n                sb.append(\"\\\"\");\n            }\n        }\n        return (sb.toString());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "void stop() {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"contextConfig.stop\"));\n\n        int i;\n\n        // Removing children\n        Container[] children = context.findChildren();\n        for (i = 0; i < children.length; i++) {\n            context.removeChild(children[i]);\n        }\n\n        // Removing application parameters\n        /*\n        ApplicationParameter[] applicationParameters =\n            context.findApplicationParameters();\n        for (i = 0; i < applicationParameters.length; i++) {\n            context.removeApplicationParameter\n                (applicationParameters[i].getName());\n        }\n        */\n\n        // Removing security constraints\n        SecurityConstraint[] securityConstraints = context.findConstraints();\n        for (i = 0; i < securityConstraints.length; i++) {\n            context.removeConstraint(securityConstraints[i]);\n        }\n\n        // Removing Ejbs\n        /*\n        ContextEjb[] contextEjbs = context.findEjbs();\n        for (i = 0; i < contextEjbs.length; i++) {\n            context.removeEjb(contextEjbs[i].getName());\n        }\n        */\n\n        // Removing environments\n        /*\n        ContextEnvironment[] contextEnvironments = context.findEnvironments();\n        for (i = 0; i < contextEnvironments.length; i++) {\n            context.removeEnvironment(contextEnvironments[i].getName());\n        }\n        */\n\n        // Removing errors pages\n        ErrorPage[] errorPages = context.findErrorPages();\n        for (i = 0; i < errorPages.length; i++) {\n            context.removeErrorPage(errorPages[i]);\n        }\n\n        // Removing filter defs\n        FilterDef[] filterDefs = context.findFilterDefs();\n        for (i = 0; i < filterDefs.length; i++) {\n            context.removeFilterDef(filterDefs[i]);\n        }\n\n        // Removing filter maps\n        FilterMap[] filterMaps = context.findFilterMaps();\n        for (i = 0; i < filterMaps.length; i++) {\n            context.removeFilterMap(filterMaps[i]);\n        }\n\n        // Removing local ejbs\n        /*\n        ContextLocalEjb[] contextLocalEjbs = context.findLocalEjbs();\n        for (i = 0; i < contextLocalEjbs.length; i++) {\n            context.removeLocalEjb(contextLocalEjbs[i].getName());\n        }\n        */\n\n        // Removing Mime mappings\n        String[] mimeMappings = context.findMimeMappings();\n        for (i = 0; i < mimeMappings.length; i++) {\n            context.removeMimeMapping(mimeMappings[i]);\n        }\n\n        // Removing parameters\n        String[] parameters = context.findParameters();\n        for (i = 0; i < parameters.length; i++) {\n            context.removeParameter(parameters[i]);\n        }\n\n        // Removing resource env refs\n        /*\n        String[] resourceEnvRefs = context.findResourceEnvRefs();\n        for (i = 0; i < resourceEnvRefs.length; i++) {\n            context.removeResourceEnvRef(resourceEnvRefs[i]);\n        }\n        */\n\n        // Removing resource links\n        /*\n        ContextResourceLink[] contextResourceLinks =\n            context.findResourceLinks();\n        for (i = 0; i < contextResourceLinks.length; i++) {\n            context.removeResourceLink(contextResourceLinks[i].getName());\n        }\n        */\n\n        // Removing resources\n        /*\n        ContextResource[] contextResources = context.findResources();\n        for (i = 0; i < contextResources.length; i++) {\n            context.removeResource(contextResources[i].getName());\n        }\n        */\n\n        // Removing security role\n        String[] securityRoles = context.findSecurityRoles();\n        for (i = 0; i < securityRoles.length; i++) {\n            context.removeSecurityRole(securityRoles[i]);\n        }\n\n        // Removing servlet mappings\n        String[] servletMappings = context.findServletMappings();\n        for (i = 0; i < servletMappings.length; i++) {\n            context.removeServletMapping(servletMappings[i]);\n        }\n\n        // FIXME : Removing status pages\n\n        // Removing taglibs\n        String[] taglibs = context.findTaglibs();\n        for (i = 0; i < taglibs.length; i++) {\n            context.removeTaglib(taglibs[i]);\n        }\n\n        // Removing welcome files\n        String[] welcomeFiles = context.findWelcomeFiles();\n        for (i = 0; i < welcomeFiles.length; i++) {\n            context.removeWelcomeFile(welcomeFiles[i]);\n        }\n\n        // Removing wrapper lifecycles\n        String[] wrapperLifecycles = context.findWrapperLifecycles();\n        for (i = 0; i < wrapperLifecycles.length; i++) {\n            context.removeWrapperLifecycle(wrapperLifecycles[i]);\n        }\n\n        // Removing wrapper listeners\n        String[] wrapperListeners = context.findWrapperListeners();\n        for (i = 0; i < wrapperListeners.length; i++) {\n            context.removeWrapperListener(wrapperListeners[i]);\n        }\n\n        // Remove (partially) folders and files created by antiLocking\n        Host host = (Host) context.getParent();\n        String appBase = host.getAppBase();\n        String docBase = context.getDocBase();\n        if ((docBase != null) && (originalDocBase != null)) {\n            File docBaseFile = new File(docBase);\n            if (!docBaseFile.isAbsolute()) {\n                docBaseFile = new File(appBase, docBase);\n            }\n            ExpandWar.delete(docBaseFile);\n        }\n        \n        ok = true;\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "void stop() {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"contextConfig.stop\"));\n\n        int i;\n\n        // Removing children\n        Container[] children = context.findChildren();\n        for (i = 0; i < children.length; i++) {\n            context.removeChild(children[i]);\n        }\n\n        // Removing application parameters\n        /*\n        ApplicationParameter[] applicationParameters =\n            context.findApplicationParameters();\n        for (i = 0; i < applicationParameters.length; i++) {\n            context.removeApplicationParameter\n                (applicationParameters[i].getName());\n        }\n        */\n\n        // Removing security constraints\n        SecurityConstraint[] securityConstraints = context.findConstraints();\n        for (i = 0; i < securityConstraints.length; i++) {\n            context.removeConstraint(securityConstraints[i]);\n        }\n\n        // Removing Ejbs\n        /*\n        ContextEjb[] contextEjbs = context.findEjbs();\n        for (i = 0; i < contextEjbs.length; i++) {\n            context.removeEjb(contextEjbs[i].getName());\n        }\n        */\n\n        // Removing environments\n        /*\n        ContextEnvironment[] contextEnvironments = context.findEnvironments();\n        for (i = 0; i < contextEnvironments.length; i++) {\n            context.removeEnvironment(contextEnvironments[i].getName());\n        }\n        */\n\n        // Removing errors pages\n        ErrorPage[] errorPages = context.findErrorPages();\n        for (i = 0; i < errorPages.length; i++) {\n            context.removeErrorPage(errorPages[i]);\n        }\n\n        // Removing filter defs\n        FilterDef[] filterDefs = context.findFilterDefs();\n        for (i = 0; i < filterDefs.length; i++) {\n            context.removeFilterDef(filterDefs[i]);\n        }\n\n        // Removing filter maps\n        FilterMap[] filterMaps = context.findFilterMaps();\n        for (i = 0; i < filterMaps.length; i++) {\n            context.removeFilterMap(filterMaps[i]);\n        }\n\n        // Removing local ejbs\n        /*\n        ContextLocalEjb[] contextLocalEjbs = context.findLocalEjbs();\n        for (i = 0; i < contextLocalEjbs.length; i++) {\n            context.removeLocalEjb(contextLocalEjbs[i].getName());\n        }\n        */\n\n        // Removing Mime mappings\n        String[] mimeMappings = context.findMimeMappings();\n        for (i = 0; i < mimeMappings.length; i++) {\n            context.removeMimeMapping(mimeMappings[i]);\n        }\n\n        // Removing parameters\n        String[] parameters = context.findParameters();\n        for (i = 0; i < parameters.length; i++) {\n            context.removeParameter(parameters[i]);\n        }\n\n        // Removing resource env refs\n        /*\n        String[] resourceEnvRefs = context.findResourceEnvRefs();\n        for (i = 0; i < resourceEnvRefs.length; i++) {\n            context.removeResourceEnvRef(resourceEnvRefs[i]);\n        }\n        */\n\n        // Removing resource links\n        /*\n        ContextResourceLink[] contextResourceLinks =\n            context.findResourceLinks();\n        for (i = 0; i < contextResourceLinks.length; i++) {\n            context.removeResourceLink(contextResourceLinks[i].getName());\n        }\n        */\n\n        // Removing resources\n        /*\n        ContextResource[] contextResources = context.findResources();\n        for (i = 0; i < contextResources.length; i++) {\n            context.removeResource(contextResources[i].getName());\n        }\n        */\n\n        // Removing security role\n        String[] securityRoles = context.findSecurityRoles();\n        for (i = 0; i < securityRoles.length; i++) {\n            context.removeSecurityRole(securityRoles[i]);\n        }\n\n        // Removing servlet mappings\n        String[] servletMappings = context.findServletMappings();\n        for (i = 0; i < servletMappings.length; i++) {\n            context.removeServletMapping(servletMappings[i]);\n        }\n\n        // FIXME : Removing status pages\n\n        // Removing taglibs\n        String[] taglibs = context.findTaglibs();\n        for (i = 0; i < taglibs.length; i++) {\n            context.removeTaglib(taglibs[i]);\n        }\n\n        // Removing welcome files\n        String[] welcomeFiles = context.findWelcomeFiles();\n        for (i = 0; i < welcomeFiles.length; i++) {\n            context.removeWelcomeFile(welcomeFiles[i]);\n        }\n\n        // Removing wrapper lifecycles\n        String[] wrapperLifecycles = context.findWrapperLifecycles();\n        for (i = 0; i < wrapperLifecycles.length; i++) {\n            context.removeWrapperLifecycle(wrapperLifecycles[i]);\n        }\n\n        // Removing wrapper listeners\n        String[] wrapperListeners = context.findWrapperListeners();\n        for (i = 0; i < wrapperListeners.length; i++) {\n            context.removeWrapperListener(wrapperListeners[i]);\n        }\n\n        // Remove (partially) folders and files created by antiLocking\n        Host host = (Host) context.getParent();\n        String appBase = host.getAppBase();\n        String docBase = context.getDocBase();\n        if ((docBase != null) && (originalDocBase != null)) {\n            File docBaseFile = new File(docBase);\n            if (!docBaseFile.isAbsolute()) {\n                docBaseFile = new File(appBase, docBase);\n            }\n            // No need to log failure - it is expected in this case\n            ExpandWar.delete(docBaseFile, false);\n        }\n        \n        ok = true;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static boolean delete(File dir) {\n        if (dir.isDirectory()) {\n            return deleteDir(dir);\n        } else {\n            return dir.delete();\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static boolean delete(File dir, boolean logFailure) {\n        boolean result;\n        if (dir.isDirectory()) {\n            result = deleteDir(dir, logFailure);\n        } else {\n            if (dir.exists()) {\n                result = dir.delete();\n            } else {\n                result = true;\n            }\n        }\n        if (logFailure && !result) {\n            log.error(sm.getString(\n                    \"expandWar.deleteFailed\", dir.getAbsolutePath()));\n        }\n        return result;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static boolean deleteDir(File dir) {\n\n        String files[] = dir.list();\n        if (files == null) {\n            files = new String[0];\n        }\n        for (int i = 0; i < files.length; i++) {\n            File file = new File(dir, files[i]);\n            if (file.isDirectory()) {\n                deleteDir(file);\n            } else {\n                file.delete();\n            }\n        }\n        return dir.delete();\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static boolean deleteDir(File dir, boolean logFailure) {\n\n        String files[] = dir.list();\n        if (files == null) {\n            files = new String[0];\n        }\n        for (int i = 0; i < files.length; i++) {\n            File file = new File(dir, files[i]);\n            if (file.isDirectory()) {\n                deleteDir(file, logFailure);\n            } else {\n                file.delete();\n            }\n        }\n\n        boolean result;\n        if (dir.exists()) {\n            result = dir.delete();\n        } else {\n            result = true;\n        }\n        \n        if (logFailure && !result) {\n            log.error(sm.getString(\n                    \"expandWar.deleteFailed\", dir.getAbsolutePath()));\n        }\n        \n        return result;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void deployWARs(File appBase, String[] files) {\n        \n        if (files == null)\n            return;\n        \n        for (int i = 0; i < files.length; i++) {\n            \n            if (files[i].equalsIgnoreCase(\"META-INF\"))\n                continue;\n            if (files[i].equalsIgnoreCase(\"WEB-INF\"))\n                continue;\n            File dir = new File(appBase, files[i]);\n            if (files[i].toLowerCase().endsWith(\".war\") && dir.isFile()) {\n                \n                // Calculate the context path and make sure it is unique\n                String contextPath = \"/\" + files[i].replace('#','/');\n                int period = contextPath.lastIndexOf(\".\");\n                if (period >= 0)\n                    contextPath = contextPath.substring(0, period);\n                if (contextPath.equals(\"/ROOT\"))\n                    contextPath = \"\";\n                \n                if (isServiced(contextPath))\n                    continue;\n                \n                String file = files[i];\n                \n                deployWAR(contextPath, dir, file);\n                \n            }\n            \n        }\n        \n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void deployWARs(File appBase, String[] files) {\n        \n        if (files == null)\n            return;\n        \n        for (int i = 0; i < files.length; i++) {\n            \n            if (files[i].equalsIgnoreCase(\"META-INF\"))\n                continue;\n            if (files[i].equalsIgnoreCase(\"WEB-INF\"))\n                continue;\n            File dir = new File(appBase, files[i]);\n            if (files[i].toLowerCase().endsWith(\".war\") && dir.isFile()\n                    && !invalidWars.contains(files[i]) ) {\n                \n                // Calculate the context path and make sure it is unique\n                String contextPath = \"/\" + files[i].replace('#','/');\n                int period = contextPath.lastIndexOf(\".\");\n                contextPath = contextPath.substring(0, period);\n                \n                // Check for WARs with /../ /./ or similar sequences in the name\n                if (!validateContextPath(appBase, contextPath)) {\n                    log.error(sm.getString(\n                            \"hostConfig.illegalWarName\", files[i]));\n                    invalidWars.add(files[i]);\n                    continue;\n                }\n\n                if (contextPath.equals(\"/ROOT\"))\n                    contextPath = \"\";\n                \n                if (isServiced(contextPath))\n                    continue;\n                \n                String file = files[i];\n                \n                deployWAR(contextPath, dir, file);\n                \n            }\n            \n        }\n        \n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        for (Stream stream : streams.values()) {\n            // The connection is closing. Close the associated streams as no\n            // longer required.\n            stream.receiveReset(Http2Error.CANCEL.getCode());\n        }\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Http11NioProcessor createProcessor() {\n            Http11NioProcessor processor = new Http11NioProcessor(\n                    proto.getMaxHttpHeaderSize(), (NioEndpoint)proto.endpoint,\n                    proto.getMaxTrailerSize());\n            processor.setAdapter(proto.getAdapter());\n            processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\n            processor.setConnectionUploadTimeout(\n                    proto.getConnectionUploadTimeout());\n            processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());\n            processor.setCompressionMinSize(proto.getCompressionMinSize());\n            processor.setCompression(proto.getCompression());\n            processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());\n            processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());\n            processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());\n            processor.setSocketBuffer(proto.getSocketBuffer());\n            processor.setMaxSavePostSize(proto.getMaxSavePostSize());\n            processor.setServer(proto.getServer());\n            register(processor);\n            return processor;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Http11NioProcessor createProcessor() {\n            Http11NioProcessor processor = new Http11NioProcessor(\n                    proto.getMaxHttpHeaderSize(), (NioEndpoint)proto.endpoint,\n                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize());\n            processor.setAdapter(proto.getAdapter());\n            processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\n            processor.setConnectionUploadTimeout(\n                    proto.getConnectionUploadTimeout());\n            processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());\n            processor.setCompressionMinSize(proto.getCompressionMinSize());\n            processor.setCompression(proto.getCompression());\n            processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());\n            processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());\n            processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());\n            processor.setSocketBuffer(proto.getSocketBuffer());\n            processor.setMaxSavePostSize(proto.getMaxSavePostSize());\n            processor.setServer(proto.getServer());\n            register(processor);\n            return processor;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Http11NioProcessor(int maxHttpHeaderSize, NioEndpoint endpoint,\n            int maxTrailerSize) {\n\n        super(endpoint);\n\n        inputBuffer = new InternalNioInputBuffer(request, maxHttpHeaderSize);\n        request.setInputBuffer(inputBuffer);\n\n        outputBuffer = new InternalNioOutputBuffer(response, maxHttpHeaderSize);\n        response.setOutputBuffer(outputBuffer);\n\n        initializeFilters(maxTrailerSize);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Http11NioProcessor(int maxHttpHeaderSize, NioEndpoint endpoint,\n            int maxTrailerSize, int maxExtensionSize) {\n\n        super(endpoint);\n\n        inputBuffer = new InternalNioInputBuffer(request, maxHttpHeaderSize);\n        request.setInputBuffer(inputBuffer);\n\n        outputBuffer = new InternalNioOutputBuffer(response, maxHttpHeaderSize);\n        response.setOutputBuffer(outputBuffer);\n\n        initializeFilters(maxTrailerSize, maxExtensionSize);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void prepareRequest() {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n        sendfileData = null;\n\n        if (protocol.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            http11 = true;\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null) {\n            ByteChunk connectionValueBC = connectionValueMB.getByteChunk();\n            if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) {\n                keepAlive = false;\n            } else if (findBytes(connectionValueBC,\n                                 Constants.KEEPALIVE_BYTES) != -1) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null) {\n                if (expectMB.indexOfIgnoreCase(\"100-continue\", 0) != -1) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n        // Check for a full URI (including protocol://host:port/)\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\"\n                    request.requestURI().setBytes\n                        (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                        (uriB, uriBCStart + slashPos,\n                         uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                                slashPos - pos - 3);\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                String transferEncodingValue = transferEncodingValueMB.toString();\n                // Parse the comma separated list. \"identity\" codings are ignored\n                int startPos = 0;\n                int commaPos = transferEncodingValue.indexOf(',');\n                String encodingName = null;\n                while (commaPos != -1) {\n                    encodingName = transferEncodingValue.substring(startPos, commaPos);\n                    addInputFilter(inputFilters, encodingName);\n                    startPos = commaPos + 1;\n                    commaPos = transferEncodingValue.indexOf(',', startPos);\n                }\n                encodingName = transferEncodingValue.substring(startPos);\n                addInputFilter(inputFilters, encodingName);\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = request.getContentLengthLong();\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                inputBuffer.addActiveFilter\n                        (inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        MessageBytes valueMB = headers.getValue(\"host\");\n\n        // Check host header\n        if (http11 && (valueMB == null)) {\n            // 400 - Bad request\n            response.setStatus(400);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" host header missing\");\n            }\n        }\n\n        parseHost(valueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter\n                    (inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (getErrorState().isError()) {\n            getAdapter().log(request, response, 0);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void prepareRequest() {\n\n        http11 = true;\n        http09 = false;\n        contentDelimitation = false;\n\n        if (protocol.isSSLEnabled()) {\n            request.scheme().setString(\"https\");\n        }\n        MessageBytes protocolMB = request.protocol();\n        if (protocolMB.equals(Constants.HTTP_11)) {\n            http11 = true;\n            protocolMB.setString(Constants.HTTP_11);\n        } else if (protocolMB.equals(Constants.HTTP_10)) {\n            http11 = false;\n            keepAlive = false;\n            protocolMB.setString(Constants.HTTP_10);\n        } else if (protocolMB.equals(\"\")) {\n            // HTTP/0.9\n            http09 = true;\n            http11 = false;\n            keepAlive = false;\n        } else {\n            // Unsupported protocol\n            http11 = false;\n            // Send 505; Unsupported HTTP version\n            response.setStatus(505);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" Unsupported HTTP version \\\"\"+protocolMB+\"\\\"\");\n            }\n        }\n\n        MimeHeaders headers = request.getMimeHeaders();\n\n        // Check connection header\n        MessageBytes connectionValueMB = headers.getValue(Constants.CONNECTION);\n        if (connectionValueMB != null) {\n            ByteChunk connectionValueBC = connectionValueMB.getByteChunk();\n            if (findBytes(connectionValueBC, Constants.CLOSE_BYTES) != -1) {\n                keepAlive = false;\n            } else if (findBytes(connectionValueBC,\n                                 Constants.KEEPALIVE_BYTES) != -1) {\n                keepAlive = true;\n            }\n        }\n\n        if (http11) {\n            MessageBytes expectMB = headers.getValue(\"expect\");\n            if (expectMB != null) {\n                if (expectMB.indexOfIgnoreCase(\"100-continue\", 0) != -1) {\n                    inputBuffer.setSwallowInput(false);\n                    request.setExpectation(true);\n                } else {\n                    response.setStatus(HttpServletResponse.SC_EXPECTATION_FAILED);\n                    setErrorState(ErrorState.CLOSE_CLEAN, null);\n                }\n            }\n        }\n\n        // Check user-agent header\n        Pattern restrictedUserAgents = protocol.getRestrictedUserAgentsPattern();\n        if (restrictedUserAgents != null && (http11 || keepAlive)) {\n            MessageBytes userAgentValueMB = headers.getValue(\"user-agent\");\n            // Check in the restricted list, and adjust the http11\n            // and keepAlive flags accordingly\n            if(userAgentValueMB != null) {\n                String userAgentValue = userAgentValueMB.toString();\n                if (restrictedUserAgents.matcher(userAgentValue).matches()) {\n                    http11 = false;\n                    keepAlive = false;\n                }\n            }\n        }\n\n        // Check for a full URI (including protocol://host:port/)\n        ByteChunk uriBC = request.requestURI().getByteChunk();\n        if (uriBC.startsWithIgnoreCase(\"http\", 0)) {\n\n            int pos = uriBC.indexOf(\"://\", 0, 3, 4);\n            int uriBCStart = uriBC.getStart();\n            int slashPos = -1;\n            if (pos != -1) {\n                byte[] uriB = uriBC.getBytes();\n                slashPos = uriBC.indexOf('/', pos + 3);\n                if (slashPos == -1) {\n                    slashPos = uriBC.getLength();\n                    // Set URI as \"/\"\n                    request.requestURI().setBytes\n                        (uriB, uriBCStart + pos + 1, 1);\n                } else {\n                    request.requestURI().setBytes\n                        (uriB, uriBCStart + slashPos,\n                         uriBC.getLength() - slashPos);\n                }\n                MessageBytes hostMB = headers.setValue(\"host\");\n                hostMB.setBytes(uriB, uriBCStart + pos + 3,\n                                slashPos - pos - 3);\n            }\n        }\n\n        // Input filter setup\n        InputFilter[] inputFilters = inputBuffer.getFilters();\n\n        // Parse transfer-encoding header\n        if (http11) {\n            MessageBytes transferEncodingValueMB = headers.getValue(\"transfer-encoding\");\n            if (transferEncodingValueMB != null) {\n                String transferEncodingValue = transferEncodingValueMB.toString();\n                // Parse the comma separated list. \"identity\" codings are ignored\n                int startPos = 0;\n                int commaPos = transferEncodingValue.indexOf(',');\n                String encodingName = null;\n                while (commaPos != -1) {\n                    encodingName = transferEncodingValue.substring(startPos, commaPos);\n                    addInputFilter(inputFilters, encodingName);\n                    startPos = commaPos + 1;\n                    commaPos = transferEncodingValue.indexOf(',', startPos);\n                }\n                encodingName = transferEncodingValue.substring(startPos);\n                addInputFilter(inputFilters, encodingName);\n            }\n        }\n\n        // Parse content-length header\n        long contentLength = request.getContentLengthLong();\n        if (contentLength >= 0) {\n            if (contentDelimitation) {\n                // contentDelimitation being true at this point indicates that\n                // chunked encoding is being used but chunked encoding should\n                // not be used with a content length. RFC 2616, section 4.4,\n                // bullet 3 states Content-Length must be ignored in this case -\n                // so remove it.\n                headers.removeHeader(\"content-length\");\n                request.setContentLength(-1);\n            } else {\n                inputBuffer.addActiveFilter\n                        (inputFilters[Constants.IDENTITY_FILTER]);\n                contentDelimitation = true;\n            }\n        }\n\n        MessageBytes valueMB = headers.getValue(\"host\");\n\n        // Check host header\n        if (http11 && (valueMB == null)) {\n            // 400 - Bad request\n            response.setStatus(400);\n            setErrorState(ErrorState.CLOSE_CLEAN, null);\n            if (log.isDebugEnabled()) {\n                log.debug(sm.getString(\"http11processor.request.prepare\")+\n                          \" host header missing\");\n            }\n        }\n\n        parseHost(valueMB);\n\n        if (!contentDelimitation) {\n            // If there's no content length\n            // (broken HTTP/1.0 or HTTP/1.1), assume\n            // the client is not broken and didn't send a body\n            inputBuffer.addActiveFilter\n                    (inputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n        }\n\n        if (getErrorState().isError()) {\n            getAdapter().log(request, response, 0);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean prepareSendfile(OutputFilter[] outputFilters) {\n        String fileName = (String) request.getAttribute(\n                org.apache.coyote.Constants.SENDFILE_FILENAME_ATTR);\n        if (fileName != null) {\n            // No entity body sent here\n            outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n            long pos = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();\n            long end = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue();\n            sendfileData = socketWrapper.createSendfileData(fileName, pos, end - pos);\n            return true;\n        }\n        return false;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void prepareSendfile(OutputFilter[] outputFilters) {\n        String fileName = (String) request.getAttribute(\n                org.apache.coyote.Constants.SENDFILE_FILENAME_ATTR);\n        if (fileName == null) {\n            sendfileData = null;\n        } else {\n            // No entity body sent here\n            outputBuffer.addActiveFilter(outputFilters[Constants.VOID_FILTER]);\n            contentDelimitation = true;\n            long pos = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue();\n            long end = ((Long) request.getAttribute(\n                    org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue();\n            sendfileData = socketWrapper.createSendfileData(fileName, pos, end - pos);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Http11AprProcessor createProcessor() {\n            Http11AprProcessor processor = new Http11AprProcessor(\n                    proto.getMaxHttpHeaderSize(), (AprEndpoint)proto.endpoint,\n                    proto.getMaxTrailerSize());\n            processor.setAdapter(proto.getAdapter());\n            processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\n            processor.setConnectionUploadTimeout(\n                    proto.getConnectionUploadTimeout());\n            processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());\n            processor.setCompressionMinSize(proto.getCompressionMinSize());\n            processor.setCompression(proto.getCompression());\n            processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());\n            processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());\n            processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());\n            processor.setSocketBuffer(proto.getSocketBuffer());\n            processor.setMaxSavePostSize(proto.getMaxSavePostSize());\n            processor.setServer(proto.getServer());\n            processor.setClientCertProvider(proto.getClientCertProvider());\n            register(processor);\n            return processor;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Http11AprProcessor createProcessor() {\n            Http11AprProcessor processor = new Http11AprProcessor(\n                    proto.getMaxHttpHeaderSize(), (AprEndpoint)proto.endpoint,\n                    proto.getMaxTrailerSize(), proto.getMaxExtensionSize());\n            processor.setAdapter(proto.getAdapter());\n            processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\n            processor.setConnectionUploadTimeout(\n                    proto.getConnectionUploadTimeout());\n            processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());\n            processor.setCompressionMinSize(proto.getCompressionMinSize());\n            processor.setCompression(proto.getCompression());\n            processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());\n            processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());\n            processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());\n            processor.setSocketBuffer(proto.getSocketBuffer());\n            processor.setMaxSavePostSize(proto.getMaxSavePostSize());\n            processor.setServer(proto.getServer());\n            processor.setClientCertProvider(proto.getClientCertProvider());\n            register(processor);\n            return processor;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Http11AprProcessor(int headerBufferSize, AprEndpoint endpoint,\n            int maxTrailerSize) {\n\n        super(endpoint);\n\n        inputBuffer = new InternalAprInputBuffer(request, headerBufferSize);\n        request.setInputBuffer(inputBuffer);\n\n        outputBuffer = new InternalAprOutputBuffer(response, headerBufferSize);\n        response.setOutputBuffer(outputBuffer);\n\n        initializeFilters(maxTrailerSize);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Http11AprProcessor(int headerBufferSize, AprEndpoint endpoint,\n            int maxTrailerSize, int maxExtensionSize) {\n\n        super(endpoint);\n\n        inputBuffer = new InternalAprInputBuffer(request, headerBufferSize);\n        request.setInputBuffer(inputBuffer);\n\n        outputBuffer = new InternalAprOutputBuffer(response, headerBufferSize);\n        response.setOutputBuffer(outputBuffer);\n\n        initializeFilters(maxTrailerSize, maxExtensionSize);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Http11Processor createProcessor() {\n            Http11Processor processor = new Http11Processor(\n                    proto.getMaxHttpHeaderSize(), (JIoEndpoint)proto.endpoint,\n                    proto.getMaxTrailerSize());\n            processor.setAdapter(proto.getAdapter());\n            processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\n            processor.setConnectionUploadTimeout(\n                    proto.getConnectionUploadTimeout());\n            processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());\n            processor.setCompressionMinSize(proto.getCompressionMinSize());\n            processor.setCompression(proto.getCompression());\n            processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());\n            processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());\n            processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());\n            processor.setSocketBuffer(proto.getSocketBuffer());\n            processor.setMaxSavePostSize(proto.getMaxSavePostSize());\n            processor.setServer(proto.getServer());\n            processor.setDisableKeepAlivePercentage(\n                    proto.getDisableKeepAlivePercentage());\n            register(processor);\n            return processor;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Http11Processor createProcessor() {\n            Http11Processor processor = new Http11Processor(\n                    proto.getMaxHttpHeaderSize(), (JIoEndpoint)proto.endpoint,\n                    proto.getMaxTrailerSize(),proto.getMaxExtensionSize());\n            processor.setAdapter(proto.getAdapter());\n            processor.setMaxKeepAliveRequests(proto.getMaxKeepAliveRequests());\n            processor.setKeepAliveTimeout(proto.getKeepAliveTimeout());\n            processor.setConnectionUploadTimeout(\n                    proto.getConnectionUploadTimeout());\n            processor.setDisableUploadTimeout(proto.getDisableUploadTimeout());\n            processor.setCompressionMinSize(proto.getCompressionMinSize());\n            processor.setCompression(proto.getCompression());\n            processor.setNoCompressionUserAgents(proto.getNoCompressionUserAgents());\n            processor.setCompressableMimeTypes(proto.getCompressableMimeTypes());\n            processor.setRestrictedUserAgents(proto.getRestrictedUserAgents());\n            processor.setSocketBuffer(proto.getSocketBuffer());\n            processor.setMaxSavePostSize(proto.getMaxSavePostSize());\n            processor.setServer(proto.getServer());\n            processor.setDisableKeepAlivePercentage(\n                    proto.getDisableKeepAlivePercentage());\n            register(processor);\n            return processor;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void initializeFilters() {\n        // Create and add the identity filters.\n        getInputBuffer().addFilter(new IdentityInputFilter());\n        getOutputBuffer().addFilter(new IdentityOutputFilter());\n\n        // Create and add the chunked filters.\n        getInputBuffer().addFilter(new ChunkedInputFilter());\n        getOutputBuffer().addFilter(new ChunkedOutputFilter());\n\n        // Create and add the void filters.\n        getInputBuffer().addFilter(new VoidInputFilter());\n        getOutputBuffer().addFilter(new VoidOutputFilter());\n\n        // Create and add buffered input filter\n        getInputBuffer().addFilter(new BufferedInputFilter());\n\n        // Create and add the chunked filters.\n        //getInputBuffer().addFilter(new GzipInputFilter());\n        getOutputBuffer().addFilter(new GzipOutputFilter());\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void initializeFilters() {\n        // Create and add the identity filters.\n        getInputBuffer().addFilter(new IdentityInputFilter());\n        getOutputBuffer().addFilter(new IdentityOutputFilter());\n\n        // Create and add the chunked filters.\n        getInputBuffer().addFilter(new ChunkedInputFilter());\n        getOutputBuffer().addFilter(new ChunkedOutputFilter());\n\n        // Create and add the void filters.\n        getInputBuffer().addFilter(new VoidInputFilter());\n        getOutputBuffer().addFilter(new VoidOutputFilter());\n\n        // Create and add buffered input filter\n        getInputBuffer().addFilter(new BufferedInputFilter());\n\n        // Create and add the chunked filters.\n        //getInputBuffer().addFilter(new GzipInputFilter());\n        getOutputBuffer().addFilter(new GzipOutputFilter());\n        \n        pluggableFilterIndex = getInputBuffer().getFilters().length;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean addInputFilter(InputFilter[] inputFilters,\n                                     String encodingName) {\n        if (encodingName.equals(\"identity\")) {\n            // Skip\n        } else if (encodingName.equals(\"chunked\")) {\n            getInputBuffer().addActiveFilter\n                (inputFilters[Constants.CHUNKED_FILTER]);\n            contentDelimitation = true;\n        } else {\n            for (int i = 2; i < inputFilters.length; i++) {\n                if (inputFilters[i].getEncodingName()\n                    .toString().equals(encodingName)) {\n                    getInputBuffer().addActiveFilter(inputFilters[i]);\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean addInputFilter(InputFilter[] inputFilters,\n                                     String encodingName) {\n        if (encodingName.equals(\"identity\")) {\n            // Skip\n        } else if (encodingName.equals(\"chunked\")) {\n            getInputBuffer().addActiveFilter\n                (inputFilters[Constants.CHUNKED_FILTER]);\n            contentDelimitation = true;\n        } else {\n            for (int i = pluggableFilterIndex; i < inputFilters.length; i++) {\n                if (inputFilters[i].getEncodingName()\n                    .toString().equals(encodingName)) {\n                    getInputBuffer().addActiveFilter(inputFilters[i]);\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void recycle() {\n        remaining = 0;\n        pos = 0;\n        lastValid = 0;\n        endChunk = false;\n        needCRLFParse = false;\n        trailingHeaders.recycle();\n        trailingHeaders.setLimit(maxTrailerSize);\n        extensionSize = 0;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void recycle() {\n        remaining = 0;\n        pos = 0;\n        lastValid = 0;\n        endChunk = false;\n        needCRLFParse = false;\n        trailingHeaders.recycle();\n        trailingHeaders.setLimit(maxTrailerSize);\n        extensionSize = 0;\n        error = false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "needed\n            if (pos >= lastValid) {\n                if (readBytes() <0)\n                    throw new EOFException(\"Unexpected end of stream whilst reading trailer headers for chunked request\");\n            }",
    "is_vulnerable": true
  },
  {
    "function_code": "needed\n            if (pos >= lastValid) {\n                if (readBytes() <0) {\n                    throwEOFException(sm.getString(\"chunkedInputFilter.eosTrailer\"));\n                }\n            }",
    "is_vulnerable": false
  },
  {
    "function_code": "line\n            while (!eol) {\n\n                // Read new bytes if needed\n                if (pos >= lastValid) {\n                    if (readBytes() <0)\n                        throw new EOFException(\"Unexpected end of stream whilst reading trailer headers for chunked request\");\n                }\n\n                chr = buf[pos];\n                if (chr == Constants.CR || chr == Constants.LF) {\n                    parseCRLF(true);\n                    eol = true;\n                } else if (chr == Constants.SP) {\n                    trailingHeaders.append(chr);\n                } else {\n                    trailingHeaders.append(chr);\n                    lastSignificantChar = trailingHeaders.getEnd();\n                }\n\n                if (!eol) {\n                    pos++;\n                }\n            }",
    "is_vulnerable": true
  },
  {
    "function_code": "line\n            while (!eol) {\n\n                // Read new bytes if needed\n                if (pos >= lastValid) {\n                    if (readBytes() <0) {\n                        throwEOFException(sm.getString(\"chunkedInputFilter.eosTrailer\"));\n                    }\n                }\n\n                chr = buf[pos];\n                if (chr == Constants.CR || chr == Constants.LF) {\n                    parseCRLF(true);\n                    eol = true;\n                } else if (chr == Constants.SP) {\n                    trailingHeaders.append(chr);\n                } else {\n                    trailingHeaders.append(chr);\n                    lastSignificantChar = trailingHeaders.getEnd();\n                }\n\n                if (!eol) {\n                    pos++;\n                }\n            }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void recycle() {\n        if (buffered.getBuffer().length > 65536) {\n            buffered = null;\n        } else {\n            buffered.recycle();\n        }\n        tempRead.recycle();\n        hasRead = false;\n        buffer = null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void recycle() {\n        if (buffered != null) {\n            if (buffered.getBuffer().length > 65536) {\n                buffered = null;\n            } else {\n                buffered.recycle();\n            }\n        }\n        tempRead.recycle();\n        hasRead = false;\n        buffer = null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                if (inIndexLimit - inIndex < 1 + tail) {\n                    // Apache Tomcat added test - detects invalid sequence as\n                    // early as possible\n                    if (jchar == 0x74 && inIndexLimit > inIndex + 1) {\n                        if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {\n                            return CoderResult.unmappableForLength(4);\n                        }\n                    }\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ? CoderResult.OVERFLOW\n                : CoderResult.UNDERFLOW;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                if (inIndexLimit - inIndex < 1 + tail) {\n                    // Apache Tomcat added tests - detect invalid sequences as\n                    // early as possible\n                    if (jchar == 0x74 && inIndexLimit > inIndex + 1) {\n                        if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {\n                            // 11110100 1yyyxxxx xxxxxxxx xxxxxxxx\n                            // Any non-zero y is > max code point\n                            return CoderResult.unmappableForLength(4);\n                        }\n                    }\n                    if (jchar == 0x60 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) == 0) {\n                            // 11100000 10000000 10xxxxxx\n                            // should have been\n                            // 00xxxxxx\n                            return CoderResult.malformedForLength(3);\n                        }\n                    }\n                    if (jchar == 0x70 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) < 0x10) {\n                            // 11110000 1000zzzz 1oyyyyyy 1oxxxxxx\n                            // should have been\n                            // 111ozzzz 1oyyyyyy 1oxxxxxx\n                            return CoderResult.malformedForLength(4);\n                        }\n                    }\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ? CoderResult.OVERFLOW\n                : CoderResult.UNDERFLOW;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                if (inIndexLimit - inIndex < 1 + tail) {\n                    // Apache Tomcat added test - detects invalid sequence as\n                    // early as possible\n                    if (jchar == 0x74 && inIndexLimit > inIndex + 1) {\n                        if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {\n                            return CoderResult.unmappableForLength(4);\n                        }\n                    }\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                if (inIndexLimit - inIndex < 1 + tail) {\n                    // Apache Tomcat added tests - detect invalid sequences as\n                    // early as possible\n                    if (jchar == 0x74 && inIndexLimit > inIndex + 1) {\n                        if ((bArr[inIndex + 1] & 0xFF) > 0x8F) {\n                            // 11110100 1yyyxxxx xxxxxxxx xxxxxxxx\n                            // Any non-zero y is > max code point\n                            return CoderResult.unmappableForLength(4);\n                        }\n                    }\n                    if (jchar == 0x60 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) == 0) {\n                            // 11100000 10000000 10xxxxxx\n                            // should have been\n                            // 00xxxxxx\n                            return CoderResult.malformedForLength(3);\n                        }\n                    }\n                    if (jchar == 0x70 && inIndexLimit > inIndex +1) {\n                        if ((bArr[inIndex + 1] & 0x7F) < 0x10) {\n                            // 11110000 1000zzzz 1oyyyyyy 1oxxxxxx\n                            // should have been\n                            // 111ozzzz 1oyyyyyy 1oxxxxxx\n                            return CoderResult.malformedForLength(4);\n                        }\n                    }\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public UDecoder() \n    {\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public UDecoder() \n    {\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void doJvmDecoder(byte[] src, boolean errorExpected,\n            int failPosExpected) {\n        CharsetDecoder decoder = B2CConverter.UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n\n\n        ByteBuffer bb = ByteBuffer.allocate(src.length);\n        CharBuffer cb = CharBuffer.allocate(bb.limit());\n\n        boolean error = false;\n        int i = 0;\n        for (; i < src.length; i++) {\n            bb.put(src[i]);\n            bb.flip();\n            CoderResult cr = decoder.decode(bb, cb, false);\n            if (cr.isError()) {\n                error = true;\n                break;\n            }\n            bb.compact();\n        }\n\n        assertEquals(Boolean.valueOf(errorExpected), Boolean.valueOf(error));\n        assertEquals(failPosExpected, i);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void doJvmDecoder(byte[] src, boolean errorExpected,\n            int failPosExpected) {\n        CharsetDecoder decoder = B2CConverter.UTF_8.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n\n\n        ByteBuffer bb = ByteBuffer.allocate(src.length);\n        CharBuffer cb = CharBuffer.allocate(bb.limit());\n\n        boolean error = false;\n        int i = 0;\n        for (; i < src.length; i++) {\n            bb.put(src[i]);\n            bb.flip();\n            CoderResult cr = decoder.decode(bb, cb, false);\n            if (cr.isError()) {\n                error = true;\n                break;\n            }\n            bb.compact();\n        }\n\n        StringBuilder ashex = new StringBuilder(src.length * 4);\n        for (int j = 0; j < src.length; j++) {\n            if (i > 0) ashex.append(' ');\n            ashex.append(Integer.toBinaryString(src[j] & 0xff));\n        }\n\n        assertEquals(ashex.toString(),\n                Boolean.valueOf(errorExpected), Boolean.valueOf(error));\n        if (failPosExpected != -1) {\n            assertEquals(failPosExpected, i);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void doHarmonyDecoder(byte[] src, boolean errorExpected,\n            int failPosExpected) {\n        CharsetDecoder decoder = new Utf8Decoder();\n\n        ByteBuffer bb = ByteBuffer.allocate(src.length);\n        CharBuffer cb = CharBuffer.allocate(bb.limit());\n\n        boolean error = false;\n        int i = 0;\n        for (; i < src.length; i++) {\n            bb.put(src[i]);\n            bb.flip();\n            CoderResult cr = decoder.decode(bb, cb, false);\n            if (cr.isError()) {\n                error = true;\n                break;\n            }\n            bb.compact();\n        }\n\n        assertEquals(Boolean.valueOf(errorExpected), Boolean.valueOf(error));\n        assertEquals(failPosExpected, i);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void doHarmonyDecoder(byte[] src, boolean errorExpected,\n            int failPosExpected) {\n        CharsetDecoder decoder = new Utf8Decoder();\n\n        ByteBuffer bb = ByteBuffer.allocate(src.length);\n        CharBuffer cb = CharBuffer.allocate(bb.limit());\n\n        boolean error = false;\n        int i = 0;\n        for (; i < src.length; i++) {\n            bb.put(src[i]);\n            bb.flip();\n            CoderResult cr = decoder.decode(bb, cb, false);\n            if (cr.isError()) {\n                error = true;\n                break;\n            }\n            bb.compact();\n        }\n\n        StringBuilder ashex = new StringBuilder(src.length * 4);\n        for (int j = 0; j < src.length; j++) {\n            if (i > 0) ashex.append(' ');\n            ashex.append(Integer.toBinaryString(src[j] & 0xff));\n        }\n\n        assertEquals(ashex.toString(),\n                Boolean.valueOf(errorExpected), Boolean.valueOf(error));\n        if (failPosExpected != -1) {\n            assertEquals(failPosExpected, i);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, final EnvVars env,\n        final Set<InternetAddress> to, final Set<InternetAddress> cc, final Set<InternetAddress> bcc) {\n\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n\n        Set<User> users = null;\n\n        final Run<?, ?> currentRun = context.getRun();\n        if (currentRun == null) {\n            debug.send(\"currentRun was null\");\n        } else {\n            final AbstractTestResultAction<?> testResultAction = currentRun.getAction(AbstractTestResultAction.class);\n            if (testResultAction == null) {\n                debug.send(\"testResultAction was null\");\n            } else {\n                if (testResultAction.getFailCount() <= 0) {\n                    debug.send(\"getFailCount() returned <= 0\");\n                } else {\n                    users = new HashSet<>();\n                    debug.send(\"Collecting builds where a test started failing...\");\n                    final HashSet<Run<?, ?>> buildsWhereATestStartedFailing = new HashSet<>();\n                    for (final TestResult caseResult : testResultAction.getFailedTests()) {\n                        final Run<?, ?> runWhereTestStartedFailing = caseResult.getFailedSinceRun();\n                        if (runWhereTestStartedFailing != null) {\n                            debug.send(\"  runWhereTestStartedFailing: %d\", runWhereTestStartedFailing.getNumber());\n                            buildsWhereATestStartedFailing.add(runWhereTestStartedFailing);\n                        } else {\n                            context.getListener().error(\"getFailedSinceRun returned null for %s\", caseResult.getFullDisplayName());\n                        }\n                    }\n                    // For each build where a test started failing, walk backward looking for build results worse than\n                    // UNSTABLE. All of those builds will be used to find suspects.\n                    debug.send(\"Collecting builds with suspects...\");\n                    final HashSet<Run<?, ?>> buildsWithSuspects = new HashSet<>();\n                    for (final Run<?, ?> buildWhereATestStartedFailing : buildsWhereATestStartedFailing) {\n                        debug.send(\"  buildWhereATestStartedFailing: %d\", buildWhereATestStartedFailing.getNumber());\n                        buildsWithSuspects.add(buildWhereATestStartedFailing);\n                        Run<?, ?> previousBuildToCheck = buildWhereATestStartedFailing.getPreviousCompletedBuild();\n                        if (previousBuildToCheck != null) {\n                            debug.send(\"    previousBuildToCheck: %d\", previousBuildToCheck.getNumber());\n                        }\n                        while (previousBuildToCheck != null) {\n                            if (buildsWithSuspects.contains(previousBuildToCheck)) {\n                                // Short-circuit if the build to check has already been checked.\n                                debug.send(\"      already contained in buildsWithSuspects; stopping search\");\n                                break;\n                            }\n                            final Result previousResult = previousBuildToCheck.getResult();\n                            if (previousResult == null) {\n                                debug.send(\"      previousResult was null\");\n                            } else {\n                                debug.send(\"      previousResult: %s\", previousResult.toString());\n                                if (previousResult.isBetterThan(Result.FAILURE)) {\n                                    debug.send(\"      previousResult was better than FAILURE; stopping search\");\n                                    break;\n                                } else {\n                                    debug.send(\"      previousResult was not better than FAILURE; adding to buildsWithSuspects; continuing search\");\n                                    buildsWithSuspects.add(previousBuildToCheck);\n                                    previousBuildToCheck = previousBuildToCheck.getPreviousCompletedBuild();\n                                    if (previousBuildToCheck != null) {\n                                        debug.send(\"    previousBuildToCheck: %d\", previousBuildToCheck.getNumber());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    debug.send(\"Collecting suspects...\");\n                    users.addAll(RecipientProviderUtilities.getChangeSetAuthors(buildsWithSuspects, debug));\n                    users.addAll(RecipientProviderUtilities.getUsersTriggeringTheBuilds(buildsWithSuspects, debug));\n                }\n            }\n        }\n\n        if (users != null) {\n            RecipientProviderUtilities.addUsers(users, context.getListener(), env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, final EnvVars env,\n        final Set<InternetAddress> to, final Set<InternetAddress> cc, final Set<InternetAddress> bcc) {\n\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n\n        Set<User> users = null;\n\n        final Run<?, ?> currentRun = context.getRun();\n        if (currentRun == null) {\n            debug.send(\"currentRun was null\");\n        } else {\n            final AbstractTestResultAction<?> testResultAction = currentRun.getAction(AbstractTestResultAction.class);\n            if (testResultAction == null) {\n                debug.send(\"testResultAction was null\");\n            } else {\n                if (testResultAction.getFailCount() <= 0) {\n                    debug.send(\"getFailCount() returned <= 0\");\n                } else {\n                    users = new HashSet<>();\n                    debug.send(\"Collecting builds where a test started failing...\");\n                    final HashSet<Run<?, ?>> buildsWhereATestStartedFailing = new HashSet<>();\n                    for (final TestResult caseResult : testResultAction.getFailedTests()) {\n                        final Run<?, ?> runWhereTestStartedFailing = caseResult.getFailedSinceRun();\n                        if (runWhereTestStartedFailing != null) {\n                            debug.send(\"  runWhereTestStartedFailing: %d\", runWhereTestStartedFailing.getNumber());\n                            buildsWhereATestStartedFailing.add(runWhereTestStartedFailing);\n                        } else {\n                            context.getListener().error(\"getFailedSinceRun returned null for %s\", caseResult.getFullDisplayName());\n                        }\n                    }\n                    // For each build where a test started failing, walk backward looking for build results worse than\n                    // UNSTABLE. All of those builds will be used to find suspects.\n                    debug.send(\"Collecting builds with suspects...\");\n                    final HashSet<Run<?, ?>> buildsWithSuspects = new HashSet<>();\n                    for (final Run<?, ?> buildWhereATestStartedFailing : buildsWhereATestStartedFailing) {\n                        debug.send(\"  buildWhereATestStartedFailing: %d\", buildWhereATestStartedFailing.getNumber());\n                        buildsWithSuspects.add(buildWhereATestStartedFailing);\n                        Run<?, ?> previousBuildToCheck = buildWhereATestStartedFailing.getPreviousCompletedBuild();\n                        if (previousBuildToCheck != null) {\n                            debug.send(\"    previousBuildToCheck: %d\", previousBuildToCheck.getNumber());\n                        }\n                        while (previousBuildToCheck != null) {\n                            if (buildsWithSuspects.contains(previousBuildToCheck)) {\n                                // Short-circuit if the build to check has already been checked.\n                                debug.send(\"      already contained in buildsWithSuspects; stopping search\");\n                                break;\n                            }\n                            final Result previousResult = previousBuildToCheck.getResult();\n                            if (previousResult == null) {\n                                debug.send(\"      previousResult was null\");\n                            } else {\n                                debug.send(\"      previousResult: %s\", previousResult.toString());\n                                if (previousResult.isBetterThan(Result.FAILURE)) {\n                                    debug.send(\"      previousResult was better than FAILURE; stopping search\");\n                                    break;\n                                } else {\n                                    debug.send(\"      previousResult was not better than FAILURE; adding to buildsWithSuspects; continuing search\");\n                                    buildsWithSuspects.add(previousBuildToCheck);\n                                    previousBuildToCheck = previousBuildToCheck.getPreviousCompletedBuild();\n                                    if (previousBuildToCheck != null) {\n                                        debug.send(\"    previousBuildToCheck: %d\", previousBuildToCheck.getNumber());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    debug.send(\"Collecting suspects...\");\n                    users.addAll(RecipientProviderUtilities.getChangeSetAuthors(buildsWithSuspects, debug));\n                    users.addAll(RecipientProviderUtilities.getUsersTriggeringTheBuilds(buildsWithSuspects, debug));\n                }\n            }\n        }\n\n        if (users != null) {\n            RecipientProviderUtilities.addUsers(users, context, env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        debug.send(\"Sending email to upstream committer(s).\");\n        Run<?, ?> cur;\n        Cause.UpstreamCause upc = context.getRun().getCause(Cause.UpstreamCause.class);\n        while (upc != null) {\n            Job<?, ?> p = (Job<?, ?>) Jenkins.getActiveInstance().getItemByFullName(upc.getUpstreamProject());\n            if(p == null) {\n                context.getListener().getLogger().print(\"There is a break in the project linkage, could not retrieve upstream project information\");\n                break;\n            }\n            cur = p.getBuildByNumber(upc.getUpstreamBuild());\n            upc = cur.getCause(Cause.UpstreamCause.class);\n            addUpstreamCommittersTriggeringBuild(cur, to, cc, bcc, env, context.getListener(), debug);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        debug.send(\"Sending email to upstream committer(s).\");\n        Run<?, ?> cur;\n        Cause.UpstreamCause upc = context.getRun().getCause(Cause.UpstreamCause.class);\n        while (upc != null) {\n            Job<?, ?> p = (Job<?, ?>) Jenkins.getActiveInstance().getItemByFullName(upc.getUpstreamProject());\n            if(p == null) {\n                context.getListener().getLogger().print(\"There is a break in the project linkage, could not retrieve upstream project information\");\n                break;\n            }\n            cur = p.getBuildByNumber(upc.getUpstreamBuild());\n            upc = cur.getCause(Cause.UpstreamCause.class);\n            addUpstreamCommittersTriggeringBuild(cur, to, cc, bcc, env, context, debug);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void addUpstreamCommittersTriggeringBuild(Run<?, ?> build, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc, EnvVars env, TaskListener listener, RecipientProviderUtilities.IDebug debug) {\n        debug.send(\"Adding upstream committer from job %s with build number %s\", build.getParent().getDisplayName(), build.getNumber());\n\n        List<ChangeLogSet<?>> changeSets = new ArrayList<>();\n        if(build instanceof AbstractBuild<?,?>) {\n            AbstractBuild<?,?> b = (AbstractBuild<?,?>)build;\n            changeSets.add(b.getChangeSet());\n        } else {\n            try {\n                // check for getChangeSets which WorkflowRun has\n                Method m = build.getClass().getMethod(\"getChangeSets\");\n                changeSets = (List<ChangeLogSet<? extends ChangeLogSet.Entry>>)m.invoke(build);\n            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n                listener.getLogger().print(\"Could not add upstream committers, build type does not provide change set\");\n            }\n        }\n\n        if(!changeSets.isEmpty()) {\n            for(ChangeLogSet<? extends ChangeLogSet.Entry> changeSet : changeSets) {\n                for(ChangeLogSet.Entry change : changeSet) {\n                    addUserFromChangeSet(change, to, cc, bcc, env, listener, debug);\n                }\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void addUpstreamCommittersTriggeringBuild(Run<?, ?> build, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc, EnvVars env, final ExtendedEmailPublisherContext context, RecipientProviderUtilities.IDebug debug) {\n        debug.send(\"Adding upstream committer from job %s with build number %s\", build.getParent().getDisplayName(), build.getNumber());\n\n        List<ChangeLogSet<?>> changeSets = new ArrayList<>();\n        if(build instanceof AbstractBuild<?,?>) {\n            AbstractBuild<?,?> b = (AbstractBuild<?,?>)build;\n            changeSets.add(b.getChangeSet());\n        } else {\n            try {\n                // check for getChangeSets which WorkflowRun has\n                Method m = build.getClass().getMethod(\"getChangeSets\");\n                changeSets = (List<ChangeLogSet<? extends ChangeLogSet.Entry>>)m.invoke(build);\n            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n                context.getListener().getLogger().print(\"Could not add upstream committers, build type does not provide change set\");\n            }\n        }\n\n        if(!changeSets.isEmpty()) {\n            for(ChangeLogSet<? extends ChangeLogSet.Entry> changeSet : changeSets) {\n                for(ChangeLogSet.Entry change : changeSet) {\n                    addUserFromChangeSet(change, to, cc, bcc, env, context, debug);\n                }\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void addUserFromChangeSet(ChangeLogSet.Entry change, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc, EnvVars env, TaskListener listener, RecipientProviderUtilities.IDebug debug) {\n        User user = change.getAuthor();\n        RecipientProviderUtilities.addUsers(Collections.singleton(user), listener, env, to, cc, bcc, debug);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void addUserFromChangeSet(ChangeLogSet.Entry change, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc, EnvVars env, final ExtendedEmailPublisherContext context, RecipientProviderUtilities.IDebug debug) {\n        User user = change.getAuthor();\n        RecipientProviderUtilities.addUsers(Collections.singleton(user), context, env, to, cc, bcc, debug);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        // looking for Upstream build.\n        Run<?, ?> cur = context.getRun();\n        Cause.UpstreamCause upc = cur.getCause(Cause.UpstreamCause.class);\n        while (upc != null) {\n            // UpstreamCause.getUpStreamProject() returns the full name, so use getItemByFullName\n            Job<?, ?> p = (Job<?, ?>) Jenkins.getActiveInstance().getItemByFullName(upc.getUpstreamProject());\n            if (p == null) {\n                context.getListener().getLogger().print(\"There is a break in the project linkage, could not retrieve upstream project information\");\n                break;\n            }\n            cur = p.getBuildByNumber(upc.getUpstreamBuild());\n            upc = cur.getCause(Cause.UpstreamCause.class);\n        }\n        addUserTriggeringTheBuild(cur, to, cc, bcc, env, context.getListener(), debug);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        // looking for Upstream build.\n        Run<?, ?> cur = context.getRun();\n        Cause.UpstreamCause upc = cur.getCause(Cause.UpstreamCause.class);\n        while (upc != null) {\n            // UpstreamCause.getUpStreamProject() returns the full name, so use getItemByFullName\n            Job<?, ?> p = (Job<?, ?>) Jenkins.getActiveInstance().getItemByFullName(upc.getUpstreamProject());\n            if (p == null) {\n                context.getListener().getLogger().print(\"There is a break in the project linkage, could not retrieve upstream project information\");\n                break;\n            }\n            cur = p.getBuildByNumber(upc.getUpstreamBuild());\n            upc = cur.getCause(Cause.UpstreamCause.class);\n        }\n        addUserTriggeringTheBuild(cur, to, cc, bcc, env, context, debug);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private static void addUserTriggeringTheBuild(Run<?, ?> run, Set<InternetAddress> to,\n        Set<InternetAddress> cc, Set<InternetAddress> bcc, EnvVars env, TaskListener listener, RecipientProviderUtilities.IDebug debug) {\n\n        final User user = RecipientProviderUtilities.getUserTriggeringTheBuild(run);\n        if (user != null) {\n            RecipientProviderUtilities.addUsers(Collections.singleton(user), listener, env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private static void addUserTriggeringTheBuild(Run<?, ?> run, Set<InternetAddress> to,\n        Set<InternetAddress> cc, Set<InternetAddress> bcc, EnvVars env, final ExtendedEmailPublisherContext context, RecipientProviderUtilities.IDebug debug) {\n\n        final User user = RecipientProviderUtilities.getUserTriggeringTheBuild(run);\n        if (user != null) {\n            RecipientProviderUtilities.addUsers(Collections.singleton(user), context, env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        Set<User> users = RecipientProviderUtilities.getChangeSetAuthors(Collections.<Run<?, ?>>singleton(context.getRun()), debug);\n        RecipientProviderUtilities.addUsers(users, context.getListener(), env, to, cc, bcc, debug);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        Set<User> users = RecipientProviderUtilities.getChangeSetAuthors(Collections.<Run<?, ?>>singleton(context.getRun()), debug);\n        RecipientProviderUtilities.addUsers(users, context, env, to, cc, bcc, debug);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        Run<?,?> run = context.getRun();\n        final Result runResult = run.getResult();\n        if (run instanceof AbstractBuild) {\n            Set<User> users = ((AbstractBuild<?,?>)run).getCulprits();\n            RecipientProviderUtilities.addUsers(users, context.getListener(), env, to, cc, bcc, debug);\n        } else if (runResult != null) {\n            List<Run<?, ?>> builds = new ArrayList<>();\n            Run<?, ?> build = run;\n            builds.add(build);\n            build = build.getPreviousCompletedBuild();\n            while (build != null) {\n                final Result buildResult = build.getResult();\n                if (buildResult != null) {\n                    if (buildResult.isWorseThan(Result.SUCCESS)) {\n                        debug.send(\"Including build %s with status %s\", build.getId(), buildResult);\n                        builds.add(build);\n                    } else {\n                        break;\n                    }\n                }\n                build = build.getPreviousCompletedBuild();\n            }\n            Set<User> users = RecipientProviderUtilities.getChangeSetAuthors(builds, debug);\n            RecipientProviderUtilities.addUsers(users, context.getListener(), env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, EnvVars env, Set<InternetAddress> to, Set<InternetAddress> cc, Set<InternetAddress> bcc) {\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                    = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n        Run<?,?> run = context.getRun();\n        final Result runResult = run.getResult();\n        if (run instanceof AbstractBuild) {\n            Set<User> users = ((AbstractBuild<?,?>)run).getCulprits();\n            RecipientProviderUtilities.addUsers(users, context, env, to, cc, bcc, debug);\n        } else if (runResult != null) {\n            List<Run<?, ?>> builds = new ArrayList<>();\n            Run<?, ?> build = run;\n            builds.add(build);\n            build = build.getPreviousCompletedBuild();\n            while (build != null) {\n                final Result buildResult = build.getResult();\n                if (buildResult != null) {\n                    if (buildResult.isWorseThan(Result.SUCCESS)) {\n                        debug.send(\"Including build %s with status %s\", build.getId(), buildResult);\n                        builds.add(build);\n                    } else {\n                        break;\n                    }\n                }\n                build = build.getPreviousCompletedBuild();\n            }\n            Set<User> users = RecipientProviderUtilities.getChangeSetAuthors(builds, debug);\n            RecipientProviderUtilities.addUsers(users, context, env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "else if (runResult != null) {\n            List<Run<?, ?>> builds = new ArrayList<>();\n            Run<?, ?> build = run;\n            builds.add(build);\n            build = build.getPreviousCompletedBuild();\n            while (build != null) {\n                final Result buildResult = build.getResult();\n                if (buildResult != null) {\n                    if (buildResult.isWorseThan(Result.SUCCESS)) {\n                        debug.send(\"Including build %s with status %s\", build.getId(), buildResult);\n                        builds.add(build);\n                    } else {\n                        break;\n                    }\n                }\n                build = build.getPreviousCompletedBuild();\n            }\n            Set<User> users = RecipientProviderUtilities.getChangeSetAuthors(builds, debug);\n            RecipientProviderUtilities.addUsers(users, context.getListener(), env, to, cc, bcc, debug);\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "else if (runResult != null) {\n            List<Run<?, ?>> builds = new ArrayList<>();\n            Run<?, ?> build = run;\n            builds.add(build);\n            build = build.getPreviousCompletedBuild();\n            while (build != null) {\n                final Result buildResult = build.getResult();\n                if (buildResult != null) {\n                    if (buildResult.isWorseThan(Result.SUCCESS)) {\n                        debug.send(\"Including build %s with status %s\", build.getId(), buildResult);\n                        builds.add(build);\n                    } else {\n                        break;\n                    }\n                }\n                build = build.getPreviousCompletedBuild();\n            }\n            Set<User> users = RecipientProviderUtilities.getChangeSetAuthors(builds, debug);\n            RecipientProviderUtilities.addUsers(users, context, env, to, cc, bcc, debug);\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, final EnvVars env,\n        final Set<InternetAddress> to, final Set<InternetAddress> cc, final Set<InternetAddress> bcc) {\n\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n\n        Set<User> users = null;\n\n        final Run<?, ?> currentRun = context.getRun();\n        if (currentRun == null) {\n            debug.send(\"currentRun was null\");\n        } else {\n            if (!Objects.equals(currentRun.getResult(), Result.FAILURE)) {\n                debug.send(\"currentBuild did not fail\");\n            } else {\n                users = new HashSet<>();\n                debug.send(\"Collecting builds with suspects...\");\n                final HashSet<Run<?, ?>> buildsWithSuspects = new HashSet<>();\n                Run<?, ?> firstFailedBuild = currentRun;\n                Run<?, ?> candidate = currentRun;\n                while (candidate != null) {\n                    final Result candidateResult = candidate.getResult();\n                    if ( candidateResult == null || !candidateResult.isWorseOrEqualTo(Result.FAILURE) ) {\n                        break;\n                    }\n                    firstFailedBuild = candidate;\n                    candidate = candidate.getPreviousCompletedBuild();\n                }\n                if (firstFailedBuild instanceof AbstractBuild) {\n                    buildsWithSuspects.add(firstFailedBuild);\n                } else {\n                    debug.send(\"  firstFailedBuild was not an instance of AbstractBuild\");\n                }\n                debug.send(\"Collecting suspects...\");\n                users.addAll(RecipientProviderUtilities.getChangeSetAuthors(buildsWithSuspects, debug));\n                users.addAll(RecipientProviderUtilities.getUsersTriggeringTheBuilds(buildsWithSuspects, debug));\n            }\n        }\n        if (users != null) {\n            RecipientProviderUtilities.addUsers(users, context.getListener(), env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addRecipients(final ExtendedEmailPublisherContext context, final EnvVars env,\n        final Set<InternetAddress> to, final Set<InternetAddress> cc, final Set<InternetAddress> bcc) {\n\n        final class Debug implements RecipientProviderUtilities.IDebug {\n            private final ExtendedEmailPublisherDescriptor descriptor\n                = Jenkins.getActiveInstance().getDescriptorByType(ExtendedEmailPublisherDescriptor.class);\n\n            private final PrintStream logger = context.getListener().getLogger();\n\n            public void send(final String format, final Object... args) {\n                descriptor.debug(logger, format, args);\n            }\n        }\n        final Debug debug = new Debug();\n\n        Set<User> users = null;\n\n        final Run<?, ?> currentRun = context.getRun();\n        if (currentRun == null) {\n            debug.send(\"currentRun was null\");\n        } else {\n            if (!Objects.equals(currentRun.getResult(), Result.FAILURE)) {\n                debug.send(\"currentBuild did not fail\");\n            } else {\n                users = new HashSet<>();\n                debug.send(\"Collecting builds with suspects...\");\n                final HashSet<Run<?, ?>> buildsWithSuspects = new HashSet<>();\n                Run<?, ?> firstFailedBuild = currentRun;\n                Run<?, ?> candidate = currentRun;\n                while (candidate != null) {\n                    final Result candidateResult = candidate.getResult();\n                    if ( candidateResult == null || !candidateResult.isWorseOrEqualTo(Result.FAILURE) ) {\n                        break;\n                    }\n                    firstFailedBuild = candidate;\n                    candidate = candidate.getPreviousCompletedBuild();\n                }\n                if (firstFailedBuild instanceof AbstractBuild) {\n                    buildsWithSuspects.add(firstFailedBuild);\n                } else {\n                    debug.send(\"  firstFailedBuild was not an instance of AbstractBuild\");\n                }\n                debug.send(\"Collecting suspects...\");\n                users.addAll(RecipientProviderUtilities.getChangeSetAuthors(buildsWithSuspects, debug));\n                users.addAll(RecipientProviderUtilities.getUsersTriggeringTheBuilds(buildsWithSuspects, debug));\n            }\n        }\n        if (users != null) {\n            RecipientProviderUtilities.addUsers(users, context, env, to, cc, bcc, debug);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void addUsers(final Set<User> users, final TaskListener listener, final EnvVars env,\n        final Set<InternetAddress> to, final Set<InternetAddress> cc, final Set<InternetAddress> bcc, final IDebug debug) {\n        for (final User user : users) {\n            if (EmailRecipientUtils.isExcludedRecipient(user, listener)) {\n                debug.send(\"User %s is an excluded recipient.\", user.getFullName());\n            } else {\n                final String userAddress = EmailRecipientUtils.getUserConfiguredEmail(user);\n                if (userAddress != null) {\n                    debug.send(\"Adding %s with address %s\", user.getFullName(), userAddress);\n                    EmailRecipientUtils.addAddressesFromRecipientList(to, cc, bcc, userAddress, env, listener);\n                } else {\n                    listener.getLogger().println(\"Failed to send e-mail to \"\n                        + user.getFullName()\n                        + \" because no e-mail address is known, and no default e-mail domain is configured\");\n                }\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private static void addUsers(final Set<User> users, final TaskListener listener, @CheckForNull Run<?,?> run, final EnvVars env,\n        final Set<InternetAddress> to, final Set<InternetAddress> cc, final Set<InternetAddress> bcc, final IDebug debug) {\n        for (final User user : users) {\n            if (EmailRecipientUtils.isExcludedRecipient(user, listener)) {\n                debug.send(\"User %s is an excluded recipient.\", user.getFullName());\n            } else {\n                final String userAddress = EmailRecipientUtils.getUserConfiguredEmail(user);\n                if (userAddress != null) {\n                    try {\n                        Authentication auth = user.impersonate();\n                        if (run != null && !run.getACL().hasPermission(auth, Item.READ)) {\n                            if (SEND_TO_USERS_WITHOUT_READ) {\n                                listener.getLogger().printf(\"Warning: user %s has no permission to view %s, but sending mail anyway%n\", userAddress, run.getFullDisplayName());\n                            } else {\n                                listener.getLogger().printf(\"Not sending mail to user %s with no permission to view %s\", userAddress, run.getFullDisplayName());\n                                continue;\n                            }\n                        }\n                    } catch (UsernameNotFoundException x) {\n                        if (SEND_TO_UNKNOWN_USERS) {\n                            listener.getLogger().printf(\"Warning: %s is not a recognized user, but sending mail anyway%n\", userAddress);\n                        } else {\n                            listener.getLogger().printf(\"Not sending mail to unregistered user %s%n\", userAddress);\n                            continue;\n                        }\n                    }\n                    debug.send(\"Adding %s with address %s\", user.getFullName(), userAddress);\n                    EmailRecipientUtils.addAddressesFromRecipientList(to, cc, bcc, userAddress, env, listener);\n                } else {\n                    listener.getLogger().println(\"Failed to send e-mail to \"\n                        + user.getFullName()\n                        + \" because no e-mail address is known, and no default e-mail domain is configured\");\n                }\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void testTrustedMethodPrevention() {\n            Response response = WebClient.create(endPoint + TIKA_PATH)\n                    .type(\"application/pdf\")\n                    .accept(\"text/plain\")\n                    .header(TikaResource.X_TIKA_OCR_HEADER_PREFIX +\n                                    \"trustedPageSeparator\",\n                            \"\\u0010\")\n                    .put(ClassLoader.getSystemResourceAsStream(\"testOCR.pdf\"));\n            assertEquals(500, response.getStatus());\n\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void testTrustedMethodPrevention() {\n        Response response = WebClient.create(endPoint + TIKA_PATH)\n                .type(\"application/pdf\")\n                .accept(\"text/plain\")\n                .header(TikaResource.X_TIKA_OCR_HEADER_PREFIX +\n                                \"trustedPageSeparator\",\n                        \"\\u0010\")\n                .put(ClassLoader.getSystemResourceAsStream(\"testOCR.pdf\"));\n        assertEquals(500, response.getStatus());\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n\n        try {\n            String property = StringUtils.removeStart(key, prefix);\n            Field field = null;\n            try {\n                object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n            } catch (NoSuchFieldException e) {\n                //swallow\n            }\n            String setter = property;\n            setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n            //default assume string class\n            //if there's a more specific type, e.g. double, int, boolean\n            //try that.\n            Class clazz = String.class;\n            if (field != null) {\n                if (field.getType() == int.class) {\n                    clazz = int.class;\n                } else if (field.getType() == double.class) {\n                    clazz = double.class;\n                } else if (field.getType() == boolean.class) {\n                    clazz = boolean.class;\n                }\n            }\n\n            Method m = tryToGetMethod(object, setter, clazz);\n            //if you couldn't find more specific setter, back off\n            //to string setter and try that.\n            if (m == null && clazz != String.class) {\n                m = tryToGetMethod(object, setter, String.class);\n            }\n\n            if (m != null) {\n                String val = httpHeaders.getFirst(key);\n                val = val.trim();\n                if (clazz == String.class) {\n                    checkTrustWorthy(setter, val);\n                    m.invoke(object, val);\n                } else if (clazz == int.class) {\n                    m.invoke(object, Integer.parseInt(val));\n                } else if (clazz == double.class) {\n                    m.invoke(object, Double.parseDouble(val));\n                } else if (clazz == boolean.class) {\n                    m.invoke(object, Boolean.parseBoolean(val));\n                } else {\n                    throw new IllegalArgumentException(\"setter must be String, int, double or boolean...for now\");\n                }\n            } else {\n                throw new NoSuchMethodException(\"Couldn't find: \"+setter);\n            }\n\n        } catch (Throwable ex) {\n            throw new WebApplicationException(String.format(Locale.ROOT,\n                    \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private static void processHeaderConfig(MultivaluedMap<String, String> httpHeaders, Object object, String key, String prefix) {\n\n        try {String property = StringUtils.removeStart(key, prefix);\n            Field field = null;\n            try {\n                field = object.getClass().getDeclaredField(StringUtils.uncapitalize(property));\n            } catch (NoSuchFieldException e) {\n                //swallow\n            }\n            String setter = property;\n            setter = \"set\"+setter.substring(0,1).toUpperCase(Locale.US)+setter.substring(1);\n            //default assume string class\n            //if there's a more specific type, e.g. double, int, boolean\n            //try that.\n            Class clazz = String.class;\n            if (field != null) {\n                if (field.getType() == int.class || field.getType() == Integer.class) {\n                    clazz = int.class;\n                } else if (field.getType() == double.class) {\n                    clazz = double.class;\n                } else if (field.getType() == Double.class) {\n                    clazz = Double.class;\n                } else if (field.getType() == float.class) {\n                    clazz = float.class;\n                } else if (field.getType() == Float.class) {\n                    clazz = Float.class;\n                } else if (field.getType() == boolean.class) {\n                    clazz = boolean.class;\n                } else if (field.getType() == Boolean.class) {\n                    clazz = Boolean.class;\n                }\n            }\n\n            Method m = tryToGetMethod(object, setter, clazz);\n            //if you couldn't find more specific setter, back off\n            //to string setter and try that.\n            if (m == null && clazz != String.class) {\n                m = tryToGetMethod(object, setter, String.class);\n            }\n\n            if (m != null) {\n                String val = httpHeaders.getFirst(key);\n                val = val.trim();\n                if (clazz == String.class) {\n                    checkTrustWorthy(setter, val);\n                    m.invoke(object, val);\n                } else if (clazz == int.class || clazz == Integer.class) {\n                    m.invoke(object, Integer.parseInt(val));\n                } else if (clazz == double.class || clazz == Double.class) {\n                    m.invoke(object, Double.parseDouble(val));\n                } else if (clazz == boolean.class || clazz == Boolean.class) {\n                    m.invoke(object, Boolean.parseBoolean(val));\n                } else if (clazz == float.class || clazz == Float.class) {\n                    m.invoke(object, Float.parseFloat(val));\n                } else {\n                    throw new IllegalArgumentException(\"setter must be String, int, float, double or boolean...for now\");\n                }\n            } else {\n                throw new NoSuchMethodException(\"Couldn't find: \"+setter);\n            }\n\n        } catch (Throwable ex) {\n            throw new WebApplicationException(String.format(Locale.ROOT,\n                    \"%s is an invalid %s header\", key, X_TIKA_OCR_HEADER_PREFIX));\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void testBogusPathCheck() {\n        TesseractOCRConfig config = new TesseractOCRConfig();\n        config.setTesseractPath(\"blahdeblahblah\");\n        assertEquals(\"blahdeblahblah\", config.getTesseractPath());\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void testBogusPathCheck() {\n        //allow path that doesn't actually exist\n        TesseractOCRConfig config = new TesseractOCRConfig();\n        config.setTesseractPath(\"blahdeblahblah\");\n        assertEquals(\"blahdeblahblah\", config.getTesseractPath());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "lines\n            if (read > value.length) { break; }",
    "is_vulnerable": true
  },
  {
    "function_code": "lines\n            if (read >= value.length) { break; }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean parseBody(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String bdy_heading = \"\";\n      String bdy_title = \"\";\n      String bdy_source = \"\";\n      String bdy_author = \"\";\n      String bdy_body = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the body, getting the heading (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c) and not EOL\n                  bdy_heading += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               while (bdy_heading.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for reuters, the heading does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        // if the very first byte is data, we have to shift the whole array, and stuff in a carat\n                        if (read == 1) {\n                           byte[] resize = new byte[value.length + 1];\n                           System.arraycopy(value, 0, resize, 1, value.length);\n                           value = resize;\n                        }\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c), or carat (\\x5e) and not EOL\n                  bdy_title += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while (bdy_title.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for bloomberg, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_BLM) {\n                  if (val_next == TB) {\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n\n               // for reuters, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        --read;\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n\n         // at this point, we have a variable number of metadata lines, with various orders\n         // we scan the start of each line for the special character, and run to the end character\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         boolean metastarted = false;\n         String longline = \"\";\n         String longkey = \"\";\n         while (read < value.length) {\n            byte val_next = value[read++];\n\n            // eat up whitespace before committing to the next section\n            if ((val_next == SP) || (val_next == TB) || (val_next == CR) || (val_next == LF)) {\n               continue;\n            }\n\n            if (val_next == CT) {      //  start of a new section , could be authors, sources, etc\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               String tmp_line = \"\";\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {\n                  // less than delimiter (\\x3c), maybe also badly formed with just new line\n                  tmp_line += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while ((val_next == CR) || (val_next == LF)) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n               if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"by\") || longline.equals(\"bdy_author\")) {\n                  longkey = \"bdy_author\";\n\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have an author candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_author += tmp_line.substring(tmp_line.indexOf(\" \"), term);\n                  metastarted = true;\n                  longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n               }\n               else if (FORMAT == this.FMT_IPTC_BLM) {\n                  String byline = \"   by \";\n                  if (tmp_line.toLowerCase(Locale.ROOT).contains(byline)) {\n                     longkey = \"bdy_author\";\n\n                     int term = tmp_line.length();\n                     term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                     term = (term > 0 ) ? term : tmp_line.length();\n                     // for bloomberg, the author line sits below their copyright statement\n                     bdy_author += tmp_line.substring(tmp_line.toLowerCase(Locale.ROOT).indexOf(byline) + byline.length(), term) + \" \";\n                     metastarted = true;\n                     longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).startsWith(\"c.\")) {\n                     // the author line for bloomberg is a multiline starting with c.2011 Bloomberg News\n                     // then containing the author info on the next line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).trim().startsWith(\"(\") && tmp_line.toLowerCase(Locale.ROOT).trim().endsWith(\")\")) {\n                     // the author line may have one or more comment lines between the copyright\n                     // statement, and the By AUTHORNAME line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n               }\n\n               else if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"eds\") || longline.equals(\"bdy_source\")) {\n                  longkey = \"bdy_source\";\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have a source candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n//                  term = Math.min(term, (tmp_line.indexOf(\"\\n\") > -1 ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_source += tmp_line.substring(tmp_line.indexOf(\" \") + 1, term) + \" \";\n                  metastarted = true;\n                  longline = (!longline.equals(longkey) ? longkey  : \"\");\n               }\n               else {\n                  // this has fallen all the way through.  trap it as part of the subject,\n                  // rather than just losing it\n                  if (!metastarted) {\n                     bdy_title += \" , \" + tmp_line;     //  not sure where else to put this but in the title\n                  }\n                  else {\n                     // what to do with stuff that is metadata, which falls after metadata lines started?\n                     bdy_body += \" \" + tmp_line + \" , \";     //  not sure where else to put this but in the title\n                  }\n               }\n            }\n            else {  // we're on to the main body\n               while ((read < value.length) && (val_next != 0))  {\n                  // read until the train runs out of tracks\n                  bdy_body += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n            }\n            // we would normally break here, but just let this read out to the end\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n      properties.put(\"body\", bdy_body);\n      properties.put(\"title\", bdy_title);\n      properties.put(\"subject\", bdy_heading);\n      properties.put(\"author\", bdy_author);\n      properties.put(\"source\", bdy_source);\n\n      added = (bdy_body.length() + bdy_title.length() + bdy_heading.length() + bdy_author.length() +\n               bdy_source.length()) > 0;\n      return added;\n   }",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean parseBody(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String bdy_heading = \"\";\n      String bdy_title = \"\";\n      String bdy_source = \"\";\n      String bdy_author = \"\";\n      String bdy_body = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the body, getting the heading (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c) and not EOL\n                  bdy_heading += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               while (bdy_heading.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for reuters, the heading does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        // if the very first byte is data, we have to shift the whole array, and stuff in a carat\n                        if (read == 1) {\n                           byte[] resize = new byte[value.length + 1];\n                           System.arraycopy(value, 0, resize, 1, value.length);\n                           value = resize;\n                        }\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      //  start of a new section , first is the heading\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               // AP, NYT, and Bloomberg end with < , Reuters with EOL\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF)) {   // less than delimiter (\\x3c), or carat (\\x5e) and not EOL\n                  bdy_title += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while (bdy_title.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               // this will only be hit on poorly-formed files\n\n               // for bloomberg, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_BLM) {\n                  if (val_next == TB) {\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n\n               // for reuters, the title does not start with the ^, so we push one back into the stream\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     // for any non-whitespace, we need to go back an additional step to non destroy the data\n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        --read;\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n\n         // at this point, we have a variable number of metadata lines, with various orders\n         // we scan the start of each line for the special character, and run to the end character\n         // pull apart the body, getting the title (^....\\x0d\\x0a)\n         boolean metastarted = false;\n         String longline = \"\";\n         String longkey = \"\";\n         while (read < value.length) {\n            byte val_next = value[read++];\n\n            // eat up whitespace before committing to the next section\n            if ((val_next == SP) || (val_next == TB) || (val_next == CR) || (val_next == LF)) {\n               continue;\n            }\n\n            if (val_next == CT) {      //  start of a new section , could be authors, sources, etc\n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               String tmp_line = \"\";\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {\n                  // less than delimiter (\\x3c), maybe also badly formed with just new line\n                  tmp_line += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n               if (val_next == CT) {      //  start of a new section , when first didn't finish cleanly\n                   --read;\n               }\n\n               if (val_next == LT) {\n                  // hit the delimiter, carry on\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while ((val_next == CR) || (val_next == LF)) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n               if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"by\") || longline.equals(\"bdy_author\")) {\n                  longkey = \"bdy_author\";\n\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have an author candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_author += tmp_line.substring(tmp_line.indexOf(\" \"), term);\n                  metastarted = true;\n                  longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n               }\n               else if (FORMAT == this.FMT_IPTC_BLM) {\n                  String byline = \"   by \";\n                  if (tmp_line.toLowerCase(Locale.ROOT).contains(byline)) {\n                     longkey = \"bdy_author\";\n\n                     int term = tmp_line.length();\n                     term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                     term = (term > 0 ) ? term : tmp_line.length();\n                     // for bloomberg, the author line sits below their copyright statement\n                     bdy_author += tmp_line.substring(tmp_line.toLowerCase(Locale.ROOT).indexOf(byline) + byline.length(), term) + \" \";\n                     metastarted = true;\n                     longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).startsWith(\"c.\")) {\n                     // the author line for bloomberg is a multiline starting with c.2011 Bloomberg News\n                     // then containing the author info on the next line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).trim().startsWith(\"(\") && tmp_line.toLowerCase(Locale.ROOT).trim().endsWith(\")\")) {\n                     // the author line may have one or more comment lines between the copyright\n                     // statement, and the By AUTHORNAME line\n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n               }\n\n               else if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"eds\") || longline.equals(\"bdy_source\")) {\n                  longkey = \"bdy_source\";\n                  // prepend a space to subsequent line, so it gets parsed consistent with the lead line\n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  // we have a source candidate\n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n//                  term = Math.min(term, (tmp_line.indexOf(\"\\n\") > -1 ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_source += tmp_line.substring(tmp_line.indexOf(\" \") + 1, term) + \" \";\n                  metastarted = true;\n                  longline = (!longline.equals(longkey) ? longkey  : \"\");\n               }\n               else {\n                  // this has fallen all the way through.  trap it as part of the subject,\n                  // rather than just losing it\n                  if (!metastarted) {\n                     bdy_title += \" , \" + tmp_line;     //  not sure where else to put this but in the title\n                  }\n                  else {\n                     // what to do with stuff that is metadata, which falls after metadata lines started?\n                     bdy_body += \" \" + tmp_line + \" , \";     //  not sure where else to put this but in the title\n                  }\n               }\n            }\n            else {  // we're on to the main body\n               while ((read < value.length) && (val_next != 0))  {\n                  // read until the train runs out of tracks\n                  bdy_body += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n               }\n\n            }\n            // we would normally break here, but just let this read out to the end\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n      properties.put(\"body\", bdy_body);\n      properties.put(\"title\", bdy_title);\n      properties.put(\"subject\", bdy_heading);\n      properties.put(\"author\", bdy_author);\n      properties.put(\"source\", bdy_source);\n\n      added = (bdy_body.length() + bdy_title.length() + bdy_heading.length() + bdy_author.length() +\n               bdy_source.length()) > 0;\n      return added;\n   }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean parseFooter(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String ftr_source = \"\";\n      String ftr_datetime = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the footer, getting the news feed source (^....\\x0d\\x0a)\n         byte val_next = value[read++];\n         byte val_peek =  (read < value.length) ? value[read+1] : 0x00;  // skip the new lines\n\n         while (((val_next < (byte)0x30) || (val_next > (byte)0x39)) && (val_next != 0)) {  // consume all non-numerics first\n            ftr_source += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read] : 0x00;  // attempt to read until end of stream\n            read++;\n            if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n\n         while ((val_next != LT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {  // get as much timedate as possible\n            // this is an american format, so arrives as mm-dd-yy HHiizzz\n            ftr_datetime += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if (read > value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n         if (val_next == LT) {\n            // hit the delimiter, carry on\n            val_next =  (read < value.length) ? value[read++] : 0x00;\n         }\n\n         if (ftr_datetime.length() > 0) {\n            // we want to pass this back in a more friendly format\n            String format_out = \"yyyy-MM-dd'T'HH:mm:ss'Z'\";\n            Date dateunix = new Date();\n            try {\n               // standard ap format\n               String format_in = \"MM-dd-yy HHmmzzz\";\n\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  // standard reuters format\n                  format_in = \"HH:mm MM-dd-yy\";\n               }\n               SimpleDateFormat dfi = new SimpleDateFormat(format_in, Locale.ROOT);\n               dfi.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n               dateunix = dfi.parse(ftr_datetime);\n            }\n            catch (ParseException ep) {\n               // failed, but this will just fall through to setting the date to now\n            }\n            SimpleDateFormat dfo = new SimpleDateFormat(format_out, Locale.ROOT);\n            dfo.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n            ftr_datetime = dfo.format(dateunix);\n         }\n         while ((val_next == CR) || (val_next == LF)) {\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if ((val_next != CR) && (val_next != LF)) {\n               --read;\n            }\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n\n      properties.put(\"publisher\", ftr_source);\n      properties.put(\"created\", ftr_datetime);\n      properties.put(\"modified\", ftr_datetime);\n\n      added = (ftr_source.length() + ftr_datetime.length()) > 0; \n      return added;\n   }",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean parseFooter(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String ftr_source = \"\";\n      String ftr_datetime = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         // pull apart the footer, getting the news feed source (^....\\x0d\\x0a)\n         byte val_next = value[read++];\n         byte val_peek =  (read < value.length) ? value[read+1] : 0x00;  // skip the new lines\n\n         while (((val_next < (byte)0x30) || (val_next > (byte)0x39)) && (val_next != 0)) {  // consume all non-numerics first\n            ftr_source += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read] : 0x00;  // attempt to read until end of stream\n            read++;\n            if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n\n         while ((val_next != LT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {  // get as much timedate as possible\n            // this is an american format, so arrives as mm-dd-yy HHiizzz\n            ftr_datetime += (char)(val_next & 0xff);  // convert the byte to an unsigned int\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if (read >= value.length) { break; }  // shouldn't ever hit this, but save a NPE\n         }\n         if (val_next == LT) {\n            // hit the delimiter, carry on\n            val_next =  (read < value.length) ? value[read++] : 0x00;\n         }\n\n         if (ftr_datetime.length() > 0) {\n            // we want to pass this back in a more friendly format\n            String format_out = \"yyyy-MM-dd'T'HH:mm:ss'Z'\";\n            Date dateunix = new Date();\n            try {\n               // standard ap format\n               String format_in = \"MM-dd-yy HHmmzzz\";\n\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  // standard reuters format\n                  format_in = \"HH:mm MM-dd-yy\";\n               }\n               SimpleDateFormat dfi = new SimpleDateFormat(format_in, Locale.ROOT);\n               dfi.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n               dateunix = dfi.parse(ftr_datetime);\n            }\n            catch (ParseException ep) {\n               // failed, but this will just fall through to setting the date to now\n            }\n            SimpleDateFormat dfo = new SimpleDateFormat(format_out, Locale.ROOT);\n            dfo.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n            ftr_datetime = dfo.format(dateunix);\n         }\n         while ((val_next == CR) || (val_next == LF)) {\n            val_next =  (read < value.length) ? value[read++] : 0x00;  // skip the new lines\n            if ((val_next != CR) && (val_next != LF)) {\n               --read;\n            }\n         }\n         done = true; // don't let this run back through and start thrashing metadata\n      }\n\n      properties.put(\"publisher\", ftr_source);\n      properties.put(\"created\", ftr_datetime);\n      properties.put(\"modified\", ftr_datetime);\n\n      added = (ftr_source.length() + ftr_datetime.length()) > 0; \n      return added;\n   }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setPageSeparator(String pageSeparator) {\n        Matcher m = ALLOWABLE_PAGE_SEPARATORS_PATTERN.matcher(pageSeparator);\n        if (! m.find()) {\n            throw new IllegalArgumentException(pageSeparator + \" contains illegal characters.\\n\"+\n            \"If you trust this value, set it with setTrustedPageSeparator\");\n        }\n        this.pageSeparator = pageSeparator;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setPageSeparator(String pageSeparator) {\n        Matcher m = ALLOWABLE_PAGE_SEPARATORS_PATTERN.matcher(pageSeparator);\n        if (! m.find()) {\n            throw new IllegalArgumentException(pageSeparator + \" contains illegal characters.\\n\"+\n            \"If you trust this value, set it with setTrustedPageSeparator\");\n        }\n        setTrustedPageSeparator(pageSeparator);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setColorspace(String colorspace) {\n        if (!colorspace.equals(null)) {\n            this.colorspace = colorspace;\n        } else {\n            throw new IllegalArgumentException(\"Colorspace value cannot be null.\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setColorspace(String colorspace) {\n        if (colorspace == null) {\n            throw new IllegalArgumentException(\"Colorspace value cannot be null.\");\n        }\n        if (! colorspace.matches(\"(?i)^[-_A-Z0-9]+$\")) {\n            throw new IllegalArgumentException(\"colorspace must match this pattern: (?i)^[-_A-Z0-9]+$\");\n        }\n        this.colorspace = colorspace;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addOtherTesseractConfig(String key, String value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key must not be null\");\n        }\n        if (value == null) {\n            throw new IllegalArgumentException(\"value must not be null\");\n        }\n\n        Matcher m = ALLOWABLE_OTHER_PARAMS_PATTERN.matcher(key);\n        if (! m.find()) {\n            throw new IllegalArgumentException(\"Value contains illegal characters: \"+key);\n        }\n        m.reset(value);\n        if (! m.find()) {\n            throw new IllegalArgumentException(\"Value contains illegal characters: \"+value);\n        }\n\n        otherTesseractConfig.put(key.trim(), value.trim());\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addOtherTesseractConfig(String key, String value) {\n        if (key == null) {\n            throw new IllegalArgumentException(\"key must not be null\");\n        }\n        if (value == null) {\n            throw new IllegalArgumentException(\"value must not be null\");\n        }\n\n        Matcher m = ALLOWABLE_OTHER_PARAMS_PATTERN.matcher(key);\n        if (! m.find()) {\n            throw new IllegalArgumentException(\"Key contains illegal characters: \"+key);\n        }\n        m.reset(value);\n        if (! m.find()) {\n            throw new IllegalArgumentException(\"Value contains illegal characters: \"+value);\n        }\n\n        otherTesseractConfig.put(key.trim(), value.trim());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public AbstractRememberMeManager() {\n        this.serializer = new DefaultSerializer<PrincipalCollection>();\n        this.cipherService = new AesCipherService();\n        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public AbstractRememberMeManager() {\n        this.serializer = new DefaultSerializer<PrincipalCollection>();\n        AesCipherService cipherService = new AesCipherService();\n        this.cipherService = cipherService;\n        setCipherKey(cipherService.generateNewKey().getEncoded());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void getRememberedPrincipals() {\n        HttpServletRequest mockRequest = createMock(HttpServletRequest.class);\n        HttpServletResponse mockResponse = createMock(HttpServletResponse.class);\n        WebSubjectContext context = new DefaultWebSubjectContext();\n        context.setServletRequest(mockRequest);\n        context.setServletResponse(mockResponse);\n\n        expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n\n        //The following base64 string was determined from the log output of the above 'onSuccessfulLogin' test.\n        //This will have to change any time the PrincipalCollection implementation changes:\n        final String userPCAesBase64 = \"WlD5MLzzZznN3dQ1lPJO/eScSuY245k29aECNmjUs31o7Yu478hWhaM5Sj\" +\n                \"jmoe900/72JNu3hcJaPG6Q17Vuz4F8x0kBjbFnPVx4PqzsZYT6yreeS2jwO6OwfI+efqXOKyB2a5KPtnr\" +\n                \"7jt5kZsyH38XJISb81cf6xqTGUru8zC+kNqJFz7E5RpO0kraBofS5jhMm45gDVjDRkjgPJAzocVWMtrza\" +\n                \"zy67P8eb+kMSBCqGI251JTNAGboVgQ28KjfaAJ/6LXRJUj7kB7CGia7mgRk+hxzEJGDs81at5VOPqODJr\" +\n                \"xb8tcIdemFUFIkiYVP9bGs4dP3ECtmw7aNrCzv+84sx3vRFUrd5DbDYpEuE12hF2Y9owDK9sxStbXoF0y\" +\n                \"A32dhfGDIqS+agsass0sWn8WX2TM9i8SxrUjiFbxqyIG49HbqGrZp5QLM9IuIwO+TzGfF1FzumQGdwmWT\" +\n                \"xkVapw5UESl34YvA615cb+82ue1I=\";\n\n        Cookie[] cookies = new Cookie[]{\n                new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n        };\n\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        replay(mockRequest);\n\n        CookieRememberMeManager mgr = new CookieRememberMeManager();\n        PrincipalCollection collection = mgr.getRememberedPrincipals(context);\n\n        verify(mockRequest);\n\n        assertTrue(collection != null);\n        //noinspection ConstantConditions\n        assertTrue(collection.iterator().next().equals(\"user\"));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void getRememberedPrincipals() {\n        HttpServletRequest mockRequest = createMock(HttpServletRequest.class);\n        HttpServletResponse mockResponse = createMock(HttpServletResponse.class);\n        WebSubjectContext context = new DefaultWebSubjectContext();\n        context.setServletRequest(mockRequest);\n        context.setServletResponse(mockResponse);\n\n        expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n\n        //The following base64 string was determined from the log output of the above 'onSuccessfulLogin' test.\n        //This will have to change any time the PrincipalCollection implementation changes:\n        final String userPCAesBase64 = \"WlD5MLzzZznN3dQ1lPJO/eScSuY245k29aECNmjUs31o7Yu478hWhaM5Sj\" +\n                \"jmoe900/72JNu3hcJaPG6Q17Vuz4F8x0kBjbFnPVx4PqzsZYT6yreeS2jwO6OwfI+efqXOKyB2a5KPtnr\" +\n                \"7jt5kZsyH38XJISb81cf6xqTGUru8zC+kNqJFz7E5RpO0kraBofS5jhMm45gDVjDRkjgPJAzocVWMtrza\" +\n                \"zy67P8eb+kMSBCqGI251JTNAGboVgQ28KjfaAJ/6LXRJUj7kB7CGia7mgRk+hxzEJGDs81at5VOPqODJr\" +\n                \"xb8tcIdemFUFIkiYVP9bGs4dP3ECtmw7aNrCzv+84sx3vRFUrd5DbDYpEuE12hF2Y9owDK9sxStbXoF0y\" +\n                \"A32dhfGDIqS+agsass0sWn8WX2TM9i8SxrUjiFbxqyIG49HbqGrZp5QLM9IuIwO+TzGfF1FzumQGdwmWT\" +\n                \"xkVapw5UESl34YvA615cb+82ue1I=\";\n\n        Cookie[] cookies = new Cookie[]{\n                new Cookie(CookieRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n        };\n\n        expect(mockRequest.getCookies()).andReturn(cookies);\n        replay(mockRequest);\n\n        CookieRememberMeManager mgr = new CookieRememberMeManager();\n        mgr.setCipherKey( Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\"));\n        PrincipalCollection collection = mgr.getRememberedPrincipals(context);\n\n        verify(mockRequest);\n\n        assertTrue(collection != null);\n        //noinspection ConstantConditions\n        assertTrue(collection.iterator().next().equals(\"user\"));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            // Invalid case, but happens for includes on Jetty: silently adapt it.\n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        contextPath = normalize(decodeRequestString(request, contextPath));\n        if (\"/\".equals(contextPath)) {\n            // the normalize method will return a \"/\" and includes on Jetty, will also be a \"/\".\n            contextPath = \"\";\n        }\n        return contextPath;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void addEmptyValueMapping(DefaultMapper mapper, String field, Object model) {\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tExpression target = expressionParser.parseExpression(field, parserContext);\n\t\ttry {\n\t\t\tClass<?> propertyType = target.getValueType(model);\n\t\t\tExpression source = new StaticExpression(getEmptyValue(propertyType));\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding empty value mapping for parameter '\" + field + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n\t\t} catch (EvaluationException e) {\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void addEmptyValueMapping(DefaultMapper mapper, String field, Object model) {\n\t\tParserContext parserContext = new FluentParserContext().evaluate(model.getClass());\n\t\tExpression target = emptyValueExpressionParser.parseExpression(field, parserContext);\n\t\ttry {\n\t\t\tClass<?> propertyType = target.getValueType(model);\n\t\t\tExpression source = new StaticExpression(getEmptyValue(propertyType));\n\t\t\tDefaultMapping mapping = new DefaultMapping(source, target);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Adding empty value mapping for parameter '\" + field + \"'\");\n\t\t\t}\n\t\t\tmapper.addMapping(mapping);\n\t\t} catch (EvaluationException e) {\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public RestActionMapper() {\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public RestActionMapper() {\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setTitle(String title) {\n            this.title = title;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setTitle(String title) {\n            this.title = title;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Locale getLocaleFromParam(Object requestedLocale) {\n        Locale locale = null;\n        if (requestedLocale != null) {\n            locale = (requestedLocale instanceof Locale) ?\n                    (Locale) requestedLocale :\n                    LocalizedTextUtil.localeFromString(requestedLocale.toString(), null);\n            if (locale != null) {\n                LOG.debug(\"Applied request locale: {}\", locale);\n            }\n        }\n        return locale;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Locale getLocaleFromParam(Object requestedLocale) {\n        Locale locale = null;\n        if (requestedLocale != null) {\n            locale = (requestedLocale instanceof Locale) ?\n                    (Locale) requestedLocale :\n                    LocalizedTextUtil.localeFromString(requestedLocale.toString(), null);\n            if (locale != null) {\n                LOG.debug(\"Applied request locale: {}\", locale);\n            }\n        }\n\n        if (locale != null && !Arrays.asList(Locale.getAvailableLocales()).contains(locale)) {\n            locale = Locale.getDefault();\n        }\n        return locale;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void register(ContainerBuilder builder, LocatableProperties props) {\n        alias(ObjectFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY, builder, props);\n        alias(FileManagerFactory.class, StrutsConstants.STRUTS_FILE_MANAGER_FACTORY, builder, props, Scope.SINGLETON);\n\n        alias(XWorkConverter.class, StrutsConstants.STRUTS_XWORKCONVERTER, builder, props);\n        alias(CollectionConverter.class, StrutsConstants.STRUTS_CONVERTER_COLLECTION, builder, props);\n        alias(ArrayConverter.class, StrutsConstants.STRUTS_CONVERTER_ARRAY, builder, props);\n        alias(DateConverter.class, StrutsConstants.STRUTS_CONVERTER_DATE, builder, props);\n        alias(NumberConverter.class, StrutsConstants.STRUTS_CONVERTER_NUMBER, builder, props);\n        alias(StringConverter.class, StrutsConstants.STRUTS_CONVERTER_STRING, builder, props);\n\n        alias(ConversionPropertiesProcessor.class, StrutsConstants.STRUTS_CONVERTER_PROPERTIES_PROCESSOR, builder, props);\n        alias(ConversionFileProcessor.class, StrutsConstants.STRUTS_CONVERTER_FILE_PROCESSOR, builder, props);\n        alias(ConversionAnnotationProcessor.class, StrutsConstants.STRUTS_CONVERTER_ANNOTATION_PROCESSOR, builder, props);\n        alias(TypeConverterCreator.class, StrutsConstants.STRUTS_CONVERTER_CREATOR, builder, props);\n        alias(TypeConverterHolder.class, StrutsConstants.STRUTS_CONVERTER_HOLDER, builder, props);\n\n        alias(TextProvider.class, StrutsConstants.STRUTS_XWORKTEXTPROVIDER, builder, props, Scope.DEFAULT);\n\n        alias(LocaleProvider.class, StrutsConstants.STRUTS_LOCALE_PROVIDER, builder, props);\n        alias(ActionProxyFactory.class, StrutsConstants.STRUTS_ACTIONPROXYFACTORY, builder, props);\n        alias(ObjectTypeDeterminer.class, StrutsConstants.STRUTS_OBJECTTYPEDETERMINER, builder, props);\n        alias(ActionMapper.class, StrutsConstants.STRUTS_MAPPER_CLASS, builder, props);\n        alias(MultiPartRequest.class, StrutsConstants.STRUTS_MULTIPART_PARSER, builder, props, Scope.DEFAULT);\n        alias(FreemarkerManager.class, StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME, builder, props);\n        alias(VelocityManager.class, StrutsConstants.STRUTS_VELOCITY_MANAGER_CLASSNAME, builder, props);\n        alias(UrlRenderer.class, StrutsConstants.STRUTS_URL_RENDERER, builder, props);\n        alias(ActionValidatorManager.class, StrutsConstants.STRUTS_ACTIONVALIDATORMANAGER, builder, props);\n        alias(ValueStackFactory.class, StrutsConstants.STRUTS_VALUESTACKFACTORY, builder, props);\n        alias(ReflectionProvider.class, StrutsConstants.STRUTS_REFLECTIONPROVIDER, builder, props);\n        alias(ReflectionContextFactory.class, StrutsConstants.STRUTS_REFLECTIONCONTEXTFACTORY, builder, props);\n        alias(PatternMatcher.class, StrutsConstants.STRUTS_PATTERNMATCHER, builder, props);\n        alias(StaticContentLoader.class, StrutsConstants.STRUTS_STATIC_CONTENT_LOADER, builder, props);\n        alias(UnknownHandlerManager.class, StrutsConstants.STRUTS_UNKNOWN_HANDLER_MANAGER, builder, props);\n        alias(UrlHelper.class, StrutsConstants.STRUTS_URL_HELPER, builder, props);\n\n        alias(TextParser.class, StrutsConstants.STRUTS_EXPRESSION_PARSER, builder, props);\n\n        if (\"true\".equalsIgnoreCase(props.getProperty(StrutsConstants.STRUTS_DEVMODE))) {\n            props.setProperty(StrutsConstants.STRUTS_I18N_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE, \"false\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY, \"0\");\n            // Convert struts properties into ones that xwork expects\n            props.setProperty(XWorkConstants.DEV_MODE, \"true\");\n        } else {\n            props.setProperty(XWorkConstants.DEV_MODE, \"false\");\n        }\n\n        // Convert Struts properties into XWork properties\n        convertIfExist(props, StrutsConstants.STRUTS_LOG_MISSING_PROPERTIES, XWorkConstants.LOG_MISSING_PROPERTIES);\n        convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EXPRESSION_CACHE, XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE);\n        convertIfExist(props, StrutsConstants.STRUTS_ALLOW_STATIC_METHOD_ACCESS, XWorkConstants.ALLOW_STATIC_METHOD_ACCESS);\n        convertIfExist(props, StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, XWorkConstants.RELOAD_XML_CONFIGURATION);\n\n        LocalizedTextUtil.addDefaultResourceBundle(\"org/apache/struts2/struts-messages\");\n        loadCustomResourceBundles(props);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void register(ContainerBuilder builder, LocatableProperties props) {\n        alias(ObjectFactory.class, StrutsConstants.STRUTS_OBJECTFACTORY, builder, props);\n        alias(FileManagerFactory.class, StrutsConstants.STRUTS_FILE_MANAGER_FACTORY, builder, props, Scope.SINGLETON);\n\n        alias(XWorkConverter.class, StrutsConstants.STRUTS_XWORKCONVERTER, builder, props);\n        alias(CollectionConverter.class, StrutsConstants.STRUTS_CONVERTER_COLLECTION, builder, props);\n        alias(ArrayConverter.class, StrutsConstants.STRUTS_CONVERTER_ARRAY, builder, props);\n        alias(DateConverter.class, StrutsConstants.STRUTS_CONVERTER_DATE, builder, props);\n        alias(NumberConverter.class, StrutsConstants.STRUTS_CONVERTER_NUMBER, builder, props);\n        alias(StringConverter.class, StrutsConstants.STRUTS_CONVERTER_STRING, builder, props);\n\n        alias(ConversionPropertiesProcessor.class, StrutsConstants.STRUTS_CONVERTER_PROPERTIES_PROCESSOR, builder, props);\n        alias(ConversionFileProcessor.class, StrutsConstants.STRUTS_CONVERTER_FILE_PROCESSOR, builder, props);\n        alias(ConversionAnnotationProcessor.class, StrutsConstants.STRUTS_CONVERTER_ANNOTATION_PROCESSOR, builder, props);\n        alias(TypeConverterCreator.class, StrutsConstants.STRUTS_CONVERTER_CREATOR, builder, props);\n        alias(TypeConverterHolder.class, StrutsConstants.STRUTS_CONVERTER_HOLDER, builder, props);\n\n        alias(TextProvider.class, StrutsConstants.STRUTS_XWORKTEXTPROVIDER, builder, props, Scope.DEFAULT);\n\n        alias(LocaleProvider.class, StrutsConstants.STRUTS_LOCALE_PROVIDER, builder, props);\n        alias(ActionProxyFactory.class, StrutsConstants.STRUTS_ACTIONPROXYFACTORY, builder, props);\n        alias(ObjectTypeDeterminer.class, StrutsConstants.STRUTS_OBJECTTYPEDETERMINER, builder, props);\n        alias(ActionMapper.class, StrutsConstants.STRUTS_MAPPER_CLASS, builder, props);\n        alias(MultiPartRequest.class, StrutsConstants.STRUTS_MULTIPART_PARSER, builder, props, Scope.DEFAULT);\n        alias(FreemarkerManager.class, StrutsConstants.STRUTS_FREEMARKER_MANAGER_CLASSNAME, builder, props);\n        alias(VelocityManager.class, StrutsConstants.STRUTS_VELOCITY_MANAGER_CLASSNAME, builder, props);\n        alias(UrlRenderer.class, StrutsConstants.STRUTS_URL_RENDERER, builder, props);\n        alias(ActionValidatorManager.class, StrutsConstants.STRUTS_ACTIONVALIDATORMANAGER, builder, props);\n        alias(ValueStackFactory.class, StrutsConstants.STRUTS_VALUESTACKFACTORY, builder, props);\n        alias(ReflectionProvider.class, StrutsConstants.STRUTS_REFLECTIONPROVIDER, builder, props);\n        alias(ReflectionContextFactory.class, StrutsConstants.STRUTS_REFLECTIONCONTEXTFACTORY, builder, props);\n        alias(PatternMatcher.class, StrutsConstants.STRUTS_PATTERNMATCHER, builder, props);\n        alias(StaticContentLoader.class, StrutsConstants.STRUTS_STATIC_CONTENT_LOADER, builder, props);\n        alias(UnknownHandlerManager.class, StrutsConstants.STRUTS_UNKNOWN_HANDLER_MANAGER, builder, props);\n        alias(UrlHelper.class, StrutsConstants.STRUTS_URL_HELPER, builder, props);\n\n        alias(TextParser.class, StrutsConstants.STRUTS_EXPRESSION_PARSER, builder, props);\n\n        if (\"true\".equalsIgnoreCase(props.getProperty(StrutsConstants.STRUTS_DEVMODE))) {\n            props.setProperty(StrutsConstants.STRUTS_I18N_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, \"true\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE, \"false\");\n            props.setProperty(StrutsConstants.STRUTS_FREEMARKER_TEMPLATES_CACHE_UPDATE_DELAY, \"0\");\n            // Convert struts properties into ones that xwork expects\n            props.setProperty(XWorkConstants.DEV_MODE, \"true\");\n        } else {\n            props.setProperty(XWorkConstants.DEV_MODE, \"false\");\n        }\n\n        // Convert Struts properties into XWork properties\n        convertIfExist(props, StrutsConstants.STRUTS_LOG_MISSING_PROPERTIES, XWorkConstants.LOG_MISSING_PROPERTIES);\n        convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EXPRESSION_CACHE, XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE);\n        convertIfExist(props, StrutsConstants.STRUTS_ENABLE_OGNL_EVAL_EXPRESSION, XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION);\n        convertIfExist(props, StrutsConstants.STRUTS_ALLOW_STATIC_METHOD_ACCESS, XWorkConstants.ALLOW_STATIC_METHOD_ACCESS);\n        convertIfExist(props, StrutsConstants.STRUTS_CONFIGURATION_XML_RELOAD, XWorkConstants.RELOAD_XML_CONFIGURATION);\n\n        LocalizedTextUtil.addDefaultResourceBundle(\"org/apache/struts2/struts-messages\");\n        loadCustomResourceBundles(props);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static boolean isExpression(Object value) {\n        String expr = value.toString();\n        return expr.startsWith(\"%{\") && expr.endsWith(\"}\");\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static boolean isExpression(String expr) {\n        return expr.startsWith(\"%{\") && expr.endsWith(\"}\");\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private String buildParameterSubstring(String name, String value) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(translateAndEncode(name));\n        builder.append('=');\n        builder.append(translateAndEncode(value));\n        return builder.toString();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private String buildParameterSubstring(String name, String value) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(encode(name));\n        builder.append('=');\n        builder.append(encode(value));\n        return builder.toString();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "Object> parseQueryString(String queryString, boolean forceValueArray) {\n        Map<String, Object> queryParams = new LinkedHashMap<String, Object>();\n        if (queryString != null) {\n            String[] params = queryString.split(\"&\");\n            for (String param : params) {\n                if (param.trim().length() > 0) {\n                    String[] tmpParams = param.split(\"=\");\n                    String paramName = null;\n                    String paramValue = \"\";\n                    if (tmpParams.length > 0) {\n                        paramName = tmpParams[0];\n                    }\n                    if (tmpParams.length > 1) {\n                        paramValue = tmpParams[1];\n                    }\n                    if (paramName != null) {\n                        paramName = translateAndDecode(paramName);\n                        String translatedParamValue = translateAndDecode(paramValue);\n\n                        if (queryParams.containsKey(paramName) || forceValueArray) {\n                            // WW-1619 append new param value to existing value(s)\n                            Object currentParam = queryParams.get(paramName);\n                            if (currentParam instanceof String) {\n                                queryParams.put(paramName, new String[]{(String) currentParam, translatedParamValue});\n                            } else {\n                                String currentParamValues[] = (String[]) currentParam;\n                                if (currentParamValues != null) {\n                                    List<String> paramList = new ArrayList<String>(Arrays.asList(currentParamValues));\n                                    paramList.add(translatedParamValue);\n                                    queryParams.put(paramName, paramList.toArray(new String[paramList.size()]));\n                                } else {\n                                    queryParams.put(paramName, new String[]{translatedParamValue});\n                                }\n                            }\n                        } else {\n                            queryParams.put(paramName, translatedParamValue);\n                        }\n                    }\n                }\n            }\n        }\n        return queryParams;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "Object> parseQueryString(String queryString, boolean forceValueArray) {\n        Map<String, Object> queryParams = new LinkedHashMap<String, Object>();\n        if (queryString != null) {\n            String[] params = queryString.split(\"&\");\n            for (String param : params) {\n                if (param.trim().length() > 0) {\n                    String[] tmpParams = param.split(\"=\");\n                    String paramName = null;\n                    String paramValue = \"\";\n                    if (tmpParams.length > 0) {\n                        paramName = tmpParams[0];\n                    }\n                    if (tmpParams.length > 1) {\n                        paramValue = tmpParams[1];\n                    }\n                    if (paramName != null) {\n                        paramName = decode(paramName);\n                        String translatedParamValue = decode(paramValue);\n\n                        if (queryParams.containsKey(paramName) || forceValueArray) {\n                            // WW-1619 append new param value to existing value(s)\n                            Object currentParam = queryParams.get(paramName);\n                            if (currentParam instanceof String) {\n                                queryParams.put(paramName, new String[]{(String) currentParam, translatedParamValue});\n                            } else {\n                                String currentParamValues[] = (String[]) currentParam;\n                                if (currentParamValues != null) {\n                                    List<String> paramList = new ArrayList<String>(Arrays.asList(currentParamValues));\n                                    paramList.add(translatedParamValue);\n                                    queryParams.put(paramName, paramList.toArray(new String[paramList.size()]));\n                                } else {\n                                    queryParams.put(paramName, new String[]{translatedParamValue});\n                                }\n                            }\n                        } else {\n                            queryParams.put(paramName, translatedParamValue);\n                        }\n                    }\n                }\n            }\n        }\n        return queryParams;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected String cleanupActionName(final String rawActionName) {\n        if (allowedActionNames.matcher(rawActionName).matches()) {\n            return rawActionName;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Action/method [#0] does not match allowed action names pattern [#1], cleaning it up!\",\n                        rawActionName, allowedActionNames);\n            }\n            String cleanActionName = rawActionName;\n            for (String chunk : allowedActionNames.split(rawActionName)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Cleaned action/method name [#0]\", cleanActionName);\n            }\n            return cleanActionName;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected String cleanupActionName(final String rawActionName) {\n        if (allowedActionNames.matcher(rawActionName).matches()) {\n            return rawActionName;\n        } else {\n            throw new StrutsException(\"Action [\" + rawActionName + \"] does not match allowed action names pattern [\" + allowedActionNames + \"]!\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected String buildErrorMessage(Throwable e, Object[] args) {\n        String errorKey = \"struts.messages.upload.error.\" + e.getClass().getSimpleName();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Preparing error message for key: [#0]\", errorKey);\n        }\n        return LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, e.getMessage(), args);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected String buildErrorMessage(Throwable e, Object[] args) {\n        String errorKey = \"struts.messages.upload.error.\" + e.getClass().getSimpleName();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Preparing error message for key: [#0]\", errorKey);\n        }\n        if (LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, null, new Object[0]) == null) {\n            return LocalizedTextUtil.findText(this.getClass(), \"struts.messages.error.uploading\", defaultLocale, null, new Object[] { e.getMessage() });\n        } else {\n            return LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, null, args);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private String buildErrorMessage(Throwable e, Object[] args) {\n        String errorKey = \"struts.message.upload.error.\" + e.getClass().getSimpleName();\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Preparing error message for key: [#0]\", errorKey);\n        return LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, e.getMessage(), args);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private String buildErrorMessage(Throwable e, Object[] args) {\n        String errorKey = \"struts.message.upload.error.\" + e.getClass().getSimpleName();\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Preparing error message for key: [#0]\", errorKey);\n        if (LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, null, new Object[0]) == null) {\n            return LocalizedTextUtil.findText(this.getClass(), \"struts.messages.error.uploading\", defaultLocale, null, new Object[] { e.getMessage() });\n        } else {\n            return LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, null, args);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected String buildErrorMessage(Throwable e, Object[] args) {\n        String errorKey = \"struts.messages.upload.error.\" + e.getClass().getSimpleName();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Preparing error message for key: [#0]\", errorKey);\n        }\n        return LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, e.getMessage(), args);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected String buildErrorMessage(Throwable e, Object[] args) {\n        String errorKey = \"struts.messages.upload.error.\" + e.getClass().getSimpleName();\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Preparing error message for key: [#0]\", errorKey);\n        }\n        if (LocalizedTextUtil.findText(this.getClass(), errorKey, getLocale(), null, new Object[0]) == null) {\n            return LocalizedTextUtil.findText(this.getClass(), \"struts.messages.error.uploading\", defaultLocale, null, new Object[] { e.getMessage() });\n        } else {\n            return LocalizedTextUtil.findText(this.getClass(), errorKey, defaultLocale, null, args);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Component findAncestor(Class clazz) {\n        Stack componentStack = getComponentStack();\n        int currPosition = componentStack.search(this);\n        if (currPosition >= 0) {\n            int start = componentStack.size() - currPosition - 1;\n\n            //for (int i = componentStack.size() - 2; i >= 0; i--) {\n            for (int i = start; i >=0; i--) {\n                Component component = (Component) componentStack.get(i);\n                if (clazz.isAssignableFrom(component.getClass()) && component != this) {\n                    return component;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Evaluates the OGNL stack to find a String value.\n     * @param expr  OGNL expression.\n     * @return  the String value found.\n     */\n    protected String findString(String expr) {\n        return (String) findValue(expr, String.class);\n    }\n\n    /**\n     * Evaluates the OGNL stack to find a String value.\n     * <br>\n     * If the given expression is <tt>null</tt> a error is logged and a <code>RuntimeException</code> is thrown\n     * constructed with a messaged based on the given field and errorMsg parameter.\n     *\n     * @param expr  OGNL expression.\n     * @param field   field name used when throwing <code>RuntimeException</code>.\n     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.\n     * @return  the String value found.\n     * @throws StrutsException is thrown in case of expression is null.\n     */\n    protected String findString(String expr, String field, String errorMsg) {\n        if (expr == null) {\n            throw fieldError(field, errorMsg, null);\n        } else {\n            return findString(expr);\n        }\n    }\n\n    /**\n     * Constructs a <code>RuntimeException</code> based on the given information.\n     * <br>\n     * A message is constructed and logged at ERROR level before being returned\n     * as a <code>RuntimeException</code>.\n     * @param field   field name used when throwing <code>RuntimeException</code>.\n     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.\n     * @param e  the caused exception, can be <tt>null</tt>.\n     * @return  the constructed <code>StrutsException</code>.\n     */\n    protected StrutsException fieldError(String field, String errorMsg, Exception e) {\n        String msg = \"tag '\" + getComponentName() + \"', field '\" + field +\n                ( parameters != null && parameters.containsKey(\"name\")?\"', name '\" + parameters.get(\"name\"):\"\") +\n                \"': \" + errorMsg;\n        throw new StrutsException(msg, e);\n    }\n\n    /**\n     * Finds a value from the OGNL stack based on the given expression.\n     * Will always evaluate <code>expr</code> against stack except when <code>expr</code>\n     * is null. If altsyntax (%{...}) is applied, simply strip it off.\n     *\n     * @param expr  the expression. Returns <tt>null</tt> if expr is null.\n     * @return the value, <tt>null</tt> if not found.\n     */\n    protected Object findValue(String expr) {\n        if (expr == null) {\n            return null;\n        }\n\n        expr = stripExpressionIfAltSyntax(expr);\n\n        return getStack().findValue(expr, throwExceptionOnELFailure);\n    }\n\n    /**\n     * If altsyntax (%{...}) is applied, simply strip the \"%{\" and \"}\" off. \n     * @param expr the expression (must be not null)\n     * @return the stripped expression if altSyntax is enabled. Otherwise\n     * the parameter expression is returned as is.\n     */\n\tprotected String stripExpressionIfAltSyntax(String expr) {\n\t\treturn ComponentUtils.stripExpressionIfAltSyntax(stack, expr);\n\t}\n\n    /**\n     * See <code>struts.properties</code> where the altSyntax flag is defined.\n     * @return if the altSyntax enabled? [TRUE]\n     */\n    public boolean altSyntax() {\n        return ComponentUtils.altSyntax(stack);\n    }\n\n    /**\n     * Adds the surrounding %{ } to the expression for proper processing.\n     * @param expr the expression.\n     * @return the modified expression if altSyntax is enabled, or the parameter \n     * expression otherwise.\n     */\n\tprotected String completeExpressionIfAltSyntax(String expr) {\n\t\tif (altSyntax()) {\n\t\t\treturn \"%{\" + expr + \"}\";\n\t\t}\n\t\treturn expr;\n\t}\n\n    /**\n     * This check is needed for backwards compatibility with 2.1.x\n     * @param expr the expression.\n     * @return the found string if altSyntax is enabled. The parameter\n     * expression otherwise.\n     */\n\tprotected String findStringIfAltSyntax(String expr) {\n\t\tif (altSyntax()) {\n\t\t    return findString(expr);\n\t\t}\n\t\treturn expr;\n\t}\n\n    /**\n     * <p>\n     * Evaluates the OGNL stack to find an Object value.\n     * </p>\n     *\n     * <p>\n     * Function just like <code>findValue(String)</code> except that if the\n     * given expression is <tt>null</tt> a error is logged and\n     * a <code>RuntimeException</code> is thrown constructed with a\n     * messaged based on the given field and errorMsg parameter.\n     * </p>\n     *\n     * @param expr  OGNL expression.\n     * @param field   field name used when throwing <code>RuntimeException</code>.\n     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.\n     * @return  the Object found, is never <tt>null</tt>.\n     * @throws StrutsException is thrown in case of not found in the OGNL stack, or expression is <tt>null</tt>.\n     */\n    protected Object findValue(String expr, String field, String errorMsg) {\n        if (expr == null) {\n            throw fieldError(field, errorMsg, null);\n        } else {\n            Object value = null;\n            Exception problem = null;\n            try {\n                value = findValue(expr);\n            } catch (Exception e) {\n                problem = e;\n            }\n\n            if (value == null) {\n                throw fieldError(field, errorMsg, problem);\n            }\n\n            return value;\n        }\n    }\n\n    /**\n     * Evaluates the OGNL stack to find an Object of the given type. Will evaluate\n     * <code>expr</code> the portion wrapped with altSyntax (%{...})\n     * against stack when altSyntax is on, else the whole <code>expr</code>\n     * is evaluated against the stack.\n     * <br>\n     * This method only supports the altSyntax. So this should be set to true.\n     * @param expr  OGNL expression.\n     * @param toType  the type expected to find.\n     * @return  the Object found, or <tt>null</tt> if not found.\n     */\n    protected Object findValue(String expr, Class toType) {\n        if (altSyntax() && toType == String.class) {\n        \treturn TextParseUtil.translateVariables('%', expr, stack);\n        } else {\n            expr = stripExpressionIfAltSyntax(expr);\n\n            return getStack().findValue(expr, toType, throwExceptionOnELFailure);\n        }\n    }\n\n    /**\n     * Renders an action URL by consulting the {@link org.apache.struts2.dispatcher.mapper.ActionMapper}.\n     * @param action      the action\n     * @param namespace   the namespace\n     * @param method      the method\n     * @param req         HTTP request\n     * @param res         HTTP response\n     * @param parameters  parameters\n     * @param scheme      http or https\n     * @param includeContext  should the context path be included or not\n     * @param encodeResult    should the url be encoded\n     * @param forceAddSchemeHostAndPort    should the scheme host and port be forced\n     * @param escapeAmp    should ampersand (&amp;) be escaped to &amp;amp;\n     * @return the action url.\n     */\n    protected String determineActionURL(String action, String namespace, String method,\n                                        HttpServletRequest req, HttpServletResponse res, Map parameters, String scheme,\n                                        boolean includeContext, boolean encodeResult, boolean forceAddSchemeHostAndPort,\n                                        boolean escapeAmp) {\n        String finalAction = findString(action);\n        String finalMethod = method != null ? findString(method) : null;\n        String finalNamespace = determineNamespace(namespace, getStack(), req);\n        ActionMapping mapping = new ActionMapping(finalAction, finalNamespace, finalMethod, parameters);\n        String uri = actionMapper.getUriFromActionMapping(mapping);\n        return urlHelper.buildUrl(uri, req, res, parameters, scheme, includeContext, encodeResult, forceAddSchemeHostAndPort, escapeAmp);\n    }\n\n    /**\n     * Determines the namespace of the current page being renderdd. Useful for Form, URL, and href generations.\n     * @param namespace  the namespace\n     * @param stack      OGNL value stack\n     * @param req        HTTP request\n     * @return  the namepsace of the current page being rendered, is never <tt>null</tt>.\n     */\n    protected String determineNamespace(String namespace, ValueStack stack, HttpServletRequest req) {\n        String result;\n\n        if (namespace == null) {\n            result = TagUtils.buildNamespace(actionMapper, stack, req);\n        } else {\n            result = findString(namespace);\n        }\n\n        if (result == null) {\n            result = \"\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Pushes this component's parameter Map as well as the component itself on to the stack\n     * and then copies the supplied parameters over. Because the component's parameter Map is\n     * pushed before the component itself, any key-value pair that can't be assigned to component\n     * will be set in the parameters Map.\n     *\n     * @param params  the parameters to copy.\n     */\n    public void copyParams(Map params) {\n        stack.push(parameters);\n        stack.push(this);\n        try {\n            for (Object o : params.entrySet()) {\n                Map.Entry entry = (Map.Entry) o;\n                String key = (String) entry.getKey();\n\n                if (key.indexOf('-') >= 0) {\n                    // UI component attributes may contain hypens (e.g. data-ajax), but ognl\n                    // can't handle that, and there can't be a component property with a hypen\n                    // so into the parameters map it goes. See WW-4493\n                    parameters.put(key, entry.getValue());\n                } else {\n                    stack.setValue(key, entry.getValue());\n                }\n            }\n        } finally {\n            stack.pop();\n            stack.pop();\n        }\n    }\n\n    /**\n     * Constructs a string representation of the given exception.\n     * @param t  the exception\n     * @return the exception as a string.\n     */\n    protected String toString(Throwable t) {\n        try (FastByteArrayOutputStream bout = new FastByteArrayOutputStream();\n                PrintWriter wrt = new PrintWriter(bout)) {\n            t.printStackTrace(wrt);\n            return bout.toString();\n        }\n    }\n\n    /**\n     * Gets the parameters.\n     * @return the parameters. Is never <tt>null</tt>.\n     */\n    public Map getParameters() {\n        return parameters;\n    }\n\n    /**\n     * Adds all the given parameters to this component's own parameters.\n     * @param params the parameters to add.\n     */\n    public void addAllParameters(Map params) {\n        parameters.putAll(params);\n    }\n\n    /**\n     * Adds the given key and value to this component's own parameter.\n     * <br>\n     * If the provided key is <tt>null</tt> nothing happens.\n     * If the provided value is <tt>null</tt> any existing parameter with\n     * the given key name is removed.\n     * @param key  the key of the new parameter to add.\n     * @param value the value associated with the key.\n     */\n    public void addParameter(String key, Object value) {\n        if (key != null) {\n            Map params = getParameters();\n\n            if (value == null) {\n                params.remove(key);\n            } else {\n                params.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Overwrite to set if body should be used.\n     * @return always false for this component.\n     */\n    public boolean usesBody() {\n        return false;\n    }\n\n    /**\n     * Checks if provided name is a valid tag's attribute\n     *\n     * @param attrName String name of attribute\n     * @return true if attribute with the same name was already defined\n     */\n    public boolean isValidTagAttribute(String attrName) {\n        return getStandardAttributes().contains(attrName);\n    }\n\n    /**\n     * If needed caches all methods annotated by given annotation to avoid further scans\n     *\n     * @return list of attributes\n     */\n    protected Collection<String> getStandardAttributes() {\n        Class clz = getClass();\n        Collection<String> standardAttributes = standardAttributesMap.get(clz);\n        if (standardAttributes == null) {\n            Collection<Method> methods = AnnotationUtils.getAnnotatedMethods(clz, StrutsTagAttribute.class);\n            standardAttributes = new HashSet<>(methods.size());\n            for(Method m : methods) {\n                standardAttributes.add(StringUtils.uncapitalize(m.getName().substring(3)));\n            }\n            standardAttributesMap.putIfAbsent(clz, standardAttributes);\n        }\n        return standardAttributes;\n    }\n\n}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Component findAncestor(Class clazz) {\n        Stack componentStack = getComponentStack();\n        int currPosition = componentStack.search(this);\n        if (currPosition >= 0) {\n            int start = componentStack.size() - currPosition - 1;\n\n            //for (int i = componentStack.size() - 2; i >= 0; i--) {\n            for (int i = start; i >=0; i--) {\n                Component component = (Component) componentStack.get(i);\n                if (clazz.isAssignableFrom(component.getClass()) && component != this) {\n                    return component;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Evaluates the OGNL stack to find a String value.\n     * @param expr  OGNL expression.\n     * @return  the String value found.\n     */\n    protected String findString(String expr) {\n        return (String) findValue(expr, String.class);\n    }\n\n    /**\n     * Evaluates the OGNL stack to find a String value.\n     * <br>\n     * If the given expression is <tt>null</tt> a error is logged and a <code>RuntimeException</code> is thrown\n     * constructed with a messaged based on the given field and errorMsg parameter.\n     *\n     * @param expr  OGNL expression.\n     * @param field   field name used when throwing <code>RuntimeException</code>.\n     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.\n     * @return  the String value found.\n     * @throws StrutsException is thrown in case of expression is null.\n     */\n    protected String findString(String expr, String field, String errorMsg) {\n        if (expr == null) {\n            throw fieldError(field, errorMsg, null);\n        } else {\n            return findString(expr);\n        }\n    }\n\n    /**\n     * Constructs a <code>RuntimeException</code> based on the given information.\n     * <br>\n     * A message is constructed and logged at ERROR level before being returned\n     * as a <code>RuntimeException</code>.\n     * @param field   field name used when throwing <code>RuntimeException</code>.\n     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.\n     * @param e  the caused exception, can be <tt>null</tt>.\n     * @return  the constructed <code>StrutsException</code>.\n     */\n    protected StrutsException fieldError(String field, String errorMsg, Exception e) {\n        String msg = \"tag '\" + getComponentName() + \"', field '\" + field +\n                ( parameters != null && parameters.containsKey(\"name\")?\"', name '\" + parameters.get(\"name\"):\"\") +\n                \"': \" + errorMsg;\n        throw new StrutsException(msg, e);\n    }\n\n    /**\n     * Finds a value from the OGNL stack based on the given expression.\n     * Will always evaluate <code>expr</code> against stack except when <code>expr</code>\n     * is null. If altsyntax (%{...}) is applied, simply strip it off.\n     *\n     * @param expr  the expression. Returns <tt>null</tt> if expr is null.\n     * @return the value, <tt>null</tt> if not found.\n     */\n    protected Object findValue(String expr) {\n        if (expr == null) {\n            return null;\n        }\n\n        expr = stripExpressionIfAltSyntax(expr);\n\n        return getStack().findValue(expr, throwExceptionOnELFailure);\n    }\n\n    /**\n     * If altsyntax (%{...}) is applied, simply strip the \"%{\" and \"}\" off. \n     * @param expr the expression (must be not null)\n     * @return the stripped expression if altSyntax is enabled. Otherwise\n     * the parameter expression is returned as is.\n     */\n\tprotected String stripExpressionIfAltSyntax(String expr) {\n\t\treturn ComponentUtils.stripExpressionIfAltSyntax(stack, expr);\n\t}\n\n    /**\n     * See <code>struts.properties</code> where the altSyntax flag is defined.\n     * @return if the altSyntax enabled? [TRUE]\n     */\n    public boolean altSyntax() {\n        return ComponentUtils.altSyntax(stack);\n    }\n\n    /**\n     * Adds the surrounding %{ } to the expression for proper processing.\n     * @param expr the expression.\n     * @return the modified expression if altSyntax is enabled, or the parameter \n     * expression otherwise.\n     */\n\tprotected String completeExpressionIfAltSyntax(String expr) {\n\t\tif (altSyntax()) {\n\t\t\treturn \"%{\" + expr + \"}\";\n\t\t}\n\t\treturn expr;\n\t}\n\n    /**\n     * This check is needed for backwards compatibility with 2.1.x\n     * @param expr the expression.\n     * @return the found string if altSyntax is enabled. The parameter\n     * expression otherwise.\n     */\n\tprotected String findStringIfAltSyntax(String expr) {\n\t\tif (altSyntax()) {\n\t\t    return findString(expr);\n\t\t}\n\t\treturn expr;\n\t}\n\n    /**\n     * <p>\n     * Evaluates the OGNL stack to find an Object value.\n     * </p>\n     *\n     * <p>\n     * Function just like <code>findValue(String)</code> except that if the\n     * given expression is <tt>null</tt> a error is logged and\n     * a <code>RuntimeException</code> is thrown constructed with a\n     * messaged based on the given field and errorMsg parameter.\n     * </p>\n     *\n     * @param expr  OGNL expression.\n     * @param field   field name used when throwing <code>RuntimeException</code>.\n     * @param errorMsg  error message used when throwing <code>RuntimeException</code>.\n     * @return  the Object found, is never <tt>null</tt>.\n     * @throws StrutsException is thrown in case of not found in the OGNL stack, or expression is <tt>null</tt>.\n     */\n    protected Object findValue(String expr, String field, String errorMsg) {\n        if (expr == null) {\n            throw fieldError(field, errorMsg, null);\n        } else {\n            Object value = null;\n            Exception problem = null;\n            try {\n                value = findValue(expr);\n            } catch (Exception e) {\n                problem = e;\n            }\n\n            if (value == null) {\n                throw fieldError(field, errorMsg, problem);\n            }\n\n            return value;\n        }\n    }\n\n    /**\n     * Evaluates the OGNL stack to find an Object of the given type. Will evaluate\n     * <code>expr</code> the portion wrapped with altSyntax (%{...})\n     * against stack when altSyntax is on, else the whole <code>expr</code>\n     * is evaluated against the stack.\n     * <br>\n     * This method only supports the altSyntax. So this should be set to true.\n     * @param expr  OGNL expression.\n     * @param toType  the type expected to find.\n     * @return  the Object found, or <tt>null</tt> if not found.\n     */\n    protected Object findValue(String expr, Class toType) {\n        if (altSyntax() && toType == String.class) {\n            if (ComponentUtils.containsExpression(expr)) {\n                return TextParseUtil.translateVariables('%', expr, stack);\n            } else {\n                return expr;\n            }\n        } else {\n            expr = stripExpressionIfAltSyntax(expr);\n\n            return getStack().findValue(expr, toType, throwExceptionOnELFailure);\n        }\n    }\n\n    /**\n     * Renders an action URL by consulting the {@link org.apache.struts2.dispatcher.mapper.ActionMapper}.\n     * @param action      the action\n     * @param namespace   the namespace\n     * @param method      the method\n     * @param req         HTTP request\n     * @param res         HTTP response\n     * @param parameters  parameters\n     * @param scheme      http or https\n     * @param includeContext  should the context path be included or not\n     * @param encodeResult    should the url be encoded\n     * @param forceAddSchemeHostAndPort    should the scheme host and port be forced\n     * @param escapeAmp    should ampersand (&amp;) be escaped to &amp;amp;\n     * @return the action url.\n     */\n    protected String determineActionURL(String action, String namespace, String method,\n                                        HttpServletRequest req, HttpServletResponse res, Map parameters, String scheme,\n                                        boolean includeContext, boolean encodeResult, boolean forceAddSchemeHostAndPort,\n                                        boolean escapeAmp) {\n        String finalAction = findString(action);\n        String finalMethod = method != null ? findString(method) : null;\n        String finalNamespace = determineNamespace(namespace, getStack(), req);\n        ActionMapping mapping = new ActionMapping(finalAction, finalNamespace, finalMethod, parameters);\n        String uri = actionMapper.getUriFromActionMapping(mapping);\n        return urlHelper.buildUrl(uri, req, res, parameters, scheme, includeContext, encodeResult, forceAddSchemeHostAndPort, escapeAmp);\n    }\n\n    /**\n     * Determines the namespace of the current page being renderdd. Useful for Form, URL, and href generations.\n     * @param namespace  the namespace\n     * @param stack      OGNL value stack\n     * @param req        HTTP request\n     * @return  the namepsace of the current page being rendered, is never <tt>null</tt>.\n     */\n    protected String determineNamespace(String namespace, ValueStack stack, HttpServletRequest req) {\n        String result;\n\n        if (namespace == null) {\n            result = TagUtils.buildNamespace(actionMapper, stack, req);\n        } else {\n            result = findString(namespace);\n        }\n\n        if (result == null) {\n            result = \"\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Pushes this component's parameter Map as well as the component itself on to the stack\n     * and then copies the supplied parameters over. Because the component's parameter Map is\n     * pushed before the component itself, any key-value pair that can't be assigned to component\n     * will be set in the parameters Map.\n     *\n     * @param params  the parameters to copy.\n     */\n    public void copyParams(Map params) {\n        stack.push(parameters);\n        stack.push(this);\n        try {\n            for (Object o : params.entrySet()) {\n                Map.Entry entry = (Map.Entry) o;\n                String key = (String) entry.getKey();\n\n                if (key.indexOf('-') >= 0) {\n                    // UI component attributes may contain hypens (e.g. data-ajax), but ognl\n                    // can't handle that, and there can't be a component property with a hypen\n                    // so into the parameters map it goes. See WW-4493\n                    parameters.put(key, entry.getValue());\n                } else {\n                    stack.setValue(key, entry.getValue());\n                }\n            }\n        } finally {\n            stack.pop();\n            stack.pop();\n        }\n    }\n\n    /**\n     * Constructs a string representation of the given exception.\n     * @param t  the exception\n     * @return the exception as a string.\n     */\n    protected String toString(Throwable t) {\n        try (FastByteArrayOutputStream bout = new FastByteArrayOutputStream();\n                PrintWriter wrt = new PrintWriter(bout)) {\n            t.printStackTrace(wrt);\n            return bout.toString();\n        }\n    }\n\n    /**\n     * Gets the parameters.\n     * @return the parameters. Is never <tt>null</tt>.\n     */\n    public Map getParameters() {\n        return parameters;\n    }\n\n    /**\n     * Adds all the given parameters to this component's own parameters.\n     * @param params the parameters to add.\n     */\n    public void addAllParameters(Map params) {\n        parameters.putAll(params);\n    }\n\n    /**\n     * Adds the given key and value to this component's own parameter.\n     * <br>\n     * If the provided key is <tt>null</tt> nothing happens.\n     * If the provided value is <tt>null</tt> any existing parameter with\n     * the given key name is removed.\n     * @param key  the key of the new parameter to add.\n     * @param value the value associated with the key.\n     */\n    public void addParameter(String key, Object value) {\n        if (key != null) {\n            Map params = getParameters();\n\n            if (value == null) {\n                params.remove(key);\n            } else {\n                params.put(key, value);\n            }\n        }\n    }\n\n    /**\n     * Overwrite to set if body should be used.\n     * @return always false for this component.\n     */\n    public boolean usesBody() {\n        return false;\n    }\n\n    /**\n     * Checks if provided name is a valid tag's attribute\n     *\n     * @param attrName String name of attribute\n     * @return true if attribute with the same name was already defined\n     */\n    public boolean isValidTagAttribute(String attrName) {\n        return getStandardAttributes().contains(attrName);\n    }\n\n    /**\n     * If needed caches all methods annotated by given annotation to avoid further scans\n     *\n     * @return list of attributes\n     */\n    protected Collection<String> getStandardAttributes() {\n        Class clz = getClass();\n        Collection<String> standardAttributes = standardAttributesMap.get(clz);\n        if (standardAttributes == null) {\n            Collection<Method> methods = AnnotationUtils.getAnnotatedMethods(clz, StrutsTagAttribute.class);\n            standardAttributes = new HashSet<>(methods.size());\n            for(Method m : methods) {\n                standardAttributes.add(StringUtils.uncapitalize(m.getName().substring(3)));\n            }\n            standardAttributesMap.putIfAbsent(clz, standardAttributes);\n        }\n        return standardAttributes;\n    }\n\n}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Object findValue(String expr, Class toType) {\n        if (altSyntax() && toType == String.class) {\n        \treturn TextParseUtil.translateVariables('%', expr, stack);\n        } else {\n            expr = stripExpressionIfAltSyntax(expr);\n\n            return getStack().findValue(expr, toType, throwExceptionOnELFailure);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Object findValue(String expr, Class toType) {\n        if (altSyntax() && toType == String.class) {\n            if (ComponentUtils.containsExpression(expr)) {\n                return TextParseUtil.translateVariables('%', expr, stack);\n            } else {\n                return expr;\n            }\n        } else {\n            expr = stripExpressionIfAltSyntax(expr);\n\n            return getStack().findValue(expr, toType, throwExceptionOnELFailure);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void testTranslateVariablesRecursive() {\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        stack.push(new HashMap<String, Object>() {{ put(\"foo\", \"${1+1}\"); }});\n\n        Object s = TextParseUtil.translateVariables('$', \"foo: ${foo}\", stack, String.class, null, 2);\n        assertEquals(\"foo: 2\", s);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void testTranslateVariablesRecursive() {\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        stack.push(new HashMap<String, Object>() {{ put(\"foo\", \"${1+1}\"); put(\"bar\", \"${${1+2}}\"); }});\n\n        Object s = TextParseUtil.translateVariables('$', \"foo: ${foo}\", stack, String.class, null, 2);\n        assertEquals(\"foo: 2\", s);\n\n        s = TextParseUtil.translateVariables('$', \"foo: ${bar}\", stack, String.class, null, 1);\n        assertEquals(\"foo: ${${1+2}}\", s);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Container createBootstrapContainer(List<ContainerProvider> providers) {\n        ContainerBuilder builder = new ContainerBuilder();\n        boolean fmFactoryRegistered = false;\n        for (ContainerProvider provider : providers) {\n            if (provider instanceof FileManagerProvider) {\n                provider.register(builder, null);\n            }\n            if (provider instanceof FileManagerFactoryProvider) {\n                provider.register(builder, null);\n                fmFactoryRegistered = true;\n            }\n        }\n        builder.factory(ObjectFactory.class, Scope.SINGLETON);\n        builder.factory(FileManager.class, \"system\", DefaultFileManager.class, Scope.SINGLETON);\n        if (!fmFactoryRegistered) {\n            builder.factory(FileManagerFactory.class, DefaultFileManagerFactory.class, Scope.SINGLETON);\n        }\n        builder.factory(ReflectionProvider.class, OgnlReflectionProvider.class, Scope.SINGLETON);\n        builder.factory(ValueStackFactory.class, OgnlValueStackFactory.class, Scope.SINGLETON);\n\n        builder.factory(XWorkConverter.class, Scope.SINGLETON);\n        builder.factory(ConversionPropertiesProcessor.class, DefaultConversionPropertiesProcessor.class, Scope.SINGLETON);\n        builder.factory(ConversionFileProcessor.class, DefaultConversionFileProcessor.class, Scope.SINGLETON);\n        builder.factory(ConversionAnnotationProcessor.class, DefaultConversionAnnotationProcessor.class, Scope.SINGLETON);\n        builder.factory(TypeConverterCreator.class, DefaultTypeConverterCreator.class, Scope.SINGLETON);\n        builder.factory(TypeConverterHolder.class, DefaultTypeConverterHolder.class, Scope.SINGLETON);\n\n        builder.factory(XWorkBasicConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.COLLECTION_CONVERTER,  CollectionConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.ARRAY_CONVERTER, ArrayConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.DATE_CONVERTER, DateConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.NUMBER_CONVERTER,  NumberConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.STRING_CONVERTER, StringConverter.class, Scope.SINGLETON);\n        builder.factory(TextProvider.class, \"system\", DefaultTextProvider.class, Scope.SINGLETON);\n        builder.factory(ObjectTypeDeterminer.class, DefaultObjectTypeDeterminer.class, Scope.SINGLETON);\n        builder.factory(PropertyAccessor.class, CompoundRoot.class.getName(), CompoundRootAccessor.class, Scope.SINGLETON);\n        builder.factory(OgnlUtil.class, Scope.SINGLETON);\n        builder.constant(XWorkConstants.DEV_MODE, \"false\");\n        builder.constant(XWorkConstants.LOG_MISSING_PROPERTIES, \"false\");\n        builder.constant(XWorkConstants.RELOAD_XML_CONFIGURATION, \"false\");\n        return builder.create(true);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Container createBootstrapContainer(List<ContainerProvider> providers) {\n        ContainerBuilder builder = new ContainerBuilder();\n        boolean fmFactoryRegistered = false;\n        for (ContainerProvider provider : providers) {\n            if (provider instanceof FileManagerProvider) {\n                provider.register(builder, null);\n            }\n            if (provider instanceof FileManagerFactoryProvider) {\n                provider.register(builder, null);\n                fmFactoryRegistered = true;\n            }\n        }\n        builder.factory(ObjectFactory.class, Scope.SINGLETON);\n        builder.factory(FileManager.class, \"system\", DefaultFileManager.class, Scope.SINGLETON);\n        if (!fmFactoryRegistered) {\n            builder.factory(FileManagerFactory.class, DefaultFileManagerFactory.class, Scope.SINGLETON);\n        }\n        builder.factory(ReflectionProvider.class, OgnlReflectionProvider.class, Scope.SINGLETON);\n        builder.factory(ValueStackFactory.class, OgnlValueStackFactory.class, Scope.SINGLETON);\n\n        builder.factory(XWorkConverter.class, Scope.SINGLETON);\n        builder.factory(ConversionPropertiesProcessor.class, DefaultConversionPropertiesProcessor.class, Scope.SINGLETON);\n        builder.factory(ConversionFileProcessor.class, DefaultConversionFileProcessor.class, Scope.SINGLETON);\n        builder.factory(ConversionAnnotationProcessor.class, DefaultConversionAnnotationProcessor.class, Scope.SINGLETON);\n        builder.factory(TypeConverterCreator.class, DefaultTypeConverterCreator.class, Scope.SINGLETON);\n        builder.factory(TypeConverterHolder.class, DefaultTypeConverterHolder.class, Scope.SINGLETON);\n\n        builder.factory(XWorkBasicConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.COLLECTION_CONVERTER,  CollectionConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.ARRAY_CONVERTER, ArrayConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.DATE_CONVERTER, DateConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.NUMBER_CONVERTER,  NumberConverter.class, Scope.SINGLETON);\n        builder.factory(TypeConverter.class, XWorkConstants.STRING_CONVERTER, StringConverter.class, Scope.SINGLETON);\n        builder.factory(TextProvider.class, \"system\", DefaultTextProvider.class, Scope.SINGLETON);\n        builder.factory(ObjectTypeDeterminer.class, DefaultObjectTypeDeterminer.class, Scope.SINGLETON);\n        builder.factory(PropertyAccessor.class, CompoundRoot.class.getName(), CompoundRootAccessor.class, Scope.SINGLETON);\n        builder.factory(OgnlUtil.class, Scope.SINGLETON);\n        builder.constant(XWorkConstants.DEV_MODE, \"false\");\n        builder.constant(XWorkConstants.LOG_MISSING_PROPERTIES, \"false\");\n        builder.constant(XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION, \"false\");\n        builder.constant(XWorkConstants.RELOAD_XML_CONFIGURATION, \"false\");\n        return builder.create(true);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Object evaluate(char[] openChars, String expression, TextParseUtil.ParsedValueEvaluator evaluator, int maxLoopCount) {\n        // deal with the \"pure\" expressions first!\n        //expression = expression.trim();\n        Object result = expression;\n        for (char open : openChars) {\n            int loopCount = 1;\n            int pos = 0;\n\n            //this creates an implicit StringBuffer and shouldn't be used in the inner loop\n            final String lookupChars = open + \"{\";\n\n            while (true) {\n                int start = expression.indexOf(lookupChars, pos);\n                if (start == -1) {\n                    pos = 0;\n                    loopCount++;\n                    start = expression.indexOf(lookupChars);\n                }\n                if (loopCount > maxLoopCount) {\n                    // translateVariables prevent infinite loop / expression recursive evaluation\n                    break;\n                }\n                int length = expression.length();\n                int x = start + 2;\n                int end;\n                char c;\n                int count = 1;\n                while (start != -1 && x < length && count != 0) {\n                    c = expression.charAt(x++);\n                    if (c == '{') {\n                        count++;\n                    } else if (c == '}') {\n                        count--;\n                    }\n                }\n                end = x - 1;\n\n                if ((start != -1) && (end != -1) && (count == 0)) {\n                    String var = expression.substring(start + 2, end);\n\n                    Object o = evaluator.evaluate(var);\n\n                    String left = expression.substring(0, start);\n                    String right = expression.substring(end + 1);\n                    String middle = null;\n                    if (o != null) {\n                        middle = o.toString();\n                        if (StringUtils.isEmpty(left)) {\n                            result = o;\n                        } else {\n                            result = left.concat(middle);\n                        }\n\n                        if (StringUtils.isNotEmpty(right)) {\n                            result = result.toString().concat(right);\n                        }\n\n                        expression = left.concat(middle).concat(right);\n                    } else {\n                        // the variable doesn't exist, so don't display anything\n                        expression = left.concat(right);\n                        result = expression;\n                    }\n                    pos = (left != null && left.length() > 0 ? left.length() - 1: 0) +\n                            (middle != null && middle.length() > 0 ? middle.length() - 1: 0) +\n                            1;\n                    pos = Math.max(pos, 1);\n                } else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
    "is_vulnerable": true
  },
  {
    "function_code": "public Object evaluate(char[] openChars, String expression, TextParseUtil.ParsedValueEvaluator evaluator, int maxLoopCount) {\n        // deal with the \"pure\" expressions first!\n        //expression = expression.trim();\n        Object result = expression;\n        int pos = 0;\n\n        for (char open : openChars) {\n            int loopCount = 1;\n            //this creates an implicit StringBuffer and shouldn't be used in the inner loop\n            final String lookupChars = open + \"{\";\n\n            while (true) {\n                int start = expression.indexOf(lookupChars, pos);\n                if (start == -1) {\n                    loopCount++;\n                    start = expression.indexOf(lookupChars);\n                }\n                if (loopCount > maxLoopCount) {\n                    // translateVariables prevent infinite loop / expression recursive evaluation\n                    break;\n                }\n                int length = expression.length();\n                int x = start + 2;\n                int end;\n                char c;\n                int count = 1;\n                while (start != -1 && x < length && count != 0) {\n                    c = expression.charAt(x++);\n                    if (c == '{') {\n                        count++;\n                    } else if (c == '}') {\n                        count--;\n                    }\n                }\n                end = x - 1;\n\n                if ((start != -1) && (end != -1) && (count == 0)) {\n                    String var = expression.substring(start + 2, end);\n\n                    Object o = evaluator.evaluate(var);\n\n                    String left = expression.substring(0, start);\n                    String right = expression.substring(end + 1);\n                    String middle = null;\n                    if (o != null) {\n                        middle = o.toString();\n                        if (StringUtils.isEmpty(left)) {\n                            result = o;\n                        } else {\n                            result = left.concat(middle);\n                        }\n\n                        if (StringUtils.isNotEmpty(right)) {\n                            result = result.toString().concat(right);\n                        }\n\n                        expression = left.concat(middle).concat(right);\n                    } else {\n                        // the variable doesn't exist, so don't display anything\n                        expression = left.concat(right);\n                        result = expression;\n                    }\n                    pos = (left != null && left.length() > 0 ? left.length() - 1: 0) +\n                            (middle != null && middle.length() > 0 ? middle.length() - 1: 0) +\n                            1;\n                    pos = Math.max(pos, 1);\n                } else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setAcceptParamNames(String commaDelim) {\n        Collection<String> acceptPatterns = ArrayUtils.asCollection(commaDelim);\n        if (acceptPatterns != null) {\n            acceptParams = new HashSet<Pattern>();\n            for (String pattern : acceptPatterns) {\n                acceptParams.add(Pattern.compile(pattern));\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setAcceptParamNames(String commaDelim) {\n        Collection<String> acceptPatterns = ArrayUtils.asCollection(commaDelim);\n        if (acceptPatterns != null) {\n            acceptParams = new HashSet<Pattern>();\n            for (String pattern : acceptPatterns) {\n                acceptParams.add(Pattern.compile(pattern));\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean acceptableName(String name) {\n        return isAccepted(name) && !isExcluded(name);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean acceptableName(String name) {\n        return isWithinLengthLimit(name) && isAccepted(name)\n                && !isExcluded(name);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean isAccepted(String paramName) {\n        if (!this.acceptParams.isEmpty()) {\n            for (Pattern pattern : acceptParams) {\n                Matcher matcher = pattern.matcher(paramName);\n                if (matcher.matches()) {\n                    return true;\n                }\n            }\n            return false;\n        } else\n            return acceptedPattern.matcher(paramName).matches();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean isAccepted(String paramName) {\n        if (!this.acceptParams.isEmpty()) {\n            for (Pattern pattern : acceptParams) {\n                Matcher matcher = pattern.matcher(paramName);\n                if (matcher.matches()) {\n                    return true;\n                }\n            }\n            return false;\n        } else\n            return acceptedPattern.matcher(paramName).matches();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<PropertyPath>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.type, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n\n\t\tif (base.size() > 1000) {\n\t\t\tthrow new IllegalArgumentException(PARSE_DEPTH_EXCEEDED);\n\t\t}\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<PropertyPath>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.type, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setWorkDir(File workDir) {\n        this.loaderDir = new File(workDir, \"loader\");\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setWorkDir(File workDir) {\n        this.loaderDir = new File(workDir, \"loader\");\n        if (loaderDir == null) {\n            canonicalLoaderDir = null;\n        } else { \n            try {\n                canonicalLoaderDir = loaderDir.getCanonicalPath();\n                if (!canonicalLoaderDir.endsWith(File.separator)) {\n                    canonicalLoaderDir += File.separator;\n                }\n            } catch (IOException ioe) {\n                canonicalLoaderDir = null;\n            }\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected ResourceEntry findResourceInternal(String name, String path) {\n\n        if (!started) {\n            log.info(sm.getString(\"webappClassLoader.stopped\", name));\n            return null;\n        }\n\n        if ((name == null) || (path == null))\n            return null;\n\n        ResourceEntry entry = (ResourceEntry) resourceEntries.get(name);\n        if (entry != null)\n            return entry;\n\n        int contentLength = -1;\n        InputStream binaryStream = null;\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        Resource resource = null;\n\n        boolean fileNeedConvert = false;\n\n        for (i = 0; (entry == null) && (i < repositoriesLength); i++) {\n            try {\n\n                String fullPath = repositories[i] + path;\n\n                Object lookupResult = resources.lookup(fullPath);\n                if (lookupResult instanceof Resource) {\n                    resource = (Resource) lookupResult;\n                }\n\n                // Note : Not getting an exception here means the resource was\n                // found\n                entry = findResourceInternal(files[i], path);\n\n                ResourceAttributes attributes =\n                    (ResourceAttributes) resources.getAttributes(fullPath);\n                contentLength = (int) attributes.getContentLength();\n                entry.lastModified = attributes.getLastModified();\n\n                if (resource != null) {\n\n\n                    try {\n                        binaryStream = resource.streamContent();\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    if (needConvert) {\n                        if (path.endsWith(\".properties\")) {\n                            fileNeedConvert = true;\n                        }\n                    }\n\n                    // Register the full path for modification checking\n                    // Note: Only syncing on a 'constant' object is needed\n                    synchronized (allPermission) {\n\n                        int j;\n\n                        long[] result2 = \n                            new long[lastModifiedDates.length + 1];\n                        for (j = 0; j < lastModifiedDates.length; j++) {\n                            result2[j] = lastModifiedDates[j];\n                        }\n                        result2[lastModifiedDates.length] = entry.lastModified;\n                        lastModifiedDates = result2;\n\n                        String[] result = new String[paths.length + 1];\n                        for (j = 0; j < paths.length; j++) {\n                            result[j] = paths[j];\n                        }\n                        result[paths.length] = fullPath;\n                        paths = result;\n\n                    }\n\n                }\n\n            } catch (NamingException e) {\n            }\n        }\n\n        if ((entry == null) && (notFoundResources.containsKey(name)))\n            return null;\n\n        JarEntry jarEntry = null;\n\n        synchronized (jarFiles) {\n\n            if (!openJARs()) {\n                return null;\n            }\n            for (i = 0; (entry == null) && (i < jarFilesLength); i++) {\n\n                jarEntry = jarFiles[i].getJarEntry(path);\n\n                if (jarEntry != null) {\n\n                    entry = new ResourceEntry();\n                    try {\n                        entry.codeBase = getURL(jarRealFiles[i], false);\n                        String jarFakeUrl = getURI(jarRealFiles[i]).toString();\n                        jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + path;\n                        entry.source = new URL(jarFakeUrl);\n                        entry.lastModified = jarRealFiles[i].lastModified();\n                    } catch (MalformedURLException e) {\n                        return null;\n                    }\n                    contentLength = (int) jarEntry.getSize();\n                    try {\n                        entry.manifest = jarFiles[i].getManifest();\n                        binaryStream = jarFiles[i].getInputStream(jarEntry);\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    // Extract resources contained in JAR to the workdir\n                    if (antiJARLocking && !(path.endsWith(\".class\"))) {\n                        byte[] buf = new byte[1024];\n                        File resourceFile = new File\n                            (loaderDir, jarEntry.getName());\n                        if (!resourceFile.exists()) {\n                            Enumeration entries = jarFiles[i].entries();\n                            while (entries.hasMoreElements()) {\n                                JarEntry jarEntry2 = \n                                    (JarEntry) entries.nextElement();\n                                if (!(jarEntry2.isDirectory()) \n                                    && (!jarEntry2.getName().endsWith\n                                        (\".class\"))) {\n                                    resourceFile = new File\n                                        (loaderDir, jarEntry2.getName());\n                                    resourceFile.getParentFile().mkdirs();\n                                    FileOutputStream os = null;\n                                    InputStream is = null;\n                                    try {\n                                        is = jarFiles[i].getInputStream\n                                            (jarEntry2);\n                                        os = new FileOutputStream\n                                            (resourceFile);\n                                        while (true) {\n                                            int n = is.read(buf);\n                                            if (n <= 0) {\n                                                break;\n                                            }\n                                            os.write(buf, 0, n);\n                                        }\n                                    } catch (IOException e) {\n                                        // Ignore\n                                    } finally {\n                                        try {\n                                            if (is != null) {\n                                                is.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                        try {\n                                            if (os != null) {\n                                                os.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n            }\n\n            if (entry == null) {\n                synchronized (notFoundResources) {\n                    notFoundResources.put(name, name);\n                }\n                return null;\n            }\n\n            if (binaryStream != null) {\n\n                byte[] binaryContent = new byte[contentLength];\n\n                int pos = 0;\n                try {\n\n                    while (true) {\n                        int n = binaryStream.read(binaryContent, pos,\n                                                  binaryContent.length - pos);\n                        if (n <= 0)\n                            break;\n                        pos += n;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\"webappClassLoader.readError\", name), e);\n                    return null;\n                } finally {\n                    try {\n                        binaryStream.close();\n                    } catch (IOException e) {}\n                }\n                if (fileNeedConvert) {\n                    String str = new String(binaryContent,0,pos);\n                    try {\n                        binaryContent = str.getBytes(\"UTF-8\");\n                    } catch (Exception e) {\n                        return null;\n                    }\n                }\n                entry.binaryContent = binaryContent;\n\n                // The certificates are only available after the JarEntry \n                // associated input stream has been fully read\n                if (jarEntry != null) {\n                    entry.certificates = jarEntry.getCertificates();\n                }\n\n            }\n\n        }\n\n        // Add the entry in the local resource repository\n        synchronized (resourceEntries) {\n            // Ensures that all the threads which may be in a race to load\n            // a particular class all end up with the same ResourceEntry\n            // instance\n            ResourceEntry entry2 = (ResourceEntry) resourceEntries.get(name);\n            if (entry2 == null) {\n                resourceEntries.put(name, entry);\n            } else {\n                entry = entry2;\n            }\n        }\n\n        return entry;\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected ResourceEntry findResourceInternal(String name, String path) {\n\n        if (!started) {\n            log.info(sm.getString(\"webappClassLoader.stopped\", name));\n            return null;\n        }\n\n        if ((name == null) || (path == null))\n            return null;\n\n        ResourceEntry entry = (ResourceEntry) resourceEntries.get(name);\n        if (entry != null)\n            return entry;\n\n        int contentLength = -1;\n        InputStream binaryStream = null;\n\n        int jarFilesLength = jarFiles.length;\n        int repositoriesLength = repositories.length;\n\n        int i;\n\n        Resource resource = null;\n\n        boolean fileNeedConvert = false;\n\n        for (i = 0; (entry == null) && (i < repositoriesLength); i++) {\n            try {\n\n                String fullPath = repositories[i] + path;\n\n                Object lookupResult = resources.lookup(fullPath);\n                if (lookupResult instanceof Resource) {\n                    resource = (Resource) lookupResult;\n                }\n\n                // Note : Not getting an exception here means the resource was\n                // found\n                entry = findResourceInternal(files[i], path);\n\n                ResourceAttributes attributes =\n                    (ResourceAttributes) resources.getAttributes(fullPath);\n                contentLength = (int) attributes.getContentLength();\n                entry.lastModified = attributes.getLastModified();\n\n                if (resource != null) {\n\n\n                    try {\n                        binaryStream = resource.streamContent();\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    if (needConvert) {\n                        if (path.endsWith(\".properties\")) {\n                            fileNeedConvert = true;\n                        }\n                    }\n\n                    // Register the full path for modification checking\n                    // Note: Only syncing on a 'constant' object is needed\n                    synchronized (allPermission) {\n\n                        int j;\n\n                        long[] result2 = \n                            new long[lastModifiedDates.length + 1];\n                        for (j = 0; j < lastModifiedDates.length; j++) {\n                            result2[j] = lastModifiedDates[j];\n                        }\n                        result2[lastModifiedDates.length] = entry.lastModified;\n                        lastModifiedDates = result2;\n\n                        String[] result = new String[paths.length + 1];\n                        for (j = 0; j < paths.length; j++) {\n                            result[j] = paths[j];\n                        }\n                        result[paths.length] = fullPath;\n                        paths = result;\n\n                    }\n\n                }\n\n            } catch (NamingException e) {\n            }\n        }\n\n        if ((entry == null) && (notFoundResources.containsKey(name)))\n            return null;\n\n        JarEntry jarEntry = null;\n\n        synchronized (jarFiles) {\n\n            if (!openJARs()) {\n                return null;\n            }\n            for (i = 0; (entry == null) && (i < jarFilesLength); i++) {\n\n                jarEntry = jarFiles[i].getJarEntry(path);\n\n                if (jarEntry != null) {\n\n                    entry = new ResourceEntry();\n                    try {\n                        entry.codeBase = getURL(jarRealFiles[i], false);\n                        String jarFakeUrl = getURI(jarRealFiles[i]).toString();\n                        jarFakeUrl = \"jar:\" + jarFakeUrl + \"!/\" + path;\n                        entry.source = new URL(jarFakeUrl);\n                        entry.lastModified = jarRealFiles[i].lastModified();\n                    } catch (MalformedURLException e) {\n                        return null;\n                    }\n                    contentLength = (int) jarEntry.getSize();\n                    try {\n                        entry.manifest = jarFiles[i].getManifest();\n                        binaryStream = jarFiles[i].getInputStream(jarEntry);\n                    } catch (IOException e) {\n                        return null;\n                    }\n\n                    // Extract resources contained in JAR to the workdir\n                    if (antiJARLocking && !(path.endsWith(\".class\"))) {\n                        byte[] buf = new byte[1024];\n                        File resourceFile = new File\n                            (loaderDir, jarEntry.getName());\n                        if (!resourceFile.exists()) {\n                            Enumeration entries = jarFiles[i].entries();\n                            while (entries.hasMoreElements()) {\n                                JarEntry jarEntry2 = \n                                    (JarEntry) entries.nextElement();\n                                if (!(jarEntry2.isDirectory()) \n                                    && (!jarEntry2.getName().endsWith\n                                        (\".class\"))) {\n                                    resourceFile = new File\n                                        (loaderDir, jarEntry2.getName());\n                                    try {\n                                        if (!resourceFile.getCanonicalPath().startsWith(\n                                                canonicalLoaderDir)) {\n                                            throw new IllegalArgumentException(\n                                                    sm.getString(\"webappClassLoader.illegalJarPath\",\n                                                            jarEntry2.getName()));\n                                        }\n                                    } catch (IOException ioe) {\n                                        throw new IllegalArgumentException(\n                                                sm.getString(\"webappClassLoader.validationErrorJarPath\",\n                                                        jarEntry2.getName()), ioe);\n                                    }\n                                    resourceFile.getParentFile().mkdirs();\n                                    FileOutputStream os = null;\n                                    InputStream is = null;\n                                    try {\n                                        is = jarFiles[i].getInputStream\n                                            (jarEntry2);\n                                        os = new FileOutputStream\n                                            (resourceFile);\n                                        while (true) {\n                                            int n = is.read(buf);\n                                            if (n <= 0) {\n                                                break;\n                                            }\n                                            os.write(buf, 0, n);\n                                        }\n                                    } catch (IOException e) {\n                                        // Ignore\n                                    } finally {\n                                        try {\n                                            if (is != null) {\n                                                is.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                        try {\n                                            if (os != null) {\n                                                os.close();\n                                            }\n                                        } catch (IOException e) {\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                }\n\n            }\n\n            if (entry == null) {\n                synchronized (notFoundResources) {\n                    notFoundResources.put(name, name);\n                }\n                return null;\n            }\n\n            if (binaryStream != null) {\n\n                byte[] binaryContent = new byte[contentLength];\n\n                int pos = 0;\n                try {\n\n                    while (true) {\n                        int n = binaryStream.read(binaryContent, pos,\n                                                  binaryContent.length - pos);\n                        if (n <= 0)\n                            break;\n                        pos += n;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\"webappClassLoader.readError\", name), e);\n                    return null;\n                } finally {\n                    try {\n                        binaryStream.close();\n                    } catch (IOException e) {}\n                }\n                if (fileNeedConvert) {\n                    String str = new String(binaryContent,0,pos);\n                    try {\n                        binaryContent = str.getBytes(\"UTF-8\");\n                    } catch (Exception e) {\n                        return null;\n                    }\n                }\n                entry.binaryContent = binaryContent;\n\n                // The certificates are only available after the JarEntry \n                // associated input stream has been fully read\n                if (jarEntry != null) {\n                    entry.certificates = jarEntry.getCertificates();\n                }\n\n            }\n\n        }\n\n        // Add the entry in the local resource repository\n        synchronized (resourceEntries) {\n            // Ensures that all the threads which may be in a race to load\n            // a particular class all end up with the same ResourceEntry\n            // instance\n            ResourceEntry entry2 = (ResourceEntry) resourceEntries.get(name);\n            if (entry2 == null) {\n                resourceEntries.put(name, entry);\n            } else {\n                entry = entry2;\n            }\n        }\n\n        return entry;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected String parseUsername(String authorization) {\n\n        //System.out.println(\"Authorization token : \" + authorization);\n        // Validate the authorization credentials format\n        if (authorization == null)\n            return (null);\n        if (!authorization.startsWith(\"Digest \"))\n            return (null);\n        authorization = authorization.substring(7).trim();\n\n        StringTokenizer commaTokenizer =\n            new StringTokenizer(authorization, \",\");\n\n        while (commaTokenizer.hasMoreTokens()) {\n            String currentToken = commaTokenizer.nextToken();\n            int equalSign = currentToken.indexOf('=');\n            if (equalSign < 0)\n                return null;\n            String currentTokenName =\n                currentToken.substring(0, equalSign).trim();\n            String currentTokenValue =\n                currentToken.substring(equalSign + 1).trim();\n            if (\"username\".equals(currentTokenName))\n                return (removeQuotes(currentTokenValue));\n        }\n\n        return (null);\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected String parseUsername(String authorization) {\n\n        // Validate the authorization credentials format\n        if (authorization == null)\n            return (null);\n        if (!authorization.startsWith(\"Digest \"))\n            return (null);\n        authorization = authorization.substring(7).trim();\n\n        StringTokenizer commaTokenizer =\n            new StringTokenizer(authorization, \",\");\n\n        while (commaTokenizer.hasMoreTokens()) {\n            String currentToken = commaTokenizer.nextToken();\n            int equalSign = currentToken.indexOf('=');\n            if (equalSign < 0)\n                return null;\n            String currentTokenName =\n                currentToken.substring(0, equalSign).trim();\n            String currentTokenValue =\n                currentToken.substring(equalSign + 1).trim();\n            if (\"username\".equals(currentTokenName))\n                return (removeQuotes(currentTokenValue));\n        }\n\n        return (null);\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void setAuthenticateHeader(Request request,\n                                         Response response,\n                                         LoginConfig config,\n                                         String nOnce) {\n\n        // Get the realm name\n        String realmName = config.getRealmName();\n        if (realmName == null)\n            realmName = REALM_NAME;\n\n        byte[] buffer = null;\n        synchronized (md5Helper) {\n            buffer = md5Helper.digest(nOnce.getBytes());\n        }\n\n        String authenticateHeader = \"Digest realm=\\\"\" + realmName + \"\\\", \"\n            +  \"qop=\\\"auth\\\", nonce=\\\"\" + nOnce + \"\\\", \" + \"opaque=\\\"\"\n            + md5Encoder.encode(buffer) + \"\\\"\";\n        response.setHeader(\"WWW-Authenticate\", authenticateHeader);\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void setAuthenticateHeader(Request request,\n                                         Response response,\n                                         LoginConfig config,\n                                         String nonce,\n                                         boolean isNonceStale) {\n\n        // Get the realm name\n        String realmName = config.getRealmName();\n        if (realmName == null)\n            realmName = REALM_NAME;\n\n        String authenticateHeader;\n        if (isNonceStale) {\n            authenticateHeader = \"Digest realm=\\\"\" + realmName + \"\\\", \" +\n            \"qop=\\\"\" + QOP + \"\\\", nonce=\\\"\" + nonce + \"\\\", \" + \"opaque=\\\"\" +\n            getOpaque() + \"\\\", stale=true\";\n        } else {\n            authenticateHeader = \"Digest realm=\\\"\" + realmName + \"\\\", \" +\n            \"qop=\\\"\" + QOP + \"\\\", nonce=\\\"\" + nonce + \"\\\", \" + \"opaque=\\\"\" +\n            getOpaque() + \"\\\"\";\n        }\n\n        response.setHeader(\"WWW-Authenticate\", authenticateHeader);\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void postWorkDirectory() {\n\n        // Acquire (or calculate) the work directory path\n        String workDir = getWorkDir();\n        if (workDir == null || workDir.length() == 0) {\n\n            // Retrieve our parent (normally a host) name\n            String hostName = null;\n            String engineName = null;\n            String hostWorkDir = null;\n            Container parentHost = getParent();\n            if (parentHost != null) {\n                hostName = parentHost.getName();\n                if (parentHost instanceof StandardHost) {\n                    hostWorkDir = ((StandardHost)parentHost).getWorkDir();\n                }\n                Container parentEngine = parentHost.getParent();\n                if (parentEngine != null) {\n                   engineName = parentEngine.getName();\n                }\n            }\n            if ((hostName == null) || (hostName.length() < 1))\n                hostName = \"_\";\n            if ((engineName == null) || (engineName.length() < 1))\n                engineName = \"_\";\n\n            String temp = getPath();\n            if (temp.startsWith(\"/\"))\n                temp = temp.substring(1);\n            temp = temp.replace('/', '_');\n            temp = temp.replace('\\\\', '_');\n            if (temp.length() < 1)\n                temp = \"_\";\n            if (hostWorkDir != null ) {\n                workDir = hostWorkDir + File.separator + temp;\n            } else {\n                workDir = \"work\" + File.separator + engineName +\n                    File.separator + hostName + File.separator + temp;\n            }\n            setWorkDir(workDir);\n        }\n\n        // Create this directory if necessary\n        File dir = new File(workDir);\n        if (!dir.isAbsolute()) {\n            File catalinaHome = engineBase();\n            String catalinaHomePath = null;\n            try {\n                catalinaHomePath = catalinaHome.getCanonicalPath();\n                dir = new File(catalinaHomePath, workDir);\n            } catch (IOException e) {\n            }\n        }\n        dir.mkdirs();\n\n        // Set the appropriate servlet context attribute\n        getServletContext().setAttribute(Globals.WORK_DIR_ATTR, dir);\n        if (getServletContext() instanceof ApplicationContext)\n            ((ApplicationContext) getServletContext()).setAttributeReadOnly\n                (Globals.WORK_DIR_ATTR);\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void postWorkDirectory() {\n\n        // Acquire (or calculate) the work directory path\n        String workDir = getWorkDir();\n        if (workDir == null || workDir.length() == 0) {\n\n            // Retrieve our parent (normally a host) name\n            String hostName = null;\n            String engineName = null;\n            String hostWorkDir = null;\n            Container parentHost = getParent();\n            if (parentHost != null) {\n                hostName = parentHost.getName();\n                if (parentHost instanceof StandardHost) {\n                    hostWorkDir = ((StandardHost)parentHost).getWorkDir();\n                }\n                Container parentEngine = parentHost.getParent();\n                if (parentEngine != null) {\n                   engineName = parentEngine.getName();\n                }\n            }\n            if ((hostName == null) || (hostName.length() < 1))\n                hostName = \"_\";\n            if ((engineName == null) || (engineName.length() < 1))\n                engineName = \"_\";\n\n            String temp = getPath();\n            if (temp.startsWith(\"/\"))\n                temp = temp.substring(1);\n            temp = temp.replace('/', '_');\n            temp = temp.replace('\\\\', '_');\n            if (temp.length() < 1)\n                temp = \"_\";\n            if (hostWorkDir != null ) {\n                workDir = hostWorkDir + File.separator + temp;\n            } else {\n                workDir = \"work\" + File.separator + engineName +\n                    File.separator + hostName + File.separator + temp;\n            }\n            setWorkDir(workDir);\n        }\n\n        // Create this directory if necessary\n        File dir = new File(workDir);\n        if (!dir.isAbsolute()) {\n            File catalinaHome = engineBase();\n            String catalinaHomePath = null;\n            try {\n                catalinaHomePath = catalinaHome.getCanonicalPath();\n                dir = new File(catalinaHomePath, workDir);\n            } catch (IOException e) {\n            }\n        }\n        dir.mkdirs();\n\n        // Set the appropriate servlet context attribute\n        if (context == null) {\n            getServletContext();\n        }\n        context.setAttribute(Globals.WORK_DIR_ATTR, dir);\n        context.setAttributeReadOnly(Globals.WORK_DIR_ATTR);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setAttribute(String name, Object value) {\n\t\n        // Name cannot be null\n        if (name == null)\n            throw new IllegalArgumentException\n                (sm.getString(\"coyoteRequest.setAttribute.namenull\"));\n\n        // Null value is the same as removeAttribute()\n        if (value == null) {\n            removeAttribute(name);\n            return;\n        }\n\n        if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {\n            dispatcherType = value;\n            return;\n        } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {\n            requestDispatcherPath = value;\n            return;\n        }\n\n        Object oldValue = null;\n        boolean replaced = false;\n\n        // Add or replace the specified attribute\n        // Check for read only attribute\n        // requests are per thread so synchronization unnecessary\n        if (readOnlyAttributes.containsKey(name)) {\n            return;\n        }\n\n        oldValue = attributes.put(name, value);\n        if (oldValue != null) {\n            replaced = true;\n        }\n\n        // Pass special attributes to the native layer\n        if (name.startsWith(\"org.apache.tomcat.\")) {\n            coyoteRequest.setAttribute(name, value);\n        }\n        \n        // Notify interested application event listeners\n        Object listeners[] = context.getApplicationEventListeners();\n        if ((listeners == null) || (listeners.length == 0))\n            return;\n        ServletRequestAttributeEvent event = null;\n        if (replaced)\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, oldValue);\n        else\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, value);\n\n        for (int i = 0; i < listeners.length; i++) {\n            if (!(listeners[i] instanceof ServletRequestAttributeListener))\n                continue;\n            ServletRequestAttributeListener listener =\n                (ServletRequestAttributeListener) listeners[i];\n            try {\n                if (replaced) {\n                    listener.attributeReplaced(event);\n                } else {\n                    listener.attributeAdded(event);\n                }\n            } catch (Throwable t) {\n                context.getLogger().error(sm.getString(\"coyoteRequest.attributeEvent\"), t);\n                // Error valve will pick this execption up and display it to user\n                attributes.put( Globals.EXCEPTION_ATTR, t );\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setAttribute(String name, Object value) {\n\t\n        // Name cannot be null\n        if (name == null)\n            throw new IllegalArgumentException\n                (sm.getString(\"coyoteRequest.setAttribute.namenull\"));\n\n        // Null value is the same as removeAttribute()\n        if (value == null) {\n            removeAttribute(name);\n            return;\n        }\n\n        if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {\n            dispatcherType = value;\n            return;\n        } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {\n            requestDispatcherPath = value;\n            return;\n        }\n\n        if (System.getSecurityManager() != null &&\n                name.equals(\"org.apache.tomcat.sendfile.filename\")) {\n            // Use the canonical file name to avoid any possible symlink and\n            // relative path issues\n            String canonicalPath;\n            try {\n                canonicalPath = new File(value.toString()).getCanonicalPath();\n            } catch (IOException e) {\n                SecurityException se = new SecurityException(sm.getString(\n                        \"coyoteRequest.sendfileNotCanonical\", value));\n                se.initCause(e);\n                throw se;\n            }\n            // Sendfile is performed in Tomcat's security context so need to\n            // check if the web app is permitted to access the file while still\n            // in the web app's security context\n            System.getSecurityManager().checkRead(canonicalPath);\n            // Update the value so the canonical path is used\n            value = canonicalPath;\n        }\n\n        Object oldValue = null;\n        boolean replaced = false;\n\n        // Add or replace the specified attribute\n        // Check for read only attribute\n        // requests are per thread so synchronization unnecessary\n        if (readOnlyAttributes.containsKey(name)) {\n            return;\n        }\n\n        oldValue = attributes.put(name, value);\n        if (oldValue != null) {\n            replaced = true;\n        }\n\n        // Pass special attributes to the native layer\n        if (name.startsWith(\"org.apache.tomcat.\")) {\n            coyoteRequest.setAttribute(name, value);\n        }\n        \n        // Notify interested application event listeners\n        Object listeners[] = context.getApplicationEventListeners();\n        if ((listeners == null) || (listeners.length == 0))\n            return;\n        ServletRequestAttributeEvent event = null;\n        if (replaced)\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, oldValue);\n        else\n            event =\n                new ServletRequestAttributeEvent(context.getServletContext(),\n                                                 getRequest(), name, value);\n\n        for (int i = 0; i < listeners.length; i++) {\n            if (!(listeners[i] instanceof ServletRequestAttributeListener))\n                continue;\n            ServletRequestAttributeListener listener =\n                (ServletRequestAttributeListener) listeners[i];\n            try {\n                if (replaced) {\n                    listener.attributeReplaced(event);\n                } else {\n                    listener.attributeAdded(event);\n                }\n            } catch (Throwable t) {\n                context.getLogger().error(sm.getString(\"coyoteRequest.attributeEvent\"), t);\n                // Error valve will pick this execption up and display it to user\n                attributes.put( Globals.EXCEPTION_ATTR, t );\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Mapper getMapper() {\n\n         return (mapper);\n\n     }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Mapper getMapper() {\n        return (mapper);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean checkSendfile(HttpServletRequest request,\n                                  HttpServletResponse response,\n                                  CacheEntry entry,\n                                  long length, Range range) {\n        if ((sendfileSize > 0)\n            && (entry.resource != null)\n            && ((length > sendfileSize) || (entry.resource.getContent() == null))\n            && (entry.attributes.getCanonicalPath() != null)\n            && (Boolean.TRUE == request.getAttribute(\"org.apache.tomcat.sendfile.support\"))\n            && (request.getClass().getName().equals(\"org.apache.catalina.connector.RequestFacade\"))\n            && (response.getClass().getName().equals(\"org.apache.catalina.connector.ResponseFacade\"))) {\n            request.setAttribute(\"org.apache.tomcat.sendfile.filename\", entry.attributes.getCanonicalPath());\n            if (range == null) {\n                request.setAttribute(\"org.apache.tomcat.sendfile.start\", new Long(0L));\n                request.setAttribute(\"org.apache.tomcat.sendfile.end\", new Long(length));\n            } else {\n                request.setAttribute(\"org.apache.tomcat.sendfile.start\", new Long(range.start));\n                request.setAttribute(\"org.apache.tomcat.sendfile.end\", new Long(range.end + 1));\n            }\n            request.setAttribute(\"org.apache.tomcat.sendfile.token\", this);\n            return true;\n        } else {\n            return false;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean checkSendfile(HttpServletRequest request,\n                                  HttpServletResponse response,\n                                  CacheEntry entry,\n                                  long length, Range range) {\n        if ((sendfileSize > 0)\n            && (entry.resource != null)\n            && ((length > sendfileSize) || (entry.resource.getContent() == null))\n            && (entry.attributes.getCanonicalPath() != null)\n            && (Boolean.TRUE == request.getAttribute(\"org.apache.tomcat.sendfile.support\"))\n            && (request.getClass().getName().equals(\"org.apache.catalina.connector.RequestFacade\"))\n            && (response.getClass().getName().equals(\"org.apache.catalina.connector.ResponseFacade\"))) {\n            request.setAttribute(\"org.apache.tomcat.sendfile.filename\", entry.attributes.getCanonicalPath());\n            if (range == null) {\n                request.setAttribute(\"org.apache.tomcat.sendfile.start\", new Long(0L));\n                request.setAttribute(\"org.apache.tomcat.sendfile.end\", new Long(length));\n            } else {\n                request.setAttribute(\"org.apache.tomcat.sendfile.start\", new Long(range.start));\n                request.setAttribute(\"org.apache.tomcat.sendfile.end\", new Long(range.end + 1));\n            }\n            return true;\n        } else {\n            return false;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "void stop() {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"contextConfig.stop\"));\n\n        int i;\n\n        // Removing children\n        Container[] children = context.findChildren();\n        for (i = 0; i < children.length; i++) {\n            context.removeChild(children[i]);\n        }\n\n        // Removing application parameters\n        /*\n        ApplicationParameter[] applicationParameters =\n            context.findApplicationParameters();\n        for (i = 0; i < applicationParameters.length; i++) {\n            context.removeApplicationParameter\n                (applicationParameters[i].getName());\n        }\n        */\n\n        // Removing security constraints\n        SecurityConstraint[] securityConstraints = context.findConstraints();\n        for (i = 0; i < securityConstraints.length; i++) {\n            context.removeConstraint(securityConstraints[i]);\n        }\n\n        // Removing Ejbs\n        /*\n        ContextEjb[] contextEjbs = context.findEjbs();\n        for (i = 0; i < contextEjbs.length; i++) {\n            context.removeEjb(contextEjbs[i].getName());\n        }\n        */\n\n        // Removing environments\n        /*\n        ContextEnvironment[] contextEnvironments = context.findEnvironments();\n        for (i = 0; i < contextEnvironments.length; i++) {\n            context.removeEnvironment(contextEnvironments[i].getName());\n        }\n        */\n\n        // Removing errors pages\n        ErrorPage[] errorPages = context.findErrorPages();\n        for (i = 0; i < errorPages.length; i++) {\n            context.removeErrorPage(errorPages[i]);\n        }\n\n        // Removing filter defs\n        FilterDef[] filterDefs = context.findFilterDefs();\n        for (i = 0; i < filterDefs.length; i++) {\n            context.removeFilterDef(filterDefs[i]);\n        }\n\n        // Removing filter maps\n        FilterMap[] filterMaps = context.findFilterMaps();\n        for (i = 0; i < filterMaps.length; i++) {\n            context.removeFilterMap(filterMaps[i]);\n        }\n\n        // Removing local ejbs\n        /*\n        ContextLocalEjb[] contextLocalEjbs = context.findLocalEjbs();\n        for (i = 0; i < contextLocalEjbs.length; i++) {\n            context.removeLocalEjb(contextLocalEjbs[i].getName());\n        }\n        */\n\n        // Removing Mime mappings\n        String[] mimeMappings = context.findMimeMappings();\n        for (i = 0; i < mimeMappings.length; i++) {\n            context.removeMimeMapping(mimeMappings[i]);\n        }\n\n        // Removing parameters\n        String[] parameters = context.findParameters();\n        for (i = 0; i < parameters.length; i++) {\n            context.removeParameter(parameters[i]);\n        }\n\n        // Removing resource env refs\n        /*\n        String[] resourceEnvRefs = context.findResourceEnvRefs();\n        for (i = 0; i < resourceEnvRefs.length; i++) {\n            context.removeResourceEnvRef(resourceEnvRefs[i]);\n        }\n        */\n\n        // Removing resource links\n        /*\n        ContextResourceLink[] contextResourceLinks =\n            context.findResourceLinks();\n        for (i = 0; i < contextResourceLinks.length; i++) {\n            context.removeResourceLink(contextResourceLinks[i].getName());\n        }\n        */\n\n        // Removing resources\n        /*\n        ContextResource[] contextResources = context.findResources();\n        for (i = 0; i < contextResources.length; i++) {\n            context.removeResource(contextResources[i].getName());\n        }\n        */\n\n        // Removing sercurity role\n        String[] securityRoles = context.findSecurityRoles();\n        for (i = 0; i < securityRoles.length; i++) {\n            context.removeSecurityRole(securityRoles[i]);\n        }\n\n        // Removing servlet mappings\n        String[] servletMappings = context.findServletMappings();\n        for (i = 0; i < servletMappings.length; i++) {\n            context.removeServletMapping(servletMappings[i]);\n        }\n\n        // FIXME : Removing status pages\n\n        // Removing taglibs\n        String[] taglibs = context.findTaglibs();\n        for (i = 0; i < taglibs.length; i++) {\n            context.removeTaglib(taglibs[i]);\n        }\n\n        // Removing welcome files\n        String[] welcomeFiles = context.findWelcomeFiles();\n        for (i = 0; i < welcomeFiles.length; i++) {\n            context.removeWelcomeFile(welcomeFiles[i]);\n        }\n\n        // Removing wrapper lifecycles\n        String[] wrapperLifecycles = context.findWrapperLifecycles();\n        for (i = 0; i < wrapperLifecycles.length; i++) {\n            context.removeWrapperLifecycle(wrapperLifecycles[i]);\n        }\n\n        // Removing wrapper listeners\n        String[] wrapperListeners = context.findWrapperListeners();\n        for (i = 0; i < wrapperListeners.length; i++) {\n            context.removeWrapperListener(wrapperListeners[i]);\n        }\n\n        // Remove (partially) folders and files created by antiLocking\n        Host host = (Host) context.getParent();\n        String appBase = host.getAppBase();\n        String docBase = context.getDocBase();\n        if ((docBase != null) && (originalDocBase != null)) {\n            File docBaseFile = new File(docBase);\n            if (!docBaseFile.isAbsolute()) {\n                docBaseFile = new File(appBase, docBase);\n            }\n            ExpandWar.delete(docBaseFile);\n        }\n        \n        ok = true;\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "void stop() {\n\n        if (log.isDebugEnabled())\n            log.debug(sm.getString(\"contextConfig.stop\"));\n\n        int i;\n\n        // Removing children\n        Container[] children = context.findChildren();\n        for (i = 0; i < children.length; i++) {\n            context.removeChild(children[i]);\n        }\n\n        // Removing application parameters\n        /*\n        ApplicationParameter[] applicationParameters =\n            context.findApplicationParameters();\n        for (i = 0; i < applicationParameters.length; i++) {\n            context.removeApplicationParameter\n                (applicationParameters[i].getName());\n        }\n        */\n\n        // Removing security constraints\n        SecurityConstraint[] securityConstraints = context.findConstraints();\n        for (i = 0; i < securityConstraints.length; i++) {\n            context.removeConstraint(securityConstraints[i]);\n        }\n\n        // Removing Ejbs\n        /*\n        ContextEjb[] contextEjbs = context.findEjbs();\n        for (i = 0; i < contextEjbs.length; i++) {\n            context.removeEjb(contextEjbs[i].getName());\n        }\n        */\n\n        // Removing environments\n        /*\n        ContextEnvironment[] contextEnvironments = context.findEnvironments();\n        for (i = 0; i < contextEnvironments.length; i++) {\n            context.removeEnvironment(contextEnvironments[i].getName());\n        }\n        */\n\n        // Removing errors pages\n        ErrorPage[] errorPages = context.findErrorPages();\n        for (i = 0; i < errorPages.length; i++) {\n            context.removeErrorPage(errorPages[i]);\n        }\n\n        // Removing filter defs\n        FilterDef[] filterDefs = context.findFilterDefs();\n        for (i = 0; i < filterDefs.length; i++) {\n            context.removeFilterDef(filterDefs[i]);\n        }\n\n        // Removing filter maps\n        FilterMap[] filterMaps = context.findFilterMaps();\n        for (i = 0; i < filterMaps.length; i++) {\n            context.removeFilterMap(filterMaps[i]);\n        }\n\n        // Removing local ejbs\n        /*\n        ContextLocalEjb[] contextLocalEjbs = context.findLocalEjbs();\n        for (i = 0; i < contextLocalEjbs.length; i++) {\n            context.removeLocalEjb(contextLocalEjbs[i].getName());\n        }\n        */\n\n        // Removing Mime mappings\n        String[] mimeMappings = context.findMimeMappings();\n        for (i = 0; i < mimeMappings.length; i++) {\n            context.removeMimeMapping(mimeMappings[i]);\n        }\n\n        // Removing parameters\n        String[] parameters = context.findParameters();\n        for (i = 0; i < parameters.length; i++) {\n            context.removeParameter(parameters[i]);\n        }\n\n        // Removing resource env refs\n        /*\n        String[] resourceEnvRefs = context.findResourceEnvRefs();\n        for (i = 0; i < resourceEnvRefs.length; i++) {\n            context.removeResourceEnvRef(resourceEnvRefs[i]);\n        }\n        */\n\n        // Removing resource links\n        /*\n        ContextResourceLink[] contextResourceLinks =\n            context.findResourceLinks();\n        for (i = 0; i < contextResourceLinks.length; i++) {\n            context.removeResourceLink(contextResourceLinks[i].getName());\n        }\n        */\n\n        // Removing resources\n        /*\n        ContextResource[] contextResources = context.findResources();\n        for (i = 0; i < contextResources.length; i++) {\n            context.removeResource(contextResources[i].getName());\n        }\n        */\n\n        // Removing sercurity role\n        String[] securityRoles = context.findSecurityRoles();\n        for (i = 0; i < securityRoles.length; i++) {\n            context.removeSecurityRole(securityRoles[i]);\n        }\n\n        // Removing servlet mappings\n        String[] servletMappings = context.findServletMappings();\n        for (i = 0; i < servletMappings.length; i++) {\n            context.removeServletMapping(servletMappings[i]);\n        }\n\n        // FIXME : Removing status pages\n\n        // Removing taglibs\n        String[] taglibs = context.findTaglibs();\n        for (i = 0; i < taglibs.length; i++) {\n            context.removeTaglib(taglibs[i]);\n        }\n\n        // Removing welcome files\n        String[] welcomeFiles = context.findWelcomeFiles();\n        for (i = 0; i < welcomeFiles.length; i++) {\n            context.removeWelcomeFile(welcomeFiles[i]);\n        }\n\n        // Removing wrapper lifecycles\n        String[] wrapperLifecycles = context.findWrapperLifecycles();\n        for (i = 0; i < wrapperLifecycles.length; i++) {\n            context.removeWrapperLifecycle(wrapperLifecycles[i]);\n        }\n\n        // Removing wrapper listeners\n        String[] wrapperListeners = context.findWrapperListeners();\n        for (i = 0; i < wrapperListeners.length; i++) {\n            context.removeWrapperListener(wrapperListeners[i]);\n        }\n\n        // Remove (partially) folders and files created by antiLocking\n        Host host = (Host) context.getParent();\n        String appBase = host.getAppBase();\n        String docBase = context.getDocBase();\n        if ((docBase != null) && (originalDocBase != null)) {\n            File docBaseFile = new File(docBase);\n            if (!docBaseFile.isAbsolute()) {\n                docBaseFile = new File(appBase, docBase);\n            }\n            // No need to log failure - it is expected in this case\n            ExpandWar.delete(docBaseFile, false);\n        }\n        \n        ok = true;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static boolean delete(File dir) {\n        if (dir.isDirectory()) {\n            return deleteDir(dir);\n        } else {\n            return dir.delete();\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static boolean delete(File dir, boolean logFailure) {\n        boolean result;\n        if (dir.isDirectory()) {\n            result = deleteDir(dir, logFailure);\n        } else {\n            if (dir.exists()) {\n                result = dir.delete();\n            } else {\n                result = true;\n            }\n        }\n        if (logFailure && !result) {\n            log.error(sm.getString(\n                    \"expandWar.deleteFailed\", dir.getAbsolutePath()));\n        }\n        return result;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static boolean deleteDir(File dir) {\n\n        String files[] = dir.list();\n        if (files == null) {\n            files = new String[0];\n        }\n        for (int i = 0; i < files.length; i++) {\n            File file = new File(dir, files[i]);\n            if (file.isDirectory()) {\n                deleteDir(file);\n            } else {\n                file.delete();\n            }\n        }\n        return dir.delete();\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static boolean deleteDir(File dir, boolean logFailure) {\n\n        String files[] = dir.list();\n        if (files == null) {\n            files = new String[0];\n        }\n        for (int i = 0; i < files.length; i++) {\n            File file = new File(dir, files[i]);\n            if (file.isDirectory()) {\n                deleteDir(file, logFailure);\n            } else {\n                file.delete();\n            }\n        }\n\n        boolean result;\n        if (dir.exists()) {\n            result = dir.delete();\n        } else {\n            result = true;\n        }\n        \n        if (logFailure && !result) {\n            log.error(sm.getString(\n                    \"expandWar.deleteFailed\", dir.getAbsolutePath()));\n        }\n        \n        return result;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void deployWARs(File appBase, String[] files) {\n        \n        if (files == null)\n            return;\n        \n        for (int i = 0; i < files.length; i++) {\n            \n            if (files[i].equalsIgnoreCase(\"META-INF\"))\n                continue;\n            if (files[i].equalsIgnoreCase(\"WEB-INF\"))\n                continue;\n            File dir = new File(appBase, files[i]);\n            if (files[i].toLowerCase().endsWith(\".war\")) {\n                \n                // Calculate the context path and make sure it is unique\n                String contextPath = \"/\" + files[i].replace('#','/');\n                int period = contextPath.lastIndexOf(\".\");\n                if (period >= 0)\n                    contextPath = contextPath.substring(0, period);\n                if (contextPath.equals(\"/ROOT\"))\n                    contextPath = \"\";\n                \n                if (isServiced(contextPath))\n                    continue;\n                \n                String file = files[i];\n                \n                deployWAR(contextPath, dir, file);\n                \n            }\n            \n        }\n        \n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void deployWARs(File appBase, String[] files) {\n        \n        if (files == null)\n            return;\n        \n        for (int i = 0; i < files.length; i++) {\n            \n            if (files[i].equalsIgnoreCase(\"META-INF\"))\n                continue;\n            if (files[i].equalsIgnoreCase(\"WEB-INF\"))\n                continue;\n            File dir = new File(appBase, files[i]);\n            if (files[i].toLowerCase().endsWith(\".war\") && dir.isFile() &&\n                    !invalidWars.contains(files[i])) {\n                \n                // Calculate the context path and make sure it is unique\n                String contextPath = \"/\" + files[i].replace('#','/');\n                int period = contextPath.lastIndexOf(\".\");\n                contextPath = contextPath.substring(0, period);\n                \n                // Check for WARs with /../ /./ or similar sequences in the name\n                if (!validateContextPath(appBase, contextPath)) {\n                    log.error(sm.getString(\n                            \"hostConfig.illegalWarName\", files[i]));\n                    invalidWars.add(files[i]);\n                    continue;\n                }\n\n                if (contextPath.equals(\"/ROOT\"))\n                    contextPath = \"\";\n                \n                if (isServiced(contextPath))\n                    continue;\n                \n                String file = files[i];\n                \n                deployWAR(contextPath, dir, file);\n                \n            }\n            \n        }\n        \n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Request() {\n\n        parameters.setQuery(queryMB);\n        parameters.setURLDecoder(urlDecoder);\n        parameters.setHeaders(headers);\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Request() {\n\n        parameters.setQuery(queryMB);\n        parameters.setURLDecoder(urlDecoder);\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean add(SendfileData data) {\n            // Initialize fd from data given\n            try {\n                data.fdpool = Socket.pool(data.socket);\n                data.fd = File.open\n                    (data.fileName, File.APR_FOPEN_READ\n                     | File.APR_FOPEN_SENDFILE_ENABLED | File.APR_FOPEN_BINARY,\n                     0, data.fdpool);\n                data.pos = data.start;\n                // Set the socket to nonblocking mode\n                Socket.timeoutSet(data.socket, 0);\n                while (true) {\n                    long nw = Socket.sendfilen(data.socket, data.fd,\n                                               data.pos, data.end - data.pos, 0);\n                    if (nw < 0) {\n                        if (!(-nw == Status.EAGAIN)) {\n                            Socket.destroy(data.socket);\n                            data.socket = 0;\n                            return false;\n                        } else {\n                            // Break the loop and add the socket to poller.\n                            break;\n                        }\n                    } else {\n                        data.pos = data.pos + nw;\n                        if (data.pos >= data.end) {\n                            // Entire file has been sent\n                            Pool.destroy(data.fdpool);\n                            // Set back socket to blocking mode\n                            Socket.timeoutSet(data.socket, soTimeout * 1000);\n                            return true;\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                log.error(sm.getString(\"endpoint.sendfile.error\"), e);\n                return false;\n            }\n            // Add socket to the list. Newly added sockets will wait\n            // at most for pollTime before being polled\n            synchronized (this) {\n                addS.add(data);\n                addCount++;\n                this.notify();\n            }\n            return false;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean add(SendfileData data) {\n            // Initialize fd from data given\n            try {\n                data.fdpool = Socket.pool(data.socket);\n                data.fd = File.open\n                    (data.fileName, File.APR_FOPEN_READ\n                     | File.APR_FOPEN_SENDFILE_ENABLED | File.APR_FOPEN_BINARY,\n                     0, data.fdpool);\n                data.pos = data.start;\n                // Set the socket to nonblocking mode\n                Socket.timeoutSet(data.socket, 0);\n                while (true) {\n                    long nw = Socket.sendfilen(data.socket, data.fd,\n                                               data.pos, data.end - data.pos, 0);\n                    if (nw < 0) {\n                        if (!(-nw == Status.EAGAIN)) {\n                            Pool.destroy(data.fdpool);\n                            // No need to close socket, this will be done by\n                            // calling code since data.socket == 0\n                            data.socket = 0;\n                            return false;\n                        } else {\n                            // Break the loop and add the socket to poller.\n                            break;\n                        }\n                    } else {\n                        data.pos = data.pos + nw;\n                        if (data.pos >= data.end) {\n                            // Entire file has been sent\n                            Pool.destroy(data.fdpool);\n                            // Set back socket to blocking mode\n                            Socket.timeoutSet(data.socket, soTimeout * 1000);\n                            return true;\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                log.error(sm.getString(\"endpoint.sendfile.error\"), e);\n                return false;\n            }\n            // Add socket to the list. Newly added sockets will wait\n            // at most for pollTime before being polled\n            synchronized (this) {\n                addS.add(data);\n                addCount++;\n                this.notify();\n            }\n            return false;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void recycle() {\n        //        buff = null;\n        enc=null;\n        start=0;\n        end=0;\n        isSet=false;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void recycle() {\n        //        buff = null;\n        charset=null;\n        start=0;\n        end=0;\n        isSet=false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String toStringInternal() {\n        String strValue=null;\n        try {\n            if( enc==null ) enc=DEFAULT_CHARACTER_ENCODING;\n            strValue = new String( buff, start, end-start, enc );\n            /*\n             Does not improve the speed too much on most systems,\n             it's safer to use the \"clasical\" new String().\n             \n             Most overhead is in creating char[] and copying,\n             the internal implementation of new String() is very close to\n             what we do. The decoder is nice for large buffers and if\n             we don't go to String ( so we can take advantage of reduced GC)\n             \n             // Method is commented out, in:\n              return B2CConverter.decodeString( enc );\n              */\n        } catch (java.io.UnsupportedEncodingException e) {\n            // Use the platform encoding in that case; the usage of a bad\n            // encoding will have been logged elsewhere already\n            strValue = new String(buff, start, end-start);\n        }\n        return strValue;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String toStringInternal() {\n        if (charset == null) {\n            charset = DEFAULT_CHARSET;\n        }\n        // new String(byte[], int, int, Charset) takes a defensive copy of the\n        // entire byte array. This is expensive if only a small subset of the\n        // bytes will be used. The code below is from Apache Harmony.\n        CharBuffer cb;\n        cb = charset.decode(ByteBuffer.wrap(buff, start, end-start));\n        return new String(cb.array(), cb.arrayOffset(), cb.length());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public UDecoder() \n    {\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public UDecoder() \n    {\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "void setByteChunk( ByteChunk mb ) {\n        initialized = (mb!=null);\n        bc = mb;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "void setByteChunk( ByteChunk mb ) {\n        bc = mb;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Parameters() {\n        super( INITIAL_SIZE );\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Parameters() {\n        // NO-OP\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setEncoding( String s ) {\n        encoding=s;\n        if(debug>0) log( \"Set encoding to \" + s );\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setEncoding( String s ) {\n        encoding=s;\n        if(log.isDebugEnabled()) {\n            log.debug( \"Set encoding to \" + s );\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setQueryStringEncoding( String s ) {\n        queryStringEncoding=s;\n        if(debug>0) log( \"Set query string encoding to \" + s );\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setQueryStringEncoding( String s ) {\n        queryStringEncoding=s;\n        if(log.isDebugEnabled()) {\n            log.debug( \"Set query string encoding to \" + s );\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void recycle() {\n        super.recycle();\n        paramHashStringArray.clear();\n        didQueryParameters=false;\n        currentChild=null;\n        didMerge=false;\n        encoding=null;\n        decodedQuery.recycle();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void recycle() {\n        parameterCount = 0;\n        paramHashValues.clear();\n        didQueryParameters=false;\n        encoding=null;\n        decodedQuery.recycle();\n        parseFailed = false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addParameterValues( String key, String[] newValues) {\n        if ( key==null ) return;\n        String values[];\n        if (paramHashStringArray.containsKey(key)) {\n            String oldValues[] = (String[])paramHashStringArray.get(key);\n            values = new String[oldValues.length + newValues.length];\n            for (int i = 0; i < oldValues.length; i++) {\n                values[i] = oldValues[i];\n            }\n            for (int i = 0; i < newValues.length; i++) {\n                values[i+ oldValues.length] = newValues[i];\n            }\n        } else {\n            values = newValues;\n        }\n\n        paramHashStringArray.put(key, values);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addParameterValues(String key, String[] newValues) {\n        if (key == null) {\n            return;\n        }\n        ArrayList values = (ArrayList) paramHashValues.get(key);\n        if (values == null) {\n            values = new ArrayList(newValues.length);\n            paramHashValues.put(key, values);\n        } else {\n            values.ensureCapacity(values.size() + newValues.length);\n        }\n        for (int i = 0; i < newValues.length; i++) {\n            values.add(newValues[i]);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String[] getParameterValues(String name) {\n        handleQueryParameters();\n        // sub-request\n        if( currentChild!=null ) {\n            currentChild.merge();\n            return (String[])currentChild.paramHashStringArray.get(name);\n        }\n\n        // no \"facade\"\n        String values[]=(String[])paramHashStringArray.get(name);\n        return values;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String[] getParameterValues(String name) {\n        handleQueryParameters();\n        // no \"facade\"\n        ArrayList values = (ArrayList) paramHashValues.get(name);\n        if (values == null) {\n            return null;\n        }\n        return (String[]) values.toArray(new String[values.size()]);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Enumeration getParameterNames() {\n        handleQueryParameters();\n        // Slow - the original code\n        if( currentChild!=null ) {\n            currentChild.merge();\n            return currentChild.paramHashStringArray.keys();\n        }\n\n        // merge in child\n        return paramHashStringArray.keys();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Enumeration getParameterNames() {\n        handleQueryParameters();\n        return Collections.enumeration(paramHashValues.keySet());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getParameter(String name ) {\n        String[] values = getParameterValues(name);\n        if (values != null) {\n            if( values.length==0 ) return \"\";\n            return values[0];\n        } else {\n            return null;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getParameter(String name ) {\n        handleQueryParameters();\n        ArrayList values = (ArrayList) paramHashValues.get(name);\n        if (values != null) {\n            if(values.size() == 0) {\n                return \"\";\n            }\n            return (String) values.get(0);\n        } else {\n            return null;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void handleQueryParameters() {\n        if( didQueryParameters ) return;\n\n        didQueryParameters=true;\n\n        if( queryMB==null || queryMB.isNull() )\n            return;\n        \n        if( debug > 0  )\n            log( \"Decoding query \" + decodedQuery + \" \" + queryStringEncoding);\n\n        try {\n            decodedQuery.duplicate( queryMB );\n        } catch (IOException e) {\n            // Can't happen, as decodedQuery can't overflow\n            e.printStackTrace();\n        }\n        processParameters( decodedQuery, queryStringEncoding );\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void handleQueryParameters() {\n        if( didQueryParameters ) return;\n\n        didQueryParameters=true;\n\n        if( queryMB==null || queryMB.isNull() )\n            return;\n        \n        if(log.isDebugEnabled()) {\n            log.debug(\"Decoding query \" + decodedQuery + \" \" +\n                    queryStringEncoding);\n        }\n\n        try {\n            decodedQuery.duplicate( queryMB );\n        } catch (IOException e) {\n            // Can't happen, as decodedQuery can't overflow\n            e.printStackTrace();\n        }\n        processParameters( decodedQuery, queryStringEncoding );\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void addParam( String key, String value ) {\n        if( key==null ) return;\n        String values[];\n        if (paramHashStringArray.containsKey(key)) {\n            String oldValues[] = (String[])paramHashStringArray.\n                get(key);\n            values = new String[oldValues.length + 1];\n            for (int i = 0; i < oldValues.length; i++) {\n                values[i] = oldValues[i];\n            }\n            values[oldValues.length] = value;\n        } else {\n            values = new String[1];\n            values[0] = value;\n        }\n        \n        \n        paramHashStringArray.put(key, values);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void addParam( String key, String value ) {\n        if( key==null ) return;\n        ArrayList values = (ArrayList) paramHashValues.get(key);\n        if (values == null) {\n            values = new ArrayList(1);\n            paramHashValues.put(key, values);\n        }\n        values.add(value);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void processParameters( String str ) {\n        int end=str.length();\n        int pos=0;\n        if( debug > 0)\n            log(\"String: \" + str );\n        \n        do {\n            boolean noEq=false;\n            int valStart=-1;\n            int valEnd=-1;\n            \n            int nameStart=pos;\n            int nameEnd=str.indexOf('=', nameStart );\n            int nameEnd2=str.indexOf('&', nameStart );\n            if( nameEnd2== -1 ) nameEnd2=end;\n            if( (nameEnd2!=-1 ) &&\n                ( nameEnd==-1 || nameEnd > nameEnd2) ) {\n                nameEnd=nameEnd2;\n                noEq=true;\n                valStart=nameEnd;\n                valEnd=nameEnd;\n                if(debug>0) log(\"no equal \" + nameStart + \" \" + nameEnd + \" \" +\n                        str.substring(nameStart, nameEnd));\n            }\n\n            if( nameEnd== -1 ) nameEnd=end;\n\n            if( ! noEq ) {\n                valStart=nameEnd+1;\n                valEnd=str.indexOf('&', valStart);\n                if( valEnd== -1 ) valEnd = (valStart < end) ? end : valStart;\n            }\n            \n            pos=valEnd+1;\n            \n            if( nameEnd<=nameStart ) {\n                continue;\n            }\n            if( debug>0)\n                log( \"XXX \" + nameStart + \" \" + nameEnd + \" \"\n                     + valStart + \" \" + valEnd );\n            \n            try {\n                tmpNameC.append(str, nameStart, nameEnd-nameStart );\n                tmpValueC.append(str, valStart, valEnd-valStart );\n            \n                if( debug > 0 )\n                    log( tmpNameC + \"= \" + tmpValueC);\n\n                if( urlDec==null ) {\n                    urlDec=new UDecoder();   \n                }\n\n                urlDec.convert( tmpNameC );\n                urlDec.convert( tmpValueC );\n\n                if( debug > 0 )\n                    log( tmpNameC + \"= \" + tmpValueC);\n                \n                addParam( tmpNameC.toString(), tmpValueC.toString() );\n            } catch( IOException ex ) {\n                ex.printStackTrace();\n            }\n\n            tmpNameC.recycle();\n            tmpValueC.recycle();\n\n        } while( pos<end );\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void processParameters( MessageBytes data, String encoding ) {\n        if( data==null || data.isNull() || data.getLength() <= 0 ) return;\n\n        if( data.getType() != MessageBytes.T_BYTES ) {\n            data.toBytes();\n        }\n        ByteChunk bc=data.getByteChunk();\n        processParameters( bc.getBytes(), bc.getOffset(),\n                           bc.getLength(), getCharset(encoding));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "recursive\n        if( debug > 0 ) {\n            log(\"Before merging \" + this + \" \" + parent + \" \" + didMerge );\n            log(  paramsAsString());\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "else if (valueStart > -1 && valueEnd == -1){\n                    valueEnd = pos;\n                }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String paramsAsString() {\n        StringBuffer sb=new StringBuffer();\n        Enumeration en= paramHashStringArray.keys();\n        while( en.hasMoreElements() ) {\n            String k=(String)en.nextElement();\n            sb.append( k ).append(\"=\");\n            String v[]=(String[])paramHashStringArray.get( k );\n            for( int i=0; i<v.length; i++ )\n                sb.append( v[i] ).append(\",\");\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String paramsAsString() {\n        StringBuffer sb = new StringBuffer();\n        Iterator it = paramHashValues.entrySet().iterator();\n        while (it.hasNext()) {\n            Map.Entry e = (Map.Entry) it.next();\n            sb.append(e.getKey()).append('=');\n            ArrayList values = (ArrayList) e.getValue();\n            for(int i = 0; i < values.size(); i++) {\n                sb.append(values.get(i)).append(',');\n            }\n            sb.append('\\n');\n        }\n        return sb.toString();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void initializeFilters() {\n\n        // Create and add the identity filters.\n        inputBuffer.addFilter(new IdentityInputFilter());\n        outputBuffer.addFilter(new IdentityOutputFilter());\n\n        // Create and add the chunked filters.\n        inputBuffer.addFilter(new ChunkedInputFilter());\n        outputBuffer.addFilter(new ChunkedOutputFilter());\n\n        // Create and add the void filters.\n        inputBuffer.addFilter(new VoidInputFilter());\n        outputBuffer.addFilter(new VoidOutputFilter());\n\n        // Create and add buffered input filter\n        inputBuffer.addFilter(new BufferedInputFilter());\n\n        // Create and add the chunked filters.\n        //inputBuffer.addFilter(new GzipInputFilter());\n        outputBuffer.addFilter(new GzipOutputFilter());\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void initializeFilters() {\n\n        // Create and add the identity filters.\n        inputBuffer.addFilter(new IdentityInputFilter());\n        outputBuffer.addFilter(new IdentityOutputFilter());\n\n        // Create and add the chunked filters.\n        inputBuffer.addFilter(new ChunkedInputFilter());\n        outputBuffer.addFilter(new ChunkedOutputFilter());\n\n        // Create and add the void filters.\n        inputBuffer.addFilter(new VoidInputFilter());\n        outputBuffer.addFilter(new VoidOutputFilter());\n\n        // Create and add buffered input filter\n        inputBuffer.addFilter(new BufferedInputFilter());\n\n        // Create and add the chunked filters.\n        //inputBuffer.addFilter(new GzipInputFilter());\n        outputBuffer.addFilter(new GzipOutputFilter());\n\n        pluggableFilterIndex = inputBuffer.filterLibrary.length;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean addInputFilter(InputFilter[] inputFilters,\n                                     String encodingName) {\n        if (encodingName.equals(\"identity\")) {\n            // Skip\n        } else if (encodingName.equals(\"chunked\")) {\n            inputBuffer.addActiveFilter\n                (inputFilters[Constants.CHUNKED_FILTER]);\n            contentDelimitation = true;\n        } else {\n            for (int i = 2; i < inputFilters.length; i++) {\n                if (inputFilters[i].getEncodingName()\n                    .toString().equals(encodingName)) {\n                    inputBuffer.addActiveFilter(inputFilters[i]);\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean addInputFilter(InputFilter[] inputFilters,\n                                     String encodingName) {\n        if (encodingName.equals(\"identity\")) {\n            // Skip\n        } else if (encodingName.equals(\"chunked\")) {\n            inputBuffer.addActiveFilter\n                (inputFilters[Constants.CHUNKED_FILTER]);\n            contentDelimitation = true;\n        } else {\n            for (int i = pluggableFilterIndex; i < inputFilters.length; i++) {\n                if (inputFilters[i].getEncodingName()\n                    .toString().equals(encodingName)) {\n                    inputBuffer.addActiveFilter(inputFilters[i]);\n                    return true;\n                }\n            }\n            return false;\n        }\n        return true;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void recycle() {\n        if (buffered.getBuffer().length > 65536) {\n            buffered = null;\n        } else {\n            buffered.recycle();\n        }\n        tempRead.recycle();\n        hasRead = false;\n        buffer = null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void recycle() {\n        if (buffered != null) {\n            if (buffered.getBuffer().length > 65536) {\n                buffered = null;\n            } else {\n                buffered.recycle();\n            }\n        }\n        tempRead.recycle();\n        hasRead = false;\n        buffer = null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void checkStreamTest_NoStreamConfiguredForCIMStream() {\n        CoverityPublisher publisher = new CoverityPublisherBuilder().build();\n        CIMInstance cimInstance = new CIMInstanceBuilder().withName(\"test-cim-instance\").withHost(\"test-cim-instance\").withPort(8080)\n                .withUser(\"admin\").withPassword(\"password\").withUseSSL(false).withCredentialId(\"\")\n                .build();\n        CIMStream cimStream = new CIMStream(\"test-cim-instance\", StringUtils.EMPTY, StringUtils.EMPTY);\n        when(descriptor.getInstance(any(CoverityPublisher.class))).thenReturn(cimInstance);\n\n        CheckConfig.StreamStatus status = CheckConfig.checkStream(publisher, cimStream);\n        assertNotNull(status);\n        assertFalse(status.isValid());\n        String statusMessage = status.getStatus();\n        assertNotNull(statusMessage);\n        assertEquals(\"[Stream] test-cim-instance/null/null : \" +\n                \"Could not find any Stream that matches the given configuration for this job.\", statusMessage);\n        assertNull(status.getVersion());\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void checkStreamTest_NoStreamConfiguredForCIMStream() {\n        setCredentialManager(\"admin\", \"password\");\n        CoverityPublisher publisher = new CoverityPublisherBuilder().build();\n        CIMInstance cimInstance = new CIMInstanceBuilder().withName(\"test-cim-instance\").withHost(\"test-cim-instance\").withPort(8080)\n                .withUseSSL(false).withDefaultCredentialId().build();\n        CIMStream cimStream = new CIMStream(\"test-cim-instance\", StringUtils.EMPTY, StringUtils.EMPTY);\n        when(descriptor.getInstance(any(CoverityPublisher.class))).thenReturn(cimInstance);\n\n        CheckConfig.StreamStatus status = CheckConfig.checkStream(publisher, cimStream);\n        assertNotNull(status);\n        assertFalse(status.isValid());\n        String statusMessage = status.getStatus();\n        assertNotNull(statusMessage);\n        assertEquals(\"[Stream] test-cim-instance/null/null : \" +\n                \"Could not find any Stream that matches the given configuration for this job.\", statusMessage);\n        assertNull(status.getVersion());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void doCheck_invalidWSResponseCode() {\n        testWsFactory.setWSResponseCode(401, \"failed response message\");\n        final String expectedErrorMessage = \"Connection check failed.\" + System.lineSeparator() +\n            \"Check Coverity Web Service Response: { Code=401, Message=\\\"failed response message\\\" }\" + System.lineSeparator() +\n            \"(check that the values entered for this instance are correct and ensure the Coverity Connect version is at least \" +\n            CoverityVersion.MINIMUM_SUPPORTED_VERSION.toString() + \")\";\n\n        CIMInstance cimInstance = new CIMInstanceBuilder().withName(\"test\").withHost(\"test.coverity\").withPort(8080)\n                .withUser(\"admin\").withPassword(\"password\").withUseSSL(false).withCredentialId(\"\").build();\n\n        FormValidation result = cimInstance.doCheck();\n\n        assertEquals(Kind.ERROR, result.kind);\n        assertEquals(expectedErrorMessage, StringEscapeUtils.unescapeHtml(result.getMessage()).replace(\"<br>\", \"\\n\"));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void doCheck_invalidWSResponseCode() {\n        testWsFactory.setWSResponseCode(401, \"failed response message\");\n        final String expectedErrorMessage = \"Connection check failed.\" + System.lineSeparator() +\n            \"Check Coverity Web Service Response: { Code=401, Message=\\\"failed response message\\\" }\" + System.lineSeparator() +\n            \"(check that the values entered for this instance are correct and ensure the Coverity Connect version is at least \" +\n            CoverityVersion.MINIMUM_SUPPORTED_VERSION.toString() + \")\";\n        CredentialUtil.setCredentialManager(\"admin\", \"password\");\n\n        CIMInstance cimInstance = new CIMInstanceBuilder().withName(\"test\").withHost(\"test.coverity\").withPort(8080)\n                .withUseSSL(false).withDefaultCredentialId().build();\n\n        FormValidation result = cimInstance.doCheck();\n\n        assertEquals(Kind.ERROR, result.kind);\n        assertEquals(expectedErrorMessage, StringEscapeUtils.unescapeHtml(result.getMessage()).replace(\"<br>\", \"\\n\"));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setup() {\n        // setup jenkins\n        Jenkins jenkins = mock(Jenkins.class);\n        PowerMockito.mockStatic(Jenkins.class);\n        when(Jenkins.getInstance()).thenReturn(jenkins);\n        DescriptorImpl descriptor = mock(CoverityPublisher.DescriptorImpl.class);\n        cimInstance = new CIMInstanceBuilder().withName(\"test-cim-instance\").withHost(\"test-cim-instance\").withPort(8080)\n                .withUser(\"admin\").withPassword(\"password\").withUseSSL(false).withCredentialId(\"\")\n                .build();\n        final List<CIMInstance> cimInstances = Arrays.asList(cimInstance);\n        when(descriptor.getInstances()).thenReturn(cimInstances);\n        when(jenkins.getDescriptorByType(CoverityPublisher.DescriptorImpl.class)).thenReturn(descriptor);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setup() {\n        // setup jenkins\n        Jenkins jenkins = mock(Jenkins.class);\n        PowerMockito.mockStatic(Jenkins.class);\n        when(Jenkins.getInstance()).thenReturn(jenkins);\n        DescriptorImpl descriptor = mock(CoverityPublisher.DescriptorImpl.class);\n        CredentialUtil.setCredentialManager(\"admin\", \"password\");\n        cimInstance = new CIMInstanceBuilder().withName(\"test-cim-instance\").withHost(\"test-cim-instance\").withPort(8080)\n                .withUseSSL(false).withDefaultCredentialId().build();\n        final List<CIMInstance> cimInstances = Arrays.asList(cimInstance);\n        when(descriptor.getInstances()).thenReturn(cimInstances);\n        when(jenkins.getDescriptorByType(CoverityPublisher.DescriptorImpl.class)).thenReturn(descriptor);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public CIMInstance build(){\n        CIMInstance instance = new CIMInstance(name, host, port, credentialId);\n        instance.setUseSSL(useSSL);\n        instance.setUser(user);\n        instance.setPassword(password);\n\n        return instance;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public CIMInstance build(){\n        CIMInstance instance = new CIMInstance(name, host, port, credentialId);\n        instance.setUseSSL(useSSL);\n\n        return instance;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public CIMInstance cloneWithCredential(String credentialId) {\n        CIMInstance instance = new CIMInstance(name, host, port, credentialId);\n        instance.setUser(user);\n        instance.setPassword(password);\n        instance.setUseSSL(useSSL);\n        return instance;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public CIMInstance cloneWithCredential(String credentialId) {\n        CIMInstance instance = new CIMInstance(name, host, port, credentialId);\n        instance.setUseSSL(useSSL);\n        return instance;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public FormValidation doCheckInstance(@QueryParameter String host, @QueryParameter int port,\n                                              @QueryParameter String user, @QueryParameter String password,\n                                              @QueryParameter boolean useSSL, @QueryParameter String credentialId) {\n            CIMInstance instance = new CIMInstance(\"\", host, port, credentialId);\n            instance.setUser(user);\n            instance.setPassword(password);\n            instance.setUseSSL(useSSL);\n            return instance.doCheck();\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public FormValidation doCheckInstance(@QueryParameter String host, @QueryParameter int port,\n                                              @QueryParameter boolean useSSL, @QueryParameter String credentialId) {\n            CIMInstance instance = new CIMInstance(\"\", host, port, credentialId);\n            instance.setUseSSL(useSSL);\n            return instance.doCheck();\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public AuthenticationMechanismOutcome handleDigestHeader(HttpServerExchange exchange, final SecurityContext securityContext) {\n        DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);\n        Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();\n        // Step 1 - Verify the set of tokens received to ensure valid values.\n        Set<DigestAuthorizationToken> mandatoryTokens = EnumSet.copyOf(MANDATORY_REQUEST_TOKENS);\n        if (!supportedAlgorithms.contains(DigestAlgorithm.MD5)) {\n            // If we don't support MD5 then the client must choose an algorithm as we can not fall back to MD5.\n            mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);\n        }\n        if (!supportedQops.isEmpty() && !supportedQops.contains(DigestQop.AUTH)) {\n            // If we do not support auth then we are mandating auth-int so force the client to send a QOP\n            mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);\n        }\n\n        DigestQop qop = null;\n        // This check is early as is increases the list of mandatory tokens.\n        if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {\n            qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n            if (qop == null || !supportedQops.contains(qop)) {\n                // We are also ensuring the client is not trying to force a qop that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n            context.setQop(qop);\n            mandatoryTokens.add(DigestAuthorizationToken.CNONCE);\n            mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);\n        }\n\n        // Check all mandatory tokens are present.\n        mandatoryTokens.removeAll(parsedHeader.keySet());\n        if (mandatoryTokens.size() > 0) {\n            for (DigestAuthorizationToken currentToken : mandatoryTokens) {\n                // TODO - Need a better check and possible concatenate the list of tokens - however\n                // even having one missing token is not something we should routinely expect.\n                REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());\n            }\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Perform some validation of the remaining tokens.\n        if (!realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM))) {\n            REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),\n                    parsedHeader.get(DigestAuthorizationToken.REALM));\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // TODO - Validate the URI\n\n        if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {\n            if (!OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE))) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.OPAQUE));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        }\n\n        DigestAlgorithm algorithm;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {\n            algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n            if (algorithm == null || !supportedAlgorithms.contains(algorithm)) {\n                // We are also ensuring the client is not trying to force an algorithm that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            // We know this is safe as the algorithm token was made mandatory\n            // if MD5 is not supported.\n            algorithm = DigestAlgorithm.MD5;\n        }\n\n        try {\n            context.setAlgorithm(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            /*\n             * This should not be possible in a properly configured installation.\n             */\n            REQUEST_LOGGER.exceptionProcessingRequest(e);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);\n        final IdentityManager identityManager = getIdentityManager(securityContext);\n        final Account account;\n\n        if (algorithm.isSession()) {\n            /* This can follow one of the following: -\n             *   1 - New session so use DigestCredentialImpl with the IdentityManager to\n             *       create a new session key.\n             *   2 - Obtain the existing session key from the session store and validate it, just use\n             *       IdentityManager to validate account is still active and the current role assignment.\n             */\n            throw new IllegalStateException(\"Not yet implemented.\");\n        } else {\n            final DigestCredential credential = new DigestCredentialImpl(context);\n            account = identityManager.verify(userName, credential);\n        }\n\n        if (account == null) {\n            // Authentication has failed, this could either be caused by the user not-existing or it\n            // could be caused due to an invalid hash.\n            securityContext.authenticationFailed(MESSAGES.authenticationFailed(userName), mechanismName);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Step 3 - Verify that the nonce was eligible to be used.\n        if (!validateNonceUse(context, parsedHeader, exchange)) {\n            // TODO - This is the right place to make use of the decision but the check needs to be much much sooner\n            // otherwise a failure server\n            // side could leave a packet that could be 're-played' after the failed auth.\n            // The username and password verification passed but for some reason we do not like the nonce.\n            context.markStale();\n            // We do not mark as a failure on the security context as this is not quite a failure, a client with a cached nonce\n            // can easily hit this point.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // We have authenticated the remote user.\n\n        sendAuthenticationInfoHeader(exchange);\n        securityContext.authenticationComplete(account, mechanismName, false);\n        return AuthenticationMechanismOutcome.AUTHENTICATED;\n\n        // Step 4 - Set up any QOP related requirements.\n\n        // TODO - Do QOP\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private AuthenticationMechanismOutcome handleDigestHeader(HttpServerExchange exchange, final SecurityContext securityContext) {\n        DigestContext context = exchange.getAttachment(DigestContext.ATTACHMENT_KEY);\n        Map<DigestAuthorizationToken, String> parsedHeader = context.getParsedHeader();\n        // Step 1 - Verify the set of tokens received to ensure valid values.\n        Set<DigestAuthorizationToken> mandatoryTokens = EnumSet.copyOf(MANDATORY_REQUEST_TOKENS);\n        if (!supportedAlgorithms.contains(DigestAlgorithm.MD5)) {\n            // If we don't support MD5 then the client must choose an algorithm as we can not fall back to MD5.\n            mandatoryTokens.add(DigestAuthorizationToken.ALGORITHM);\n        }\n        if (!supportedQops.isEmpty() && !supportedQops.contains(DigestQop.AUTH)) {\n            // If we do not support auth then we are mandating auth-int so force the client to send a QOP\n            mandatoryTokens.add(DigestAuthorizationToken.MESSAGE_QOP);\n        }\n\n        DigestQop qop = null;\n        // This check is early as is increases the list of mandatory tokens.\n        if (parsedHeader.containsKey(DigestAuthorizationToken.MESSAGE_QOP)) {\n            qop = DigestQop.forName(parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n            if (qop == null || !supportedQops.contains(qop)) {\n                // We are also ensuring the client is not trying to force a qop that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.MESSAGE_QOP.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.MESSAGE_QOP));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n            context.setQop(qop);\n            mandatoryTokens.add(DigestAuthorizationToken.CNONCE);\n            mandatoryTokens.add(DigestAuthorizationToken.NONCE_COUNT);\n        }\n\n        // Check all mandatory tokens are present.\n        mandatoryTokens.removeAll(parsedHeader.keySet());\n        if (mandatoryTokens.size() > 0) {\n            for (DigestAuthorizationToken currentToken : mandatoryTokens) {\n                // TODO - Need a better check and possible concatenate the list of tokens - however\n                // even having one missing token is not something we should routinely expect.\n                REQUEST_LOGGER.missingAuthorizationToken(currentToken.getName());\n            }\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Perform some validation of the remaining tokens.\n        if (!realmName.equals(parsedHeader.get(DigestAuthorizationToken.REALM))) {\n            REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.REALM.getName(),\n                    parsedHeader.get(DigestAuthorizationToken.REALM));\n            // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if(parsedHeader.containsKey(DigestAuthorizationToken.DIGEST_URI)) {\n            String uri = parsedHeader.get(DigestAuthorizationToken.DIGEST_URI);\n            String requestURI = exchange.getRequestURI();\n            if(!exchange.getQueryString().isEmpty()) {\n                requestURI = requestURI + \"?\" + exchange.getQueryString();\n            }\n            if(!uri.equals(requestURI)) {\n                //just end the auth process\n                exchange.setStatusCode(StatusCodes.BAD_REQUEST);\n                exchange.endExchange();\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        if (parsedHeader.containsKey(DigestAuthorizationToken.OPAQUE)) {\n            if (!OPAQUE_VALUE.equals(parsedHeader.get(DigestAuthorizationToken.OPAQUE))) {\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.OPAQUE.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.OPAQUE));\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        }\n\n        DigestAlgorithm algorithm;\n        if (parsedHeader.containsKey(DigestAuthorizationToken.ALGORITHM)) {\n            algorithm = DigestAlgorithm.forName(parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n            if (algorithm == null || !supportedAlgorithms.contains(algorithm)) {\n                // We are also ensuring the client is not trying to force an algorithm that has been disabled.\n                REQUEST_LOGGER.invalidTokenReceived(DigestAuthorizationToken.ALGORITHM.getName(),\n                        parsedHeader.get(DigestAuthorizationToken.ALGORITHM));\n                // TODO - This actually needs to result in a HTTP 400 Bad Request response and not a new challenge.\n                return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n            }\n        } else {\n            // We know this is safe as the algorithm token was made mandatory\n            // if MD5 is not supported.\n            algorithm = DigestAlgorithm.MD5;\n        }\n\n        try {\n            context.setAlgorithm(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            /*\n             * This should not be possible in a properly configured installation.\n             */\n            REQUEST_LOGGER.exceptionProcessingRequest(e);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        final String userName = parsedHeader.get(DigestAuthorizationToken.USERNAME);\n        final IdentityManager identityManager = getIdentityManager(securityContext);\n        final Account account;\n\n        if (algorithm.isSession()) {\n            /* This can follow one of the following: -\n             *   1 - New session so use DigestCredentialImpl with the IdentityManager to\n             *       create a new session key.\n             *   2 - Obtain the existing session key from the session store and validate it, just use\n             *       IdentityManager to validate account is still active and the current role assignment.\n             */\n            throw new IllegalStateException(\"Not yet implemented.\");\n        } else {\n            final DigestCredential credential = new DigestCredentialImpl(context);\n            account = identityManager.verify(userName, credential);\n        }\n\n        if (account == null) {\n            // Authentication has failed, this could either be caused by the user not-existing or it\n            // could be caused due to an invalid hash.\n            securityContext.authenticationFailed(MESSAGES.authenticationFailed(userName), mechanismName);\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // Step 3 - Verify that the nonce was eligible to be used.\n        if (!validateNonceUse(context, parsedHeader, exchange)) {\n            // TODO - This is the right place to make use of the decision but the check needs to be much much sooner\n            // otherwise a failure server\n            // side could leave a packet that could be 're-played' after the failed auth.\n            // The username and password verification passed but for some reason we do not like the nonce.\n            context.markStale();\n            // We do not mark as a failure on the security context as this is not quite a failure, a client with a cached nonce\n            // can easily hit this point.\n            return AuthenticationMechanismOutcome.NOT_AUTHENTICATED;\n        }\n\n        // We have authenticated the remote user.\n\n        sendAuthenticationInfoHeader(exchange);\n        securityContext.authenticationComplete(account, mechanismName, false);\n        return AuthenticationMechanismOutcome.AUTHENTICATED;\n\n        // Step 4 - Set up any QOP related requirements.\n\n        // TODO - Do QOP\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected XStream createXStream() {\n        XStream xstream = null;\n        if (brokerContext != null) {\n            Map<String, XStream> beans = brokerContext.getBeansOfType(XStream.class);\n            for (XStream bean : beans.values()) {\n                if (bean != null) {\n                    xstream = bean;\n                    break;\n                }\n            }\n        }\n\n        if (xstream == null) {\n            xstream = new XStream();\n            xstream.ignoreUnknownElements();\n        }\n\n        // For any object whose elements contains an UTF8Buffer instance instead\n        // of a String type we map it to String both in and out such that we don't\n        // marshal UTF8Buffers out\n        xstream.registerConverter(new AbstractSingleValueConverter() {\n\n            @Override\n            public Object fromString(String str) {\n                return str;\n            }\n\n            @SuppressWarnings(\"rawtypes\")\n            @Override\n            public boolean canConvert(Class type) {\n                return type.equals(UTF8Buffer.class);\n            }\n        });\n\n        xstream.alias(\"string\", UTF8Buffer.class);\n\n        return xstream;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected XStream createXStream() {\n        XStream xstream = null;\n        if (brokerContext != null) {\n            Map<String, XStream> beans = brokerContext.getBeansOfType(XStream.class);\n            for (XStream bean : beans.values()) {\n                if (bean != null) {\n                    xstream = bean;\n                    break;\n                }\n            }\n        }\n\n        if (xstream == null) {\n            xstream = XStreamSupport.createXStream();\n            xstream.ignoreUnknownElements();\n        }\n\n        // For any object whose elements contains an UTF8Buffer instance instead\n        // of a String type we map it to String both in and out such that we don't\n        // marshal UTF8Buffers out\n        xstream.registerConverter(new AbstractSingleValueConverter() {\n\n            @Override\n            public Object fromString(String str) {\n                return str;\n            }\n\n            @SuppressWarnings(\"rawtypes\")\n            @Override\n            public boolean canConvert(Class type) {\n                return type.equals(UTF8Buffer.class);\n            }\n        });\n\n        xstream.alias(\"string\", UTF8Buffer.class);\n\n        return xstream;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static XStream createXStream() {\n        XStream stream = new XStream();\n        stream.addPermission(NoTypePermission.NONE);\n        stream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n        stream.allowTypeHierarchy(Collection.class);\n        stream.allowTypeHierarchy(Map.class);\n        stream.allowTypes(new Class[]{String.class});\n        if (ClassLoadingAwareObjectInputStream.isAllAllowed()) {\n            stream.addPermission(AnyTypePermission.ANY);\n        } else {\n            for (String packageName : ClassLoadingAwareObjectInputStream.getSerialziablePackages()) {\n                stream.allowTypesByWildcard(new String[]{packageName + \".**\"});\n            }\n        }\n        return stream;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static XStream createXStream() {\n        XStream stream = new XStream();\n        stream.addPermission(NoTypePermission.NONE);\n        stream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n        stream.allowTypeHierarchy(Collection.class);\n        stream.allowTypeHierarchy(Map.class);\n        stream.allowTypes(new Class[]{String.class});\n        if (ClassLoadingAwareObjectInputStream.isAllAllowed()) {\n            stream.addPermission(AnyTypePermission.ANY);\n        } else {\n            for (String packageName : ClassLoadingAwareObjectInputStream.serializablePackages) {\n                stream.allowTypesByWildcard(new String[]{packageName + \".**\"});\n            }\n        }\n        return stream;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private XPathEvaluator createEvaluator(String xpath2) {\n        try {\n            return (XPathEvaluator)EVALUATOR_CONSTRUCTOR.newInstance(new Object[] {xpath});\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException) {\n                throw (RuntimeException)cause;\n            }\n            throw new RuntimeException(\"Invalid XPath Expression: \" + xpath + \" reason: \" + e.getMessage(), e);\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Invalid XPath Expression: \" + xpath + \" reason: \" + e.getMessage(), e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private XPathEvaluator createEvaluator(String xpath2) {\n        try {\n            return (XPathEvaluator)EVALUATOR_CONSTRUCTOR.newInstance(new Object[] {xpath, builder});\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof RuntimeException) {\n                throw (RuntimeException)cause;\n            }\n            throw new RuntimeException(\"Invalid XPath Expression: \" + xpath + \" reason: \" + e.getMessage(), e);\n        } catch (Throwable e) {\n            throw new RuntimeException(\"Invalid XPath Expression: \" + xpath + \" reason: \" + e.getMessage(), e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public WireFormat createWireFormat() {\n        WireFormatInfo info = new WireFormatInfo();\n        info.setVersion(version);\n\n        try {\n            info.setStackTraceEnabled(stackTraceEnabled);\n            info.setCacheEnabled(cacheEnabled);\n            info.setTcpNoDelayEnabled(tcpNoDelayEnabled);\n            info.setTightEncodingEnabled(tightEncodingEnabled);\n            info.setSizePrefixDisabled(sizePrefixDisabled);\n            info.setMaxInactivityDuration(maxInactivityDuration);\n            info.setMaxInactivityDurationInitalDelay(maxInactivityDurationInitalDelay);\n            info.setCacheSize(cacheSize);\n            info.setMaxFrameSize(maxFrameSize);\n            if( host!=null ) {\n                info.setHost(host);\n            }\n            info.setProviderName(providerName);\n            info.setProviderVersion(providerVersion);\n            info.setPlatformDetails(platformDetails);\n        } catch (Exception e) {\n            IllegalStateException ise = new IllegalStateException(\"Could not configure WireFormatInfo\");\n            ise.initCause(e);\n            throw ise;\n        }\n\n        OpenWireFormat f = new OpenWireFormat(version);\n        f.setMaxFrameSize(maxFrameSize);\n        f.setPreferedWireFormatInfo(info);\n        return f;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public WireFormat createWireFormat() {\n        WireFormatInfo info = new WireFormatInfo();\n        info.setVersion(version);\n\n        try {\n            info.setStackTraceEnabled(stackTraceEnabled);\n            info.setCacheEnabled(cacheEnabled);\n            info.setTcpNoDelayEnabled(tcpNoDelayEnabled);\n            info.setTightEncodingEnabled(tightEncodingEnabled);\n            info.setSizePrefixDisabled(sizePrefixDisabled);\n            info.setMaxInactivityDuration(maxInactivityDuration);\n            info.setMaxInactivityDurationInitalDelay(maxInactivityDurationInitalDelay);\n            info.setCacheSize(cacheSize);\n            info.setMaxFrameSize(maxFrameSize);\n            if( host!=null ) {\n                info.setHost(host);\n            }\n            info.setProviderName(providerName);\n            info.setProviderVersion(providerVersion);\n            if (includePlatformDetails) {\n                platformDetails = ActiveMQConnectionMetaData.PLATFORM_DETAILS;\n            }\n            info.setPlatformDetails(platformDetails);\n        } catch (Exception e) {\n            IllegalStateException ise = new IllegalStateException(\"Could not configure WireFormatInfo\");\n            ise.initCause(e);\n            throw ise;\n        }\n\n        OpenWireFormat f = new OpenWireFormat(version);\n        f.setMaxFrameSize(maxFrameSize);\n        f.setPreferedWireFormatInfo(info);\n        return f;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static boolean isAllAllowed() {\n        return getSerialziablePackages().length == 1 && getSerialziablePackages()[0].equals(\"*\");\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static boolean isAllAllowed() {\n        return serializablePackages.length == 1 && serializablePackages[0].equals(\"*\");\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\").replace(\"\\\\\", \"\").replace(\"/\", \"\");\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n            }\n            return guarded;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "private String guard(String filename) {\n            String guarded = filename.replace(\":\", \"_\");\n            guarded = FileSystems.getDefault().getPath(guarded).normalize().toString();\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"guarded \" + filename + \" to \" + guarded);\n            }\n            return guarded;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean evaluate(String text) {\n        try {\n            InputSource inputSource = new InputSource(new StringReader(text));\n            return ((Boolean)expression.evaluate(inputSource, XPathConstants.BOOLEAN)).booleanValue();\n        } catch (XPathExpressionException e) {\n            return false;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean evaluate(String text) {\n        try {\n            InputSource inputSource = new InputSource(new StringReader(text));\n            Document inputDocument = builder.parse(inputSource);\n            return ((Boolean) xpath.evaluate(xpathExpression, inputDocument, XPathConstants.BOOLEAN)).booleanValue();\n        } catch (Exception e) {\n            return false;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean evaluate(String text) {\n        try {\n            InputSource inputSource = new InputSource(new StringReader(text));\n            return ((Boolean)expression.evaluate(inputSource, XPathConstants.BOOLEAN)).booleanValue();\n        } catch (XPathExpressionException e) {\n            return false;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean evaluate(String text) {\n        try {\n            InputSource inputSource = new InputSource(new StringReader(text));\n            Document inputDocument = builder.parse(inputSource);\n            return ((Boolean)xpath.evaluate(xpathExpression, inputDocument, XPathConstants.BOOLEAN)).booleanValue();\n        } catch (Exception e) {\n            return false;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean evaluate(InputSource inputSource) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            DocumentBuilder dbuilder = factory.newDocumentBuilder();\n            Document doc = dbuilder.parse(inputSource);\n\n            //An XPath expression could return a true or false value instead of a node.\n            //eval() is a better way to determine the boolean value of the exp.\n            //For compliance with legacy behavior where selecting an empty node returns true,\n            //selectNodeIterator is attempted in case of a failure.\n\n            CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n            XObject result = cachedXPathAPI.eval(doc, xpath);\n            if (result.bool())\n            \treturn true;\n            else {\n            \tNodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            \treturn (iterator.nextNode() != null);\n            }\n\n        } catch (Throwable e) {\n            return false;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean evaluate(InputSource inputSource) {\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            setupFeatures(factory);\n            factory.setNamespaceAware(true);\n            factory.setIgnoringElementContentWhitespace(true);\n            factory.setIgnoringComments(true);\n            DocumentBuilder dbuilder = factory.newDocumentBuilder();\n            Document doc = dbuilder.parse(inputSource);\n\n            //An XPath expression could return a true or false value instead of a node.\n            //eval() is a better way to determine the boolean value of the exp.\n            //For compliance with legacy behavior where selecting an empty node returns true,\n            //selectNodeIterator is attempted in case of a failure.\n\n            CachedXPathAPI cachedXPathAPI = new CachedXPathAPI();\n            XObject result = cachedXPathAPI.eval(doc, xpath);\n            if (result.bool())\n            \treturn true;\n            else {\n            \tNodeIterator iterator = cachedXPathAPI.selectNodeIterator(doc, xpath);\n            \treturn (iterator.nextNode() != null);\n            }\n\n        } catch (Throwable e) {\n            return false;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Resource getResource(String pathInContext)\n    {\n        Resource r=null;\n        if (_relativeResourceBase!=null)\n            pathInContext=URIUtil.addPaths(_relativeResourceBase,pathInContext);\n\n        try\n        {\n            if (_resourceBase!=null)\n            {\n                r = _resourceBase.addPath(pathInContext);\n                if (!_contextHandler.checkAlias(pathInContext,r))\n                    r=null;\n            }\n            else if (_servletContext instanceof ContextHandler.Context)\n            {\n                r = _contextHandler.getResource(pathInContext);\n            }\n            else\n            {\n                URL u = _servletContext.getResource(pathInContext);\n                r = _contextHandler.newResource(u);\n            }\n\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Resource \"+pathInContext+\"=\"+r);\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n        }\n\n        if((r==null || !r.exists()) && pathInContext.endsWith(\"/jetty-dir.css\"))\n            r=_stylesheet;\n\n        return r;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Resource getResource(String pathInContext)\n    {\n        Resource r=null;\n        if (_relativeResourceBase!=null)\n            pathInContext=URIUtil.addPaths(_relativeResourceBase,pathInContext);\n\n        try\n        {\n            if (_resourceBase!=null)\n            {\n                r = _resourceBase.addPath(pathInContext);\n                if (!_contextHandler.checkAlias(pathInContext,r))\n                    r=null;\n            }\n            else if (_servletContext instanceof ContextHandler.Context)\n            {\n                r = _contextHandler.getResource(pathInContext);\n            }\n            else\n            {\n                URL u = _servletContext.getResource(pathInContext);\n                r = _contextHandler.newResource(u);\n            }\n\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Resource \"+pathInContext+\"=\"+r);\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n        }\n        catch (Throwable t)\n        {\n            // Any error has potential to reveal fully qualified path\n            throw (InvalidPathException) new InvalidPathException(pathInContext, \"Invalid PathInContext\").initCause(t);\n        }\n\n        if((r==null || !r.exists()) && pathInContext.endsWith(\"/jetty-dir.css\"))\n            r=_stylesheet;\n\n        return r;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private IllegalCharacterException(State state,byte ch,ByteBuffer buffer)\n        {\n            super(String.format(\"Illegal character 0x%X in state=%s for buffer %s\",ch,state,toDebugString(buffer)));\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "private IllegalCharacterException(State state,byte ch,ByteBuffer buffer)\n        {\n            super(400,String.format(\"Illegal character 0x%X\",ch));\n            // Bug #460642 - don't reveal buffers to end user\n            LOG.warn(String.format(\"Illegal character 0x%X in state=%s for buffer %s\",ch,state,BufferUtil.toDetailString(buffer)));\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean check(String uri, Resource resource)\n    {\n        // Only support PathResource alias checking\n        if (!(resource instanceof PathResource))\n            return false;\n        \n        PathResource pathResource = (PathResource)resource;\n\n        try\n        {\n            Path path = pathResource.getPath();\n            Path alias = pathResource.getAliasPath();\n            \n            // is the file itself a symlink?\n            if (Files.isSymbolicLink(path))\n            {        \n                alias = path.getParent().resolve(alias);\n                if (LOG.isDebugEnabled())\n                {\n                    LOG.debug(\"path ={}\",path);\n                    LOG.debug(\"alias={}\",alias);\n                }\n                if (Files.isSameFile(path,alias))\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Allow symlink {} --> {}\",resource,pathResource.getAliasPath());\n                    return true;\n                }\n            }\n\n            // No, so let's check each element ourselves\n            boolean linked=true;\n            Path target=path;\n            int loops=0;\n            while (linked)\n            {\n                if (++loops>100)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Too many symlinks {} --> {}\",resource,target);\n                    return false;\n                }\n                linked=false;\n                Path d = target.getRoot();\n                for (Path e:target)\n                {\n                    Path r=d.resolve(e);\n                    d=r;\n\n                    while (Files.exists(d) && Files.isSymbolicLink(d))\n                    {\n                        Path link=Files.readSymbolicLink(d);    \n                        if (!link.isAbsolute())\n                            link=d.getParent().resolve(link);\n                        d=link;\n                        linked=true;\n                    }\n                }\n                target=d;\n            }\n            \n            if (pathResource.getAliasPath().equals(target))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Allow path symlink {} --> {}\",resource,target);\n                return true;\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.ignore(e);\n        }\n        \n        return false;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean check(String uri, Resource resource)\n    {\n        // Only support PathResource alias checking\n        if (!(resource instanceof PathResource))\n            return false;\n        \n        PathResource pathResource = (PathResource)resource;\n\n        try\n        {\n            Path path = pathResource.getPath();\n            Path alias = pathResource.getAliasPath();\n\n            if (path.equals(alias))\n                return false; // Unknown why this is an alias\n\n            // is the file itself a symlink?\n            if (Files.isSymbolicLink(path))\n            {        \n                alias = path.getParent().resolve(alias);\n                if (LOG.isDebugEnabled())\n                {\n                    LOG.debug(\"path ={}\",path);\n                    LOG.debug(\"alias={}\",alias);\n                }\n                if (Files.isSameFile(path,alias))\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Allow symlink {} --> {}\",resource,pathResource.getAliasPath());\n                    return true;\n                }\n            }\n\n            // No, so let's check each element ourselves\n            boolean linked=true;\n            Path target=path;\n            int loops=0;\n            while (linked)\n            {\n                if (++loops>100)\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Too many symlinks {} --> {}\",resource,target);\n                    return false;\n                }\n                linked=false;\n                Path d = target.getRoot();\n                for (Path e:target)\n                {\n                    Path r=d.resolve(e);\n                    d=r;\n\n                    while (Files.exists(d) && Files.isSymbolicLink(d))\n                    {\n                        Path link=Files.readSymbolicLink(d);    \n                        if (!link.isAbsolute())\n                            link=d.getParent().resolve(link);\n                        d=link;\n                        linked=true;\n                    }\n                }\n                target=d;\n            }\n            \n            if (pathResource.getAliasPath().equals(target))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Allow path symlink {} --> {}\",resource,target);\n                return true;\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.ignore(e);\n        }\n        \n        return false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean check(Object credentials)\n        {\n            if (credentials instanceof char[])\n                credentials=new String((char[])credentials);\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean check(Object credentials)\n        {\n            if (credentials instanceof char[])\n                credentials=new String((char[])credentials);\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return stringEquals(TypeUtil.toString(digest, 16).toLowerCase(), response == null ? null : response.toLowerCase());\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean check(Object credentials)\n        {\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return (TypeUtil.toString(digest, 16).equalsIgnoreCase(response));\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean check(Object credentials)\n        {\n            String password = (credentials instanceof String) ? (String) credentials : credentials.toString();\n\n            try\n            {\n                MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                byte[] ha1;\n                if (credentials instanceof Credential.MD5)\n                {\n                    // Credentials are already a MD5 digest - assume it's in\n                    // form user:realm:password (we have no way to know since\n                    // it's a digest, alright?)\n                    ha1 = ((Credential.MD5) credentials).getDigest();\n                }\n                else\n                {\n                    // calc A1 digest\n                    md.update(username.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(realm.getBytes(StandardCharsets.ISO_8859_1));\n                    md.update((byte) ':');\n                    md.update(password.getBytes(StandardCharsets.ISO_8859_1));\n                    ha1 = md.digest();\n                }\n                // calc A2 digest\n                md.reset();\n                md.update(method.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(uri.getBytes(StandardCharsets.ISO_8859_1));\n                byte[] ha2 = md.digest();\n\n                // calc digest\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\"\n                // nc-value \":\" unq(cnonce-value) \":\" unq(qop-value) \":\" H(A2) )\n                // <\">\n                // request-digest = <\"> < KD ( H(A1), unq(nonce-value) \":\" H(A2)\n                // ) > <\">\n\n                md.update(TypeUtil.toString(ha1, 16).getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(nc.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(cnonce.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(qop.getBytes(StandardCharsets.ISO_8859_1));\n                md.update((byte) ':');\n                md.update(TypeUtil.toString(ha2, 16).getBytes(StandardCharsets.ISO_8859_1));\n                byte[] digest = md.digest();\n\n                // check digest\n                return stringEquals(TypeUtil.toString(digest, 16).toLowerCase(), response == null ? null : response.toLowerCase());\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n            }\n\n            return false;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static Collection<Object[]> data() \n    {\n        List<Object[]> data = new ArrayList<>();\n        data.add(new Class<?>[]{FileResource.class});\n        data.add(new Class<?>[]{PathResource.class});\n        return data;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static Collection<Object[]> data()\n    {\n        List<Object[]> data = new ArrayList<>();\n        data.add(new Class<?>[]{FileResource.class});\n        data.add(new Class<?>[]{PathResource.class});\n        return data;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "Path checkAliasPath(final Path path)\n    {\n        Path abs = path;\n        if (!abs.isAbsolute())\n        {\n            abs = path.toAbsolutePath();\n        }\n\n        try\n        {\n            if (Files.isSymbolicLink(path))\n                return Files.readSymbolicLink(path);\n            if (Files.exists(path))\n            {\n                Path real = abs.toRealPath(FOLLOW_LINKS);\n                \n                /*\n                 * If the real path is not the same as the absolute path\n                 * then we know that the real path is the alias for the\n                 * provided path.\n                 *\n                 * For OS's that are case insensitive, this should\n                 * return the real (on-disk / case correct) version\n                 * of the path.\n                 *\n                 * We have to be careful on Windows and OSX.\n                 * \n                 * Assume we have the following scenario\n                 *   Path a = new File(\"foo\").toPath();\n                 *   Files.createFile(a);\n                 *   Path b = new File(\"FOO\").toPath();\n                 * \n                 * There now exists a file called \"foo\" on disk.\n                 * Using Windows or OSX, with a Path reference of\n                 * \"FOO\", \"Foo\", \"fOO\", etc.. means the following\n                 * \n                 *                        |  OSX    |  Windows   |  Linux\n                 * -----------------------+---------+------------+---------\n                 * Files.exists(a)        |  True   |  True      |  True\n                 * Files.exists(b)        |  True   |  True      |  False\n                 * Files.isSameFile(a,b)  |  True   |  True      |  False\n                 * a.equals(b)            |  False  |  True      |  False\n                 * \n                 * See the javadoc for Path.equals() for details about this FileSystem\n                 * behavior difference\n                 * \n                 * We also cannot rely on a.compareTo(b) as this is roughly equivalent\n                 * in implementation to a.equals(b)\n                 */\n                \n                int absCount = abs.getNameCount();\n                int realCount = real.getNameCount();\n                if (absCount != realCount)\n                {\n                    // different number of segments\n                    return real;\n                }\n                \n                // compare each segment of path, backwards\n                for (int i = realCount-1; i >= 0; i--)\n                {\n                    if (!abs.getName(i).toString().equals(real.getName(i).toString()))\n                    {\n                        return real;\n                    }\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n        }\n        catch (Exception e)\n        {\n            LOG.warn(\"bad alias ({} {}) for {}\", e.getClass().getName(), e.getMessage(),path);\n        }\n        return null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "Path checkAliasPath()\n    {\n        Path abs = path;\n\n        /* Catch situation where the Path class has already normalized\n         * the URI eg. input path \"aa./foo.txt\"\n         * from an #addPath(String) is normalized away during\n         * the creation of a Path object reference.\n         * If the URI is different then the Path.toUri() then\n         * we will just use the original URI to construct the\n         * alias reference Path.\n         */\n\n        if(!URIUtil.equalsIgnoreEncodings(uri,path.toUri()))\n        {\n            return new File(uri).toPath().toAbsolutePath();\n        }\n\n        if (!abs.isAbsolute())\n        {\n            abs = path.toAbsolutePath();\n        }\n\n        try\n        {\n            if (Files.isSymbolicLink(path))\n                return Files.readSymbolicLink(path);\n            if (Files.exists(path))\n            {\n                Path real = abs.toRealPath(FOLLOW_LINKS);\n                \n                /*\n                 * If the real path is not the same as the absolute path\n                 * then we know that the real path is the alias for the\n                 * provided path.\n                 *\n                 * For OS's that are case insensitive, this should\n                 * return the real (on-disk / case correct) version\n                 * of the path.\n                 *\n                 * We have to be careful on Windows and OSX.\n                 * \n                 * Assume we have the following scenario\n                 *   Path a = new File(\"foo\").toPath();\n                 *   Files.createFile(a);\n                 *   Path b = new File(\"FOO\").toPath();\n                 * \n                 * There now exists a file called \"foo\" on disk.\n                 * Using Windows or OSX, with a Path reference of\n                 * \"FOO\", \"Foo\", \"fOO\", etc.. means the following\n                 * \n                 *                        |  OSX    |  Windows   |  Linux\n                 * -----------------------+---------+------------+---------\n                 * Files.exists(a)        |  True   |  True      |  True\n                 * Files.exists(b)        |  True   |  True      |  False\n                 * Files.isSameFile(a,b)  |  True   |  True      |  False\n                 * a.equals(b)            |  False  |  True      |  False\n                 * \n                 * See the javadoc for Path.equals() for details about this FileSystem\n                 * behavior difference\n                 * \n                 * We also cannot rely on a.compareTo(b) as this is roughly equivalent\n                 * in implementation to a.equals(b)\n                 */\n                \n                int absCount = abs.getNameCount();\n                int realCount = real.getNameCount();\n                if (absCount != realCount)\n                {\n                    // different number of segments\n                    return real;\n                }\n                \n                // compare each segment of path, backwards\n                for (int i = realCount-1; i >= 0; i--)\n                {\n                    if (!abs.getName(i).toString().equals(real.getName(i).toString()))\n                    {\n                        return real;\n                    }\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            LOG.ignore(e);\n        }\n        catch (Exception e)\n        {\n            LOG.warn(\"bad alias ({} {}) for {}\", e.getClass().getName(), e.getMessage(),path);\n        }\n        return null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public PathResource(Path path)\n    {\n        this.path = path.toAbsolutePath();\n        assertValidPath(path);\n        this.uri = this.path.toUri();\n        this.alias = checkAliasPath(path);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public PathResource(Path path)\n    {\n        this.path = path.toAbsolutePath();\n        assertValidPath(path);\n        this.uri = this.path.toUri();\n        this.alias = checkAliasPath();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public FileResource(File file)\n    {\n        assertValidPath(file.toString());\n        _file=file;\n        _uri=normalizeURI(_file,_file.toURI());\n        _alias=checkFileAlias(_file);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public FileResource(File base, String childPath)\n    {\n        String encoded = URIUtil.encodePath(childPath);\n\n        _file = new File(base, childPath);\n\n        // The encoded path should be a suffix of the resource (give or take a directory / )\n        URI uri;\n        try\n        {\n            if (base.isDirectory())\n            {\n                // treat all paths being added as relative\n                uri=new URI(URIUtil.addPaths(base.toURI().toASCIIString(),encoded));\n            }\n            else\n            {\n                uri=new URI(base.toURI().toASCIIString()+encoded);\n            }\n        }\n        catch (final URISyntaxException e)\n        {\n            throw new InvalidPathException(base.toString() + childPath, e.getMessage())\n            {\n                {\n                    initCause(e);\n                }\n            };\n        }\n\n        _uri=uri;\n        _alias=checkFileAlias(_uri,_file);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private static URI checkFileAlias(File file)\n    {\n        try\n        {\n            String abs=file.getAbsolutePath();\n            String can=file.getCanonicalPath();\n\n            if (!abs.equals(can))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"ALIAS abs={} can={}\",abs,can);\n\n                URI alias=new File(can).toURI();\n                // Have to encode the path as File.toURI does not!\n                String uri=\"file://\"+URIUtil.encodePath(alias.getPath());\n                return new URI(uri);\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.warn(\"bad alias for {}: {}\",file,e.toString());\n            LOG.debug(e);\n            try\n            {\n                return new URI(\"http://eclipse.org/bad/canonical/alias\");\n            }\n            catch(Exception e2)\n            {\n                LOG.ignore(e2);\n                throw new RuntimeException(e);\n            }\n        }\n\n        return null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private static URI checkFileAlias(final URI uri, final File file)\n    {\n        try\n        {\n            if (!URIUtil.equalsIgnoreEncodings(uri,file.toURI()))\n            {\n                // Return alias pointing to Java File normalized URI\n                return new File(uri).getAbsoluteFile().toURI();\n            }\n\n            String abs=file.getAbsolutePath();\n            String can=file.getCanonicalPath();\n\n            if (!abs.equals(can))\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"ALIAS abs={} can={}\",abs,can);\n\n                URI alias=new File(can).toURI();\n                // Have to encode the path as File.toURI does not!\n                return new URI(\"file://\"+URIUtil.encodePath(alias.getPath()));\n            }\n        }\n        catch(Exception e)\n        {\n            LOG.warn(\"bad alias for {}: {}\",file,e.toString());\n            LOG.debug(e);\n            try\n            {\n                return new URI(\"http://eclipse.org/bad/canonical/alias\");\n            }\n            catch(Exception e2)\n            {\n                LOG.ignore(e2);\n                throw new RuntimeException(e);\n            }\n        }\n\n        return null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean isDirectory()\n    {\n        return _file.exists() && _file.isDirectory() || _uri.endsWith(\"/\");\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean isDirectory()\n    {\n        return _file.exists() && _file.isDirectory() || _uri.toASCIIString().endsWith(\"/\");\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String[] list()\n    {\n        String[] list =_file.list();\n        if (list==null)\n            return null;\n        for (int i=list.length;i-->0;)\n        {\n            if (new File(_file,list[i]).isDirectory() &&\n                !list[i].endsWith(\"/\"))\n                list[i]+=\"/\";\n        }\n        return list;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String[] list()\n    {\n        String[] list =_file.list();\n        if (list==null)\n            return null;\n        for (int i=list.length;i-->0;)\n        {\n            if (new File(_file,list[i]).isDirectory() &&\n                    !list[i].endsWith(\"/\"))\n                list[i]+=\"/\";\n        }\n        return list;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public int hashCode()\n    {\n       return null == _file ? super.hashCode() : _file.hashCode();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public int hashCode()\n    {\n        return null == _file ? super.hashCode() : _file.hashCode();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public URL getURL()\n    {\n        try\n        {\n            return new URL(_uri);\n        }\n        catch (MalformedURLException e)\n        {\n            throw new IllegalStateException(e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public URL getURL()\n    {\n        try\n        {\n            return _uri.toURL();\n        }\n        catch (MalformedURLException e)\n        {\n            throw new IllegalStateException(e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public URI getURI()\n    {\n        return _file.toURI();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public URI getURI()\n    {\n        return _uri;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String toString()\n    {\n        return _uri;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String toString()\n    {\n        return _uri.toString();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean check(Object credentials)\n    {\n        if (this == credentials) return true;\n\n        if (credentials instanceof Password) return credentials.equals(_pw);\n\n        if (credentials instanceof String) return credentials.equals(_pw);\n\n        if (credentials instanceof char[]) return Arrays.equals(_pw.toCharArray(), (char[]) credentials);\n\n        if (credentials instanceof Credential) return ((Credential) credentials).check(_pw);\n\n        return false;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean check(Object credentials)\n    {\n        if (this == credentials)\n            return true;\n\n        if (credentials instanceof Password)\n            return credentials.equals(_pw);\n\n        if (credentials instanceof String)\n            return stringEquals(_pw, (String)credentials);\n\n        if (credentials instanceof char[])\n            return stringEquals(_pw, new String((char[])credentials));\n\n        if (credentials instanceof Credential)\n            return ((Credential)credentials).check(_pw);\n\n        return false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean equals(Object o)\n    {\n        if (this == o)\n            return true;\n\n        if (null == o)\n            return false;\n\n        if (o instanceof Password)\n        {\n            Password p = (Password) o;\n            //noinspection StringEquality\n            return p._pw == _pw || (null != _pw && _pw.equals(p._pw));\n        }\n\n        if (o instanceof String)\n            return o.equals(_pw);\n\n        return false;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean equals(Object o)\n    {\n        if (this == o)\n            return true;\n\n        if (null == o)\n            return false;\n\n        if (o instanceof Password)\n            return stringEquals(_pw, ((Password)o)._pw);\n\n        if (o instanceof String)\n            return stringEquals(_pw, (String)o);\n\n        return false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static String obfuscate(String s)\n    {\n        StringBuilder buf = new StringBuilder();\n        byte[] b = s.getBytes(StandardCharsets.UTF_8);\n\n        buf.append(__OBFUSCATE);\n        for (int i = 0; i < b.length; i++)\n        {\n            byte b1 = b[i];\n            byte b2 = b[b.length - (i + 1)];\n            if (b1<0 || b2<0)\n            {\n                int i0 = (0xff&b1)*256 + (0xff&b2);\n                String x = Integer.toString(i0, 36).toLowerCase(Locale.ENGLISH);\n                buf.append(\"U0000\",0,5-x.length());\n                buf.append(x);\n            }\n            else\n            {\n                int i1 = 127 + b1 + b2;\n                int i2 = 127 + b1 - b2;\n                int i0 = i1 * 256 + i2;\n                String x = Integer.toString(i0, 36).toLowerCase(Locale.ENGLISH);\n\n                int j0 = Integer.parseInt(x, 36);\n                int j1 = (i0 / 256);\n                int j2 = (i0 % 256);\n                byte bx = (byte) ((j1 + j2 - 254) / 2);\n\n                buf.append(\"000\",0,4-x.length());\n                buf.append(x);\n            }\n\n        }\n        return buf.toString();\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static String obfuscate(String s)\n    {\n        StringBuilder buf = new StringBuilder();\n        byte[] b = s.getBytes(StandardCharsets.UTF_8);\n\n        buf.append(__OBFUSCATE);\n        for (int i = 0; i < b.length; i++)\n        {\n            byte b1 = b[i];\n            byte b2 = b[b.length - (i + 1)];\n            if (b1<0 || b2<0)\n            {\n                int i0 = (0xff&b1)*256 + (0xff&b2);\n                String x = Integer.toString(i0, 36).toLowerCase(Locale.ENGLISH);\n                buf.append(\"U0000\",0,5-x.length());\n                buf.append(x);\n            }\n            else\n            {\n                int i1 = 127 + b1 + b2;\n                int i2 = 127 + b1 - b2;\n                int i0 = i1 * 256 + i2;\n                String x = Integer.toString(i0, 36).toLowerCase(Locale.ENGLISH);\n\n                int j0 = Integer.parseInt(x, 36);\n                int j1 = (i0 / 256);\n                int j2 = (i0 % 256);\n                byte bx = (byte) ((j1 + j2 - 254) / 2);\n\n                buf.append(\"000\",0,4-x.length());\n                buf.append(x);\n            }\n\n        }\n        return buf.toString();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean check(Object credentials)\n        {\n            try\n            {\n                if (credentials instanceof char[])\n                    credentials=new String((char[])credentials);\n                if (credentials instanceof Password || credentials instanceof String)\n                {\n                    byte[] digest;\n                    synchronized (__md5Lock)\n                    {\n                        if (__md == null) __md = MessageDigest.getInstance(\"MD5\");\n                        __md.reset();\n                        __md.update(credentials.toString().getBytes(StandardCharsets.ISO_8859_1));\n                        digest = __md.digest();\n                    }\n                    if (digest == null || digest.length != _digest.length) return false;\n                    boolean digestMismatch = false;\n                    for (int i = 0; i < digest.length; i++)\n                        digestMismatch |= (digest[i] != _digest[i]);\n                    return !digestMismatch;\n                }\n                else if (credentials instanceof MD5)\n                {\n                    MD5 md5 = (MD5) credentials;\n                    if (_digest.length != md5._digest.length) return false;\n                    boolean digestMismatch = false;\n                    for (int i = 0; i < _digest.length; i++)\n                        digestMismatch |= (_digest[i] != md5._digest[i]);\n                    return !digestMismatch;\n                }\n                else if (credentials instanceof Credential)\n                {\n                    // Allow credential to attempt check - i.e. this'll work\n                    // for DigestAuthModule$Digest credentials\n                    return ((Credential) credentials).check(this);\n                }\n                else\n                {\n                    LOG.warn(\"Can't check \" + credentials.getClass() + \" against MD5\");\n                    return false;\n                }\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n                return false;\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean check(Object credentials)\n        {\n            try\n            {\n                if (credentials instanceof char[])\n                    credentials=new String((char[])credentials);\n                if (credentials instanceof Password || credentials instanceof String)\n                {\n                    byte[] digest;\n                    synchronized (__md5Lock)\n                    {\n                        if (__md == null) __md = MessageDigest.getInstance(\"MD5\");\n                        __md.reset();\n                        __md.update(credentials.toString().getBytes(StandardCharsets.ISO_8859_1));\n                        digest = __md.digest();\n                    }\n                    return byteEquals(_digest, digest);\n                }\n                else if (credentials instanceof MD5)\n                {\n                    MD5 md5 = (MD5)credentials;\n                    return byteEquals(_digest, md5._digest);\n                }\n                else if (credentials instanceof Credential)\n                {\n                    // Allow credential to attempt check - i.e. this'll work\n                    // for DigestAuthModule$Digest credentials\n                    return ((Credential)credentials).check(this);\n                }\n                else\n                {\n                    LOG.warn(\"Can't check \" + credentials.getClass() + \" against MD5\");\n                    return false;\n                }\n            }\n            catch (Exception e)\n            {\n                LOG.warn(e);\n                return false;\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "else if (credentials instanceof Credential)\n                {\n                    // Allow credential to attempt check - i.e. this'll work\n                    // for DigestAuthModule$Digest credentials\n                    return ((Credential) credentials).check(this);\n                }",
    "is_vulnerable": true
  },
  {
    "function_code": "else if (credentials instanceof Credential)\n                {\n                    // Allow credential to attempt check - i.e. this'll work\n                    // for DigestAuthModule$Digest credentials\n                    return ((Credential)credentials).check(this);\n                }",
    "is_vulnerable": false
  },
  {
    "function_code": "public PyBytecode(int argcount, int nlocals, int stacksize, int flags,\n            String codestring, PyObject[] constants, String[] names, String varnames[],\n            String filename, String name, int firstlineno, String lnotab,\n            String[] cellvars, String[] freevars) {\n\n        debug = defaultDebug;\n\n        co_argcount = nargs = argcount;\n        co_varnames = varnames;\n        co_nlocals = nlocals; // maybe assert = varnames.length;\n        co_filename = filename;\n        co_firstlineno = firstlineno;\n        co_cellvars = cellvars;\n        co_freevars = freevars;\n        co_name = name;\n        co_flags = new CompilerFlags(flags);\n        varargs = co_flags.isFlagSet(CodeFlag.CO_VARARGS);\n        varkwargs = co_flags.isFlagSet(CodeFlag.CO_VARKEYWORDS);\n\n        co_stacksize = stacksize;\n        co_consts = constants;\n        co_names = names;\n        co_code = getBytes(codestring);\n        co_lnotab = getBytes(lnotab);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public PyBytecode(int argcount, int nlocals, int stacksize, int flags,\n            String codestring, PyObject[] constants, String[] names, String varnames[],\n            String filename, String name, int firstlineno, String lnotab,\n            String[] cellvars, String[] freevars) {\n\n        debug = defaultDebug;\n\n        if (argcount < 0) {\n            throw Py.ValueError(\"code: argcount must not be negative\");\n        } else if (nlocals < 0) {\n            throw Py.ValueError(\"code: nlocals must not be negative\");\n        }\n\n        co_argcount = nargs = argcount;\n        co_varnames = varnames;\n        co_nlocals = nlocals; // maybe assert = varnames.length;\n        co_filename = filename;\n        co_firstlineno = firstlineno;\n        co_cellvars = cellvars;\n        co_freevars = freevars;\n        co_name = name;\n        co_flags = new CompilerFlags(flags);\n        varargs = co_flags.isFlagSet(CodeFlag.CO_VARARGS);\n        varkwargs = co_flags.isFlagSet(CodeFlag.CO_VARKEYWORDS);\n\n        co_stacksize = stacksize;\n        co_consts = constants;\n        co_names = names;\n        co_code = getBytes(codestring);\n        co_lnotab = getBytes(lnotab);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DefaultEditorPage()\n\t{\n\t\tForm<Void> form = new Form<Void>(\"form\");\n\t\tthis.add(form);\n\n\t\t// FeedbackPanel //\n\t\tfinal KendoFeedbackPanel feedback = new KendoFeedbackPanel(\"feedback\");\n\t\tform.add(feedback);\n\n\t\t// ComboBox //\n\t\tfinal Editor<String> editor = new Editor<String>(\"editor\", Model.of(\"<p>test</p>\"));\n\t\tform.add(editor.setEscapeModelStrings(false));\n\n\t\t// Buttons //\n\t\tform.add(new Button(\"button\") {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onSubmit()\n\t\t\t{\n\t\t\t\tString html = editor.getModelObject();\n\n\t\t\t\tthis.info(html != null ? html : \"empty\");\n\t\t\t}\n\t\t});\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public DefaultEditorPage()\n\t{\n\t\tForm<Void> form = new Form<Void>(\"form\");\n\t\tthis.add(form);\n\n\t\t// FeedbackPanel //\n\t\tfinal KendoFeedbackPanel feedback = new KendoFeedbackPanel(\"feedback\");\n\t\tform.add(feedback);\n\n\t\t// ComboBox //\n\t\tfinal Editor editor = new Editor(\"editor\", Model.of(\"<p>test</p>\"));\n\t\tform.add(editor.setEscapeModelStrings(false));\n\n\t\t// Buttons //\n\t\tform.add(new Button(\"button\") {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void onSubmit()\n\t\t\t{\n\t\t\t\tString html = editor.getModelObject();\n\n\t\t\t\tthis.info(html != null ? html : \"empty\");\n\t\t\t}\n\t\t});\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public void convertInput()\n\t{\n\t\tfinal PolicyFactory policy = this.newPolicyFactory();\n\t\tfinal String html = this.textarea.getConvertedInput();\n\n\t\tthis.setConvertedInput(policy.sanitize(html));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void convertInput()\n\t{\n\t\tfinal PolicyFactory policy = newPolicyFactory();\n\t\tfinal String input = this.textarea.getConvertedInput();\n\n\t\tthis.setConvertedInput(policy.sanitize(input));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected PolicyFactory newPolicyFactory()\n\t{\n\t\treturn new HtmlPolicyBuilder() // lf\n\t\t\t\t.allowCommonInlineFormattingElements() // lf\n\t\t\t\t.allowCommonBlockElements() // lf\n\t\t\t\t.allowElements(\"a\").allowAttributes(\"href\", \"target\").onElements(\"a\") // lf\n\t\t\t\t.allowAttributes(\"size\").onElements(\"font\") // lf\n\t\t\t\t.allowAttributes(\"class\", \"style\").globally() // lf\n\t\t\t\t.toFactory();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "protected static PolicyFactory newPolicyFactory()\n\t{\n\t\treturn new HtmlPolicyBuilder() // lf\n\t\t\t\t.allowCommonInlineFormattingElements() // lf\n\t\t\t\t.allowCommonBlockElements() // lf\n\t\t\t\t.allowElements(\"a\").allowAttributes(\"href\", \"target\").onElements(\"a\") // lf\n\t\t\t\t.allowAttributes(\"size\").onElements(\"font\") // lf\n\t\t\t\t.allowAttributes(\"class\", \"style\").globally() // lf\n\t\t\t\t.toFactory();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void reload(AjaxRequestTarget target, Component component, KendoEffect effect, boolean reverse)\n\t{\n\t\tString selector = JQueryWidget.getSelector(component);\n\n\t\ttarget.add(component);\n\t\ttarget.appendJavaScript(String.format(\"kendo.fx(jQuery('%s')).%s.%s();\", selector, effect, !reverse ? \"play\" : \"reverse\"));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void reload(IPartialPageRequestHandler handler, Component component, KendoEffect effect, boolean reverse)\n\t{\n\t\tString selector = JQueryWidget.getSelector(component);\n\n\t\thandler.add(component);\n\t\thandler.appendJavaScript(String.format(\"kendo.fx(jQuery('%s')).%s.%s();\", selector, effect, !reverse ? \"play\" : \"reverse\"));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public ChartPayload(AjaxRequestTarget target, String seriesName, String seriesField, String category, long value)\n\t{\n\t\tsuper(target);\n\n\t\tthis.value = value;\n\t\tthis.category = category;\n\t\tthis.seriesName = seriesName;\n\t\tthis.seriesField = seriesField;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ChartPayload(IPartialPageRequestHandler handler, String seriesName, String seriesField, String category, long value)\n\t{\n\t\tsuper(handler);\n\n\t\tthis.value = value;\n\t\tthis.category = category;\n\t\tthis.seriesName = seriesName;\n\t\tthis.seriesField = seriesField;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public Editor(String id, IModel<T> model, Options options)\n\t{\n\t\tsuper(id, model);\n\n\t\tthis.options = Args.notNull(options, \"options\");\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public Editor(String id, IModel<String> model, Options options)\n\t{\n\t\tsuper(id, model);\n\n\t\tthis.options = Args.notNull(options, \"options\");\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public RefreshPayload(int index, AjaxRequestTarget target)\n\t\t{\n\t\t\tsuper(target);\n\n\t\t\tthis.index = index;\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public RefreshPayload(int index, IPartialPageRequestHandler handler)\n\t\t{\n\t\t\tsuper(handler);\n\n\t\t\tthis.index = index;\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void reload(Component component, AjaxRequestTarget target)\n\t{\n\t\tBroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void reload(IPartialPageRequestHandler handler)\n\t{\n\t\tBroadcastUtils.breadth(handler, new FeedbackPayload(handler));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void debug(Component component, AjaxRequestTarget target, String message)\n\t{\n\t\tBroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.DEBUG, message));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void debug(IPartialPageRequestHandler handler, String message)\n\t{\n\t\tBroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.DEBUG, message));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void info(Component component, AjaxRequestTarget target, String message)\n\t{\n\t\tBroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.INFO, message));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void info(IPartialPageRequestHandler handler, String message)\n\t{\n\t\tBroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.INFO, message));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void success(Component component, AjaxRequestTarget target, String message)\n\t{\n\t\tBroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.SUCCESS, message));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void success(IPartialPageRequestHandler handler, String message)\n\t{\n\t\tBroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.SUCCESS, message));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void warn(Component component, AjaxRequestTarget target, String message)\n\t{\n\t\tBroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.WARNING, message));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void warn(IPartialPageRequestHandler handler, String message)\n\t{\n\t\tBroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.WARNING, message));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void error(Component component, AjaxRequestTarget target, String message)\n\t{\n\t\tBroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.ERROR, message));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void error(IPartialPageRequestHandler handler, String message)\n\t{\n\t\tBroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.ERROR, message));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void fatal(Component component, AjaxRequestTarget target, String message)\n\t{\n\t\tBroadcastUtils.breadth(component.getPage(), new FeedbackPayload(target, FeedbackMessage.FATAL, message));\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void fatal(IPartialPageRequestHandler handler, String message)\n\t{\n\t\tBroadcastUtils.breadth(handler, new FeedbackPayload(handler, FeedbackMessage.FATAL, message));\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void breadth(Component component, AjaxPayload payload)\n\t{\n\t\tcomponent.send(component, Broadcast.BREADTH, payload);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void breadth(IPartialPageRequestHandler handler, HandlerPayload payload)\n\t{\n\t\tBroadcastUtils.breadth((Page) handler.getPage(), payload);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void bubble(Component component, AjaxPayload payload)\n\t{\n\t\tcomponent.send(component, Broadcast.BUBBLE, payload);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void bubble(IPartialPageRequestHandler handler, HandlerPayload payload)\n\t{\n\t\tBroadcastUtils.bubble((Page) handler.getPage(), payload);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void depth(Component component, AjaxPayload payload)\n\t{\n\t\tcomponent.send(component, Broadcast.DEPTH, payload);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void depth(IPartialPageRequestHandler handler, HandlerPayload payload)\n\t{\n\t\tBroadcastUtils.depth((Page) handler.getPage(), payload);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void exact(Component component, AjaxPayload payload)\n\t{\n\t\tcomponent.send(component, Broadcast.EXACT, payload);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void exact(IPartialPageRequestHandler handler, HandlerPayload payload)\n\t{\n\t\tBroadcastUtils.exact((Page) handler.getPage(), payload);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public FeedbackPayload(AjaxRequestTarget target, int level, String message)\n\t{\n\t\tsuper(target);\n\n\t\tthis.level = level;\n\t\tthis.message = message;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public FeedbackPayload(IPartialPageRequestHandler handler, int level, String message)\n\t{\n\t\tsuper(handler);\n\n\t\tthis.level = level;\n\t\tthis.message = message;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public SnakeYAMLDataFormat(Class<?> type) {\n        this.yamlCache = new ThreadLocal<>();\n        this.useApplicationContextClassLoader = true;\n        this.prettyFlow = false;\n        this.allowAnyType = false;\n\n        if (type != null) {\n            setUnmarshalType(type);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public SnakeYAMLDataFormat(Class<?> type) {\n        this.yamlCache = new ThreadLocal<>();\n        this.useApplicationContextClassLoader = true;\n        this.prettyFlow = false;\n        this.allowAnyType = false;\n\n        if (type != null) {\n            this.unmarshalType = type;\n            this.typeFilters = new CopyOnWriteArrayList<>();\n            this.typeFilters.add(TypeFilters.types(type));\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected XStream createXStream(ClassResolver resolver, ClassLoader classLoader) {\n        if (xstreamDriver != null) {\n            xstream = new XStream(xstreamDriver);\n        } else {\n            xstream = new XStream();\n        }\n\n        if (mode != null) {\n            xstream.setMode(getModeFromString(mode));\n        }\n\n        ClassLoader xstreamLoader = xstream.getClassLoader();\n        if (classLoader != null && xstreamLoader instanceof CompositeClassLoader) {\n            ((CompositeClassLoader) xstreamLoader).add(classLoader);\n        }\n\n        try {\n            if (this.implicitCollections != null) {\n                for (Entry<String, String[]> entry : this.implicitCollections.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.addImplicitCollection(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.aliases != null) {\n                for (Entry<String, String> entry : this.aliases.entrySet()) {\n                    xstream.alias(entry.getKey(), resolver.resolveMandatoryClass(entry.getValue()));\n                    // It can turn the auto-detection mode off\n                    xstream.processAnnotations(resolver.resolveMandatoryClass(entry.getValue()));\n                }\n            }\n\n            if (this.omitFields != null) {\n                for (Entry<String, String[]> entry : this.omitFields.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.omitField(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.converters != null) {\n                for (String name : this.converters) {\n                    Class<Converter> converterClass = resolver.resolveMandatoryClass(name, Converter.class);\n                    Converter converter;\n\n                    Constructor<Converter> con = null;\n                    try {\n                        con = converterClass.getDeclaredConstructor(new Class[]{XStream.class});\n                    } catch (Exception e) {\n                        //swallow as we null check in a moment.\n                    }\n                    if (con != null) {\n                        converter = con.newInstance(xstream);\n                    } else {\n                        converter = converterClass.newInstance();\n                        try {\n                            Method method = converterClass.getMethod(\"setXStream\", new Class[]{XStream.class});\n                            if (method != null) {\n                                ObjectHelper.invokeMethod(method, converter, xstream);\n                            }\n                        } catch (Throwable e) {\n                            // swallow, as it just means the user never add an XStream setter, which is optional\n                        }\n                    }\n\n                    xstream.registerConverter(converter);\n                }\n            }\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to build XStream instance\", e);\n        }\n\n        return xstream;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected XStream createXStream(ClassResolver resolver, ClassLoader classLoader) {\n        if (xstreamDriver != null) {\n            xstream = new XStream(xstreamDriver);\n        } else {\n            xstream = new XStream();\n        }\n\n        if (mode != null) {\n            xstream.setMode(getModeFromString(mode));\n        }\n\n        ClassLoader xstreamLoader = xstream.getClassLoader();\n        if (classLoader != null && xstreamLoader instanceof CompositeClassLoader) {\n            ((CompositeClassLoader) xstreamLoader).add(classLoader);\n        }\n\n        try {\n            if (this.implicitCollections != null) {\n                for (Entry<String, String[]> entry : this.implicitCollections.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.addImplicitCollection(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.aliases != null) {\n                for (Entry<String, String> entry : this.aliases.entrySet()) {\n                    xstream.alias(entry.getKey(), resolver.resolveMandatoryClass(entry.getValue()));\n                    // It can turn the auto-detection mode off\n                    xstream.processAnnotations(resolver.resolveMandatoryClass(entry.getValue()));\n                }\n            }\n\n            if (this.omitFields != null) {\n                for (Entry<String, String[]> entry : this.omitFields.entrySet()) {\n                    for (String name : entry.getValue()) {\n                        xstream.omitField(resolver.resolveMandatoryClass(entry.getKey()), name);\n                    }\n                }\n            }\n\n            if (this.converters != null) {\n                for (String name : this.converters) {\n                    Class<Converter> converterClass = resolver.resolveMandatoryClass(name, Converter.class);\n                    Converter converter;\n\n                    Constructor<Converter> con = null;\n                    try {\n                        con = converterClass.getDeclaredConstructor(new Class[]{XStream.class});\n                    } catch (Exception e) {\n                        //swallow as we null check in a moment.\n                    }\n                    if (con != null) {\n                        converter = con.newInstance(xstream);\n                    } else {\n                        converter = converterClass.newInstance();\n                        try {\n                            Method method = converterClass.getMethod(\"setXStream\", new Class[]{XStream.class});\n                            if (method != null) {\n                                ObjectHelper.invokeMethod(method, converter, xstream);\n                            }\n                        } catch (Throwable e) {\n                            // swallow, as it just means the user never add an XStream setter, which is optional\n                        }\n                    }\n\n                    xstream.registerConverter(converter);\n                }\n            }\n\n            addDefaultPermissions(xstream);\n            if (this.permissions != null) {\n                // permissions ::= pterm (',' pterm)*   # consits of one or more terms\n                // pterm       ::= aod? wterm           # each term preceded by an optional sign \n                // aod         ::= '+' | '-'            # indicates allow or deny where allow if omitted\n                // wterm       ::= a class name with optional wildcard characters\n                addPermissions(xstream, permissions);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to build XStream instance\", e);\n        }\n\n        return xstream;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean isContentTypeHeader() {\n        return contentTypeHeader;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean isContentTypeHeader() {\n        return contentTypeHeader;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setAllowJavaSerializedObject(boolean allowJavaSerializedObject) {\n        this.allowJavaSerializedObject = allowJavaSerializedObject;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setAllowJavaSerializedObject(boolean allowJavaSerializedObject) {\n        // need to override and call super for component docs\n        super.setAllowJavaSerializedObject(allowJavaSerializedObject);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DefaultHttpBinding(HttpEndpoint endpoint) {\n        this.endpoint = endpoint;\n        this.headerFilterStrategy = endpoint.getHeaderFilterStrategy();\n        this.allowJavaSerializedObject = endpoint.getComponent().isAllowJavaSerializedObject();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DefaultHttpBinding(HttpEndpoint endpoint) {\n        this.endpoint = endpoint;\n        this.headerFilterStrategy = endpoint.getHeaderFilterStrategy();\n        if (endpoint.getComponent() != null) {\n            this.allowJavaSerializedObject = endpoint.getComponent().isAllowJavaSerializedObject();\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void readRequest(HttpServletRequest request, HttpMessage message) {\n        LOG.trace(\"readRequest {}\", request);\n        \n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n        \n        //apply the headerFilterStrategy\n        Enumeration<?> names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            String value = request.getHeader(name);\n            // use http helper to extract parameter value as it may contain multiple values\n            Object extracted = HttpHelper.extractHttpParameterValue(value);\n            // mapping the content-type\n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, extracted, message.getExchange())) {\n                HttpHelper.appendHeader(headers, name, extracted);\n            }\n        }\n                \n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }\n\n        try {\n            populateRequestParameters(request, message);\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Cannot read request parameters due \" + e.getMessage(), e);\n        }\n        \n        Object body = message.getBody();\n        // reset the stream cache if the body is the instance of StreamCache\n        if (body instanceof StreamCache) {\n            ((StreamCache)body).reset();\n        }\n\n        // store the method and query and other info in headers as String types\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"HTTP method {}\", request.getMethod());\n            LOG.trace(\"HTTP query {}\", request.getQueryString());\n            LOG.trace(\"HTTP url {}\", request.getRequestURL());\n            LOG.trace(\"HTTP uri {}\", request.getRequestURI().toString());\n            LOG.trace(\"HTTP path {}\", request.getPathInfo());\n            LOG.trace(\"HTTP content-type {}\", request.getContentType());\n        }\n\n        // if content type is serialized java object, then de-serialize it to a Java object\n        if (request.getContentType() != null && HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(request.getContentType())) {\n            if (allowJavaSerializedObject || endpoint.isTransferException()) {\n                try {\n                    InputStream is = endpoint.getCamelContext().getTypeConverter().mandatoryConvertTo(InputStream.class, body);\n                    Object object = HttpHelper.deserializeJavaObjectFromStream(is);\n                    if (object != null) {\n                        message.setBody(object);\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeCamelException(\"Cannot deserialize body to Java object\", e);\n                }\n            } else {\n                throw new RuntimeCamelException(\"Content-type \" + HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT + \" is not allowed\");\n            }\n        }\n        \n        populateAttachments(request, message);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void readRequest(HttpServletRequest request, HttpMessage message) {\n        LOG.trace(\"readRequest {}\", request);\n        \n        // lets force a parse of the body and headers\n        message.getBody();\n        // populate the headers from the request\n        Map<String, Object> headers = message.getHeaders();\n        \n        //apply the headerFilterStrategy\n        Enumeration<?> names = request.getHeaderNames();\n        while (names.hasMoreElements()) {\n            String name = (String)names.nextElement();\n            String value = request.getHeader(name);\n            // use http helper to extract parameter value as it may contain multiple values\n            Object extracted = HttpHelper.extractHttpParameterValue(value);\n            // mapping the content-type\n            if (name.toLowerCase().equals(\"content-type\")) {\n                name = Exchange.CONTENT_TYPE;\n            }\n            if (headerFilterStrategy != null\n                && !headerFilterStrategy.applyFilterToExternalHeaders(name, extracted, message.getExchange())) {\n                HttpHelper.appendHeader(headers, name, extracted);\n            }\n        }\n                \n        if (request.getCharacterEncoding() != null) {\n            headers.put(Exchange.HTTP_CHARACTER_ENCODING, request.getCharacterEncoding());\n            message.getExchange().setProperty(Exchange.CHARSET_NAME, request.getCharacterEncoding());\n        }\n\n        try {\n            populateRequestParameters(request, message);\n        } catch (Exception e) {\n            throw new RuntimeCamelException(\"Cannot read request parameters due \" + e.getMessage(), e);\n        }\n        \n        Object body = message.getBody();\n        // reset the stream cache if the body is the instance of StreamCache\n        if (body instanceof StreamCache) {\n            ((StreamCache)body).reset();\n        }\n\n        // store the method and query and other info in headers as String types\n        headers.put(Exchange.HTTP_METHOD, request.getMethod());\n        headers.put(Exchange.HTTP_QUERY, request.getQueryString());\n        headers.put(Exchange.HTTP_URL, request.getRequestURL().toString());\n        headers.put(Exchange.HTTP_URI, request.getRequestURI());\n        headers.put(Exchange.HTTP_PATH, request.getPathInfo());\n        headers.put(Exchange.CONTENT_TYPE, request.getContentType());\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"HTTP method {}\", request.getMethod());\n            LOG.trace(\"HTTP query {}\", request.getQueryString());\n            LOG.trace(\"HTTP url {}\", request.getRequestURL());\n            LOG.trace(\"HTTP uri {}\", request.getRequestURI().toString());\n            LOG.trace(\"HTTP path {}\", request.getPathInfo());\n            LOG.trace(\"HTTP content-type {}\", request.getContentType());\n        }\n\n        // if content type is serialized java object, then de-serialize it to a Java object\n        if (request.getContentType() != null && HttpConstants.CONTENT_TYPE_JAVA_SERIALIZED_OBJECT.equals(request.getContentType())) {\n            // only deserialize java if allowed\n            if (allowJavaSerializedObject || endpoint.isTransferException()) {\n                try {\n                    InputStream is = endpoint.getCamelContext().getTypeConverter().mandatoryConvertTo(InputStream.class, body);\n                    Object object = HttpHelper.deserializeJavaObjectFromStream(is);\n                    if (object != null) {\n                        message.setBody(object);\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeCamelException(\"Cannot deserialize body to Java object\", e);\n                }\n            } else {\n                // set empty body\n                message.setBody(null);\n            }\n        }\n        \n        populateAttachments(request, message);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "new RouteBuilder() {\n\n            @Override\n            public void configure() throws Exception {\n                JacksonDataFormat format = new JacksonDataFormat();\n                format.setAllowJacksonUnmarshallType(true);\n\n                from(\"direct:backPojo\").unmarshal(format).to(\"mock:reversePojo\");\n\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "new RouteBuilder() {\n\n            @Override\n            public void configure() throws Exception {\n                JacksonDataFormat format = new JacksonDataFormat();\n                format.setAllowUnmarshallType(true);\n\n                from(\"direct:backPojo\").unmarshal(format).to(\"mock:reversePojo\");\n\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected Exchange createExchange(Object xml) {\n        Exchange exchange = createExchangeWithBody(context, xml);\n        return exchange;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected Exchange createExchange(Object xml) {\n        Exchange exchange = createExchangeWithBody(context, xml);\n        return exchange;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }\n        return factory;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(schemaLanguage);\n        if (getResourceResolver() != null) {\n            factory.setResourceResolver(getResourceResolver());\n        }  \n        if (!Boolean.parseBoolean(camelContext.getProperty(ACCESS_EXTERNAL_DTD))) {\n            try {\n                factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            } catch (SAXException e) {\n                LOG.error(e.getMessage(), e);\n                throw new IllegalStateException(e);\n            } \n        }\n        return factory;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "forward\n        if (overrule != null) {\n            exchange.getIn().setHeader(Exchange.FILE_NAME, name);\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "forward\n        if (overrule != null) {\n            exchange.getIn().setHeader(Exchange.FILE_NAME, value);\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String createFileName(Exchange exchange) {\n        String answer;\n\n        // overrule takes precedence\n        String overrule = exchange.getIn().getHeader(Exchange.OVERRULE_FILE_NAME, String.class);\n        String consumed = exchange.getIn().getHeader(Exchange.FILE_NAME_CONSUMED, String.class);\n        String name = overrule == null ? exchange.getIn().getHeader(Exchange.FILE_NAME, String.class) : overrule;\n\n        // if we have an overrule then override the existing header to use the overrule computed name from this point forward\n        if (overrule != null) {\n            exchange.getIn().setHeader(Exchange.FILE_NAME, name);\n        }\n\n        // expression support\n        Expression expression = endpoint.getFileName();\n\n        if (name != null && !name.equals(consumed)) {\n            // the header name can be an expression too, that should override\n            // whatever configured on the endpoint\n            if (StringHelper.hasStartToken(name, \"simple\")) {\n                log.trace(\"{} contains a Simple expression: {}\", Exchange.FILE_NAME, name);\n                Language language = getEndpoint().getCamelContext().resolveLanguage(\"file\");\n                expression = language.createExpression(name);\n            }\n        }\n        if (expression != null) {\n            log.trace(\"Filename evaluated as expression: {}\", expression);\n            name = expression.evaluate(exchange, String.class);\n        }\n\n        // flatten name\n        if (name != null && endpoint.isFlatten()) {\n            // check for both windows and unix separators\n            int pos = Math.max(name.lastIndexOf(\"/\"), name.lastIndexOf(\"\\\\\"));\n            if (pos != -1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        // compute path by adding endpoint starting directory\n        String endpointPath = endpoint.getConfiguration().getDirectory();\n        String baseDir = \"\";\n        if (endpointPath.length() > 0) {\n            // Its a directory so we should use it as a base path for the filename\n            // If the path isn't empty, we need to add a trailing / if it isn't already there\n            baseDir = endpointPath;\n            boolean trailingSlash = endpointPath.endsWith(\"/\") || endpointPath.endsWith(\"\\\\\");\n            if (!trailingSlash) {\n                baseDir += getFileSeparator();\n            }\n        }\n        if (name != null) {\n            answer = baseDir + name;\n        } else {\n            // use a generated filename if no name provided\n            answer = baseDir + endpoint.getGeneratedFileName(exchange.getIn());\n        }\n\n        if (endpoint.getConfiguration().needToNormalize()) {\n            // must normalize path to cater for Windows and other OS\n            answer = normalizePath(answer);\n        }\n\n        return answer;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String createFileName(Exchange exchange) {\n        String answer;\n\n        // overrule takes precedence\n        Object value;\n\n        Object overrule = exchange.getIn().getHeader(Exchange.OVERRULE_FILE_NAME);\n        if (overrule != null) {\n            if (overrule instanceof Expression) {\n                value = overrule;\n            } else {\n                value = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, overrule);\n            }\n        } else {\n            value = exchange.getIn().getHeader(Exchange.FILE_NAME);\n        }\n\n        // if we have an overrule then override the existing header to use the overrule computed name from this point forward\n        if (overrule != null) {\n            exchange.getIn().setHeader(Exchange.FILE_NAME, value);\n        }\n\n        if (value != null && value instanceof String && StringHelper.hasStartToken((String) value, \"simple\")) {\n            log.warn(\"Simple expression: {} detected in header: {} of type String. This feature has been removed (see CAMEL-6748).\", value, Exchange.FILE_NAME);\n        }\n\n        // expression support\n        Expression expression = endpoint.getFileName();\n        if (value != null && value instanceof Expression) {\n            expression = (Expression) value;\n        }\n\n        // evaluate the name as a String from the value\n        String name;\n        if (expression != null) {\n            log.trace(\"Filename evaluated as expression: {}\", expression);\n            name = expression.evaluate(exchange, String.class);\n        } else {\n            name = exchange.getContext().getTypeConverter().convertTo(String.class, exchange, value);\n        }\n\n        // flatten name\n        if (name != null && endpoint.isFlatten()) {\n            // check for both windows and unix separators\n            int pos = Math.max(name.lastIndexOf(\"/\"), name.lastIndexOf(\"\\\\\"));\n            if (pos != -1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        // compute path by adding endpoint starting directory\n        String endpointPath = endpoint.getConfiguration().getDirectory();\n        String baseDir = \"\";\n        if (endpointPath.length() > 0) {\n            // Its a directory so we should use it as a base path for the filename\n            // If the path isn't empty, we need to add a trailing / if it isn't already there\n            baseDir = endpointPath;\n            boolean trailingSlash = endpointPath.endsWith(\"/\") || endpointPath.endsWith(\"\\\\\");\n            if (!trailingSlash) {\n                baseDir += getFileSeparator();\n            }\n        }\n        if (name != null) {\n            answer = baseDir + name;\n        } else {\n            // use a generated filename if no name provided\n            answer = baseDir + endpoint.getGeneratedFileName(exchange.getIn());\n        }\n\n        if (endpoint.getConfiguration().needToNormalize()) {\n            // must normalize path to cater for Windows and other OS\n            answer = normalizePath(answer);\n        }\n\n        return answer;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (mappingFile != null) {\n            setProperty(camelContext, dataFormat, \"mappingFile\", mappingFile);\n        }\n        // should be true by default\n        boolean isValidation = getValidation() == null || getValidation();\n        setProperty(camelContext, dataFormat, \"validation\", isValidation);\n\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (packages != null) {\n            setProperty(camelContext, dataFormat, \"packages\", packages);\n        }\n        if (classes != null) {\n            setProperty(camelContext, dataFormat, \"classes\", classes);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (mappingFile != null) {\n            setProperty(camelContext, dataFormat, \"mappingFile\", mappingFile);\n        }\n        // should be true by default\n        boolean isValidation = getValidation() == null || getValidation();\n        setProperty(camelContext, dataFormat, \"validation\", isValidation);\n\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (packages != null) {\n            setProperty(camelContext, dataFormat, \"packages\", packages);\n        }\n        if (classes != null) {\n            setProperty(camelContext, dataFormat, \"classes\", classes);\n        }\n        if (whitelistEnabled != null) {\n            setProperty(camelContext, dataFormat, \"whitelistEnabled\", whitelistEnabled);\n        }\n        if (allowedUnmarshallObjects != null) {\n            setProperty(camelContext, dataFormat, \"allowedUnmarshallObjects\", allowedUnmarshallObjects);\n        }\n        if (deniedUnmarshallObjects != null) {\n            setProperty(camelContext, dataFormat, \"deniedUnmarshallObjects\", deniedUnmarshallObjects);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (this.converters != null) {\n            setProperty(camelContext, dataFormat, \"converters\", this.converters);\n        }\n        if (this.aliases != null) {\n            setProperty(camelContext, dataFormat, \"aliases\", this.aliases);\n        }\n        if (this.omitFields != null) {\n            setProperty(camelContext, dataFormat, \"omitFields\", this.omitFields);\n        }\n        if (this.implicitCollections != null) {\n            setProperty(camelContext, dataFormat, \"implicitCollections\", this.implicitCollections);\n        }\n        if (this.mode != null) {\n            setProperty(camelContext, dataFormat, \"mode\", mode);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void configureDataFormat(DataFormat dataFormat, CamelContext camelContext) {\n        if (encoding != null) {\n            setProperty(camelContext, dataFormat, \"encoding\", encoding);\n        }\n        if (this.converters != null) {\n            setProperty(camelContext, dataFormat, \"converters\", this.converters);\n        }\n        if (this.aliases != null) {\n            setProperty(camelContext, dataFormat, \"aliases\", this.aliases);\n        }\n        if (this.omitFields != null) {\n            setProperty(camelContext, dataFormat, \"omitFields\", this.omitFields);\n        }\n        if (this.implicitCollections != null) {\n            setProperty(camelContext, dataFormat, \"implicitCollections\", this.implicitCollections);\n        }\n        if (this.permissions != null) {\n            setProperty(camelContext, dataFormat, \"permissions\", this.permissions);\n        }\n        if (this.mode != null) {\n            setProperty(camelContext, dataFormat, \"mode\", mode);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void handleMessage(Message message) {\n        if (isGET(message) && message.getContent(List.class) != null) {\n            LOG.fine(\"DocLiteralInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n        DataReader<XMLStreamReader> dr = getDataReader(message);\n        MessageContentsList parameters = new MessageContentsList();\n\n        Exchange exchange = message.getExchange();\n        BindingOperationInfo bop = exchange.getBindingOperationInfo();\n\n        boolean client = isRequestor(message);\n\n        //if body is empty and we have BindingOperationInfo, we do not need to match \n        //operation anymore, just return\n        if (bop != null && !StaxUtils.toNextElement(xmlReader)) {\n            // body may be empty for partial response to decoupled request\n            return;\n        }\n\n        //bop might be a unwrapped, wrap it back so that we can get correct info \n        if (bop != null && bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n\n        if (bop == null) {\n            QName startQName = xmlReader == null \n                ? new QName(\"http://cxf.apache.org/jaxws/provider\", \"invoke\")\n                : xmlReader.getName();\n            bop = getBindingOperationInfo(exchange, startQName, client);\n        }\n\n        try {\n            if (bop != null && bop.isUnwrappedCapable()) {\n                ServiceInfo si = bop.getBinding().getService();\n                // Wrapped case\n                MessageInfo msgInfo = setMessage(message, bop, client, si);\n    \n                // Determine if we should keep the parameters wrapper\n                if (shouldWrapParameters(msgInfo, message)) {\n                    QName startQName = xmlReader.getName();\n                    if (!msgInfo.getMessageParts().get(0).getConcreteName().equals(startQName)) {\n                        throw new Fault(\"UNEXPECTED_WRAPPER_ELEMENT\", LOG, null, startQName,\n                                        msgInfo.getMessageParts().get(0).getConcreteName());\n                    }\n                    Object wrappedObject = dr.read(msgInfo.getMessageParts().get(0), xmlReader);\n                    parameters.put(msgInfo.getMessageParts().get(0), wrappedObject);\n                } else {\n                    // Unwrap each part individually if we don't have a wrapper\n    \n                    bop = bop.getUnwrappedOperation();\n    \n                    msgInfo = setMessage(message, bop, client, si);\n                    List<MessagePartInfo> messageParts = msgInfo.getMessageParts();\n                    Iterator<MessagePartInfo> itr = messageParts.iterator();\n    \n                    // advance just past the wrapped element so we don't get\n                    // stuck\n                    if (xmlReader.getEventType() == XMLStreamConstants.START_ELEMENT) {\n                        StaxUtils.nextEvent(xmlReader);\n                    }\n    \n                    // loop through each child element\n                    getPara(xmlReader, dr, parameters, itr, message);\n                }\n    \n            } else {\n                //Bare style\n                BindingMessageInfo msgInfo = null;\n\n    \n                Endpoint ep = exchange.get(Endpoint.class);\n                ServiceInfo si = ep.getEndpointInfo().getService();\n                if (bop != null) { //for xml binding or client side\n                    if (client) {\n                        msgInfo = bop.getOutput();\n                    } else {\n                        msgInfo = bop.getInput();\n                        if (bop.getOutput() == null) {\n                            exchange.setOneWay(true);\n                        }\n                    }\n                    if (msgInfo == null) {\n                        return;\n                    }\n                    setMessage(message, bop, client, si, msgInfo.getMessageInfo());\n                }\n    \n                Collection<OperationInfo> operations = null;\n                operations = new ArrayList<OperationInfo>();\n                operations.addAll(si.getInterface().getOperations());\n    \n                if (xmlReader == null || !StaxUtils.toNextElement(xmlReader)) {\n                    // empty input\n    \n                    // TO DO : check duplicate operation with no input\n                    for (OperationInfo op : operations) {\n                        MessageInfo bmsg = op.getInput();\n                        if (bmsg.getMessageParts().size() == 0) {\n                            BindingOperationInfo boi = ep.getEndpointInfo().getBinding().getOperation(op);\n                            exchange.put(BindingOperationInfo.class, boi);\n                            exchange.put(OperationInfo.class, op);\n                            exchange.setOneWay(op.isOneWay());\n                        }\n                    }\n                    return;\n                }\n    \n                int paramNum = 0;\n    \n                do {\n                    QName elName = xmlReader.getName();\n                    Object o = null;\n    \n                    MessagePartInfo p;\n                    if (!client && msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() == 0) {\n                        //no input messagePartInfo\n                        return;\n                    }\n                    \n                    if (msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() > 0) {\n                        if (msgInfo.getMessageParts().size() > paramNum) {\n                            p = msgInfo.getMessageParts().get(paramNum);\n                        } else {\n                            p = null;\n                        }\n                    } else {\n                        p = findMessagePart(exchange, operations, elName, client, paramNum, message);\n                    }\n    \n                    if (p == null) {\n                        throw new Fault(new org.apache.cxf.common.i18n.Message(\"NO_PART_FOUND\", LOG, elName),\n                                        Fault.FAULT_CODE_CLIENT);\n                    }\n    \n                    o = dr.read(p, xmlReader);\n                    if (Boolean.TRUE.equals(si.getProperty(\"soap.force.doclit.bare\")) \n                        && parameters.isEmpty()) {\n                        // webservice provider does not need to ensure size\n                        parameters.add(o);\n                    } else {\n                        parameters.put(p, o);\n                    }\n                    \n                    paramNum++;\n                    if (message.getContent(XMLStreamReader.class) == null || o == xmlReader) {\n                        xmlReader = null;\n                    }\n                } while (xmlReader != null && StaxUtils.toNextElement(xmlReader));\n    \n            }\n    \n            message.setContent(List.class, parameters);\n        } catch (Fault f) {\n            if (!isRequestor(message)) {\n                f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n            }\n            throw f;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void handleMessage(Message message) {\n        if (isGET(message) && message.getContent(List.class) != null) {\n            LOG.fine(\"DocLiteralInInterceptor skipped in HTTP GET method\");\n            return;\n        }\n\n        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n        DataReader<XMLStreamReader> dr = getDataReader(message);\n        MessageContentsList parameters = new MessageContentsList();\n\n        Exchange exchange = message.getExchange();\n        BindingOperationInfo bop = exchange.getBindingOperationInfo();\n\n        boolean client = isRequestor(message);\n\n        //if body is empty and we have BindingOperationInfo, we do not need to match \n        //operation anymore, just return\n        if (bop != null && !StaxUtils.toNextElement(xmlReader)) {\n            // body may be empty for partial response to decoupled request\n            return;\n        }\n\n        //bop might be a unwrapped, wrap it back so that we can get correct info \n        if (bop != null && bop.isUnwrapped()) {\n            bop = bop.getWrappedOperation();\n        }\n\n        if (bop == null) {\n            QName startQName = xmlReader == null \n                ? new QName(\"http://cxf.apache.org/jaxws/provider\", \"invoke\")\n                : xmlReader.getName();\n            bop = getBindingOperationInfo(exchange, startQName, client);\n        }\n\n        try {\n            if (bop != null && bop.isUnwrappedCapable()) {\n                ServiceInfo si = bop.getBinding().getService();\n                // Wrapped case\n                MessageInfo msgInfo = setMessage(message, bop, client, si);\n    \n                // Determine if we should keep the parameters wrapper\n                if (shouldWrapParameters(msgInfo, message)) {\n                    QName startQName = xmlReader.getName();\n                    if (!msgInfo.getMessageParts().get(0).getConcreteName().equals(startQName)) {\n                        throw new Fault(\"UNEXPECTED_WRAPPER_ELEMENT\", LOG, null, startQName,\n                                        msgInfo.getMessageParts().get(0).getConcreteName());\n                    }\n                    Object wrappedObject = dr.read(msgInfo.getMessageParts().get(0), xmlReader);\n                    parameters.put(msgInfo.getMessageParts().get(0), wrappedObject);\n                } else {\n                    // Unwrap each part individually if we don't have a wrapper\n    \n                    bop = bop.getUnwrappedOperation();\n    \n                    msgInfo = setMessage(message, bop, client, si);\n                    List<MessagePartInfo> messageParts = msgInfo.getMessageParts();\n                    Iterator<MessagePartInfo> itr = messageParts.iterator();\n    \n                    // advance just past the wrapped element so we don't get\n                    // stuck\n                    if (xmlReader.getEventType() == XMLStreamConstants.START_ELEMENT) {\n                        StaxUtils.nextEvent(xmlReader);\n                    }\n    \n                    // loop through each child element\n                    getPara(xmlReader, dr, parameters, itr, message);\n                }\n    \n            } else {\n                //Bare style\n                BindingMessageInfo msgInfo = null;\n\n    \n                Endpoint ep = exchange.get(Endpoint.class);\n                ServiceInfo si = ep.getEndpointInfo().getService();\n                if (bop != null) { //for xml binding or client side\n                    if (client) {\n                        msgInfo = bop.getOutput();\n                    } else {\n                        msgInfo = bop.getInput();\n                        if (bop.getOutput() == null) {\n                            exchange.setOneWay(true);\n                        }\n                    }\n                    if (msgInfo == null) {\n                        return;\n                    }\n                    setMessage(message, bop, client, si, msgInfo.getMessageInfo());\n                }\n    \n                Collection<OperationInfo> operations = null;\n                operations = new ArrayList<OperationInfo>();\n                operations.addAll(si.getInterface().getOperations());\n    \n                if (xmlReader == null || !StaxUtils.toNextElement(xmlReader)) {\n                    // empty input\n    \n                    // TO DO : check duplicate operation with no input\n                    for (OperationInfo op : operations) {\n                        MessageInfo bmsg = op.getInput();\n                        if (bmsg.getMessageParts().size() == 0) {\n                            BindingOperationInfo boi = ep.getEndpointInfo().getBinding().getOperation(op);\n                            exchange.put(BindingOperationInfo.class, boi);\n                            exchange.put(OperationInfo.class, op);\n                            exchange.setOneWay(op.isOneWay());\n                        }\n                    }\n                    return;\n                }\n    \n                int paramNum = 0;\n    \n                do {\n                    QName elName = xmlReader.getName();\n                    Object o = null;\n    \n                    MessagePartInfo p;\n                    if (!client && msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() == 0) {\n                        //no input messagePartInfo\n                        return;\n                    }\n                    \n                    if (msgInfo != null && msgInfo.getMessageParts() != null \n                        && msgInfo.getMessageParts().size() > 0) {\n                        if (msgInfo.getMessageParts().size() > paramNum) {\n                            p = msgInfo.getMessageParts().get(paramNum);\n                        } else {\n                            p = null;\n                        }\n                    } else {\n                        p = findMessagePart(exchange, operations, elName, client, paramNum, message);\n                    }\n                    \n                    //Make sure the elName found on the wire is actually OK for \n                    //the purpose we need it\n                    validatePart(p, elName, si);\n\n                    o = dr.read(p, xmlReader);\n                    if (Boolean.TRUE.equals(si.getProperty(\"soap.force.doclit.bare\")) \n                        && parameters.isEmpty()) {\n                        // webservice provider does not need to ensure size\n                        parameters.add(o);\n                    } else {\n                        parameters.put(p, o);\n                    }\n                    \n                    paramNum++;\n                    if (message.getContent(XMLStreamReader.class) == null || o == xmlReader) {\n                        xmlReader = null;\n                    }\n                } while (xmlReader != null && StaxUtils.toNextElement(xmlReader));\n    \n            }\n    \n            message.setContent(List.class, parameters);\n        } catch (Fault f) {\n            if (!isRequestor(message)) {\n                f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n            }\n            throw f;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public URIMappingInterceptor() {\n        super(Phase.UNMARSHAL);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public URIMappingInterceptor() {\n        super(Phase.UNMARSHAL);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private static String getIdFromToken(Element token) {\n        if (token != null) {\n            // Try to find the \"Id\" on the token.\n            if (token.hasAttributeNS(WSConstants.WSU_NS, \"Id\")) {\n                return token.getAttributeNS(WSConstants.WSU_NS, \"Id\");\n            } else if (token.hasAttributeNS(null, \"ID\")) {\n                return token.getAttributeNS(null, \"ID\");\n            } else if (token.hasAttributeNS(null, \"AssertionID\")) {\n                return token.getAttributeNS(null, \"AssertionID\");\n            }\n        }\n        return \"\";\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private static String getIdFromToken(Element token) {\n        if (token != null) {\n            // For SAML tokens get the ID/AssertionID\n            if (\"Assertion\".equals(token.getLocalName())\n                && WSConstants.SAML2_NS.equals(token.getNamespaceURI())) {\n                return token.getAttributeNS(null, \"ID\");\n            } else if (\"Assertion\".equals(token.getLocalName())\n                && WSConstants.SAML_NS.equals(token.getNamespaceURI())) {\n                return token.getAttributeNS(null, \"AssertionID\");\n            }\n\n            // For UsernameTokens get the username\n            if (WSConstants.USERNAME_TOKEN_LN.equals(token.getLocalName())\n                && WSConstants.WSSE_NS.equals(token.getNamespaceURI())) {\n                Element usernameElement =\n                    XMLUtils.getDirectChildElement(token, WSConstants.USERNAME_LN, WSConstants.WSSE_NS);\n                if (usernameElement != null) {\n                    return XMLUtils.getElementText(usernameElement);\n                }\n            }\n\n            // For BinarySecurityTokens take the hash of the value\n            if (WSConstants.BINARY_TOKEN_LN.equals(token.getLocalName())\n                && WSConstants.WSSE_NS.equals(token.getNamespaceURI())) {\n                String text = XMLUtils.getElementText(token);\n                if (text != null && !\"\".equals(text)) {\n                    try {\n                        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n                        byte[] bytes = digest.digest(text.getBytes());\n                        return Base64.getMimeEncoder().encodeToString(bytes);\n                    } catch (NoSuchAlgorithmException e) {\n                        // SHA-256 must be supported so not going to happen...\n                    }\n                }\n            }\n        }\n        return \"\";\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Binding createBinding(BindingInfo binding) {\n        XMLBinding xb = new XMLBinding(binding);\n        \n        xb.getInInterceptors().add(new AttachmentInInterceptor());    \n        xb.getInInterceptors().add(new StaxInInterceptor());\n        xb.getInInterceptors().add(new URIMappingInterceptor());\n        xb.getInInterceptors().add(new DocLiteralInInterceptor());\n        xb.getInInterceptors().add(new XMLMessageInInterceptor());\n        \n        xb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        xb.getOutInterceptors().add(new StaxOutInterceptor());\n        xb.getOutInterceptors().add(new WrappedOutInterceptor());\n        xb.getOutInterceptors().add(new XMLMessageOutInterceptor());            \n\n        xb.getInFaultInterceptors().add(new XMLFaultInInterceptor());\n        xb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        xb.getOutFaultInterceptors().add(new XMLFaultOutInterceptor());\n        \n        return xb;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Binding createBinding(BindingInfo binding) {\n        XMLBinding xb = new XMLBinding(binding);\n        \n        xb.getInInterceptors().add(new AttachmentInInterceptor());    \n        xb.getInInterceptors().add(new StaxInInterceptor());\n        xb.getInInterceptors().add(new DocLiteralInInterceptor());\n        xb.getInInterceptors().add(new XMLMessageInInterceptor());\n        \n        xb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        xb.getOutInterceptors().add(new StaxOutInterceptor());\n        xb.getOutInterceptors().add(new WrappedOutInterceptor());\n        xb.getOutInterceptors().add(new XMLMessageOutInterceptor());            \n\n        xb.getInFaultInterceptors().add(new XMLFaultInInterceptor());\n        xb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        xb.getOutFaultInterceptors().add(new XMLFaultOutInterceptor());\n        \n        return xb;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Binding createBinding(BindingInfo binding) {\n        // TODO what about the mix style/use?\n\n\n        // The default style should be doc-lit wrapped.\n        String parameterStyle = SoapBindingConstants.PARAMETER_STYLE_WRAPPED;\n        String bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n\n        boolean hasWrapped = false;\n        \n        org.apache.cxf.binding.soap.SoapBinding sb = null;\n        SoapVersion version = null;\n        if (binding instanceof SoapBindingInfo) {\n            SoapBindingInfo sbi = (SoapBindingInfo) binding;\n            version = sbi.getSoapVersion();\n            sb = new org.apache.cxf.binding.soap.SoapBinding(binding, version);\n            // Service wide style\n            if (!StringUtils.isEmpty(sbi.getStyle())) {\n                bindingStyle = sbi.getStyle();\n            }\n\n            boolean hasRPC = false;\n            boolean hasDoc = false;\n            \n            // Operation wide style, what to do with the mixed style/use?\n            for (BindingOperationInfo boi : sbi.getOperations()) {\n                String st = sbi.getStyle(boi.getOperationInfo());\n                if (st != null) {\n                    bindingStyle = st;\n                    if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(st)) {\n                        hasRPC = true;\n                    } else {\n                        hasDoc = true;\n                    }\n                }\n                if (boi.getUnwrappedOperation() == null) {\n                    parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                } else {\n                    hasWrapped = true;\n                }\n            }\n            \n            if (Boolean.TRUE.equals(binding.getService().getProperty(\"soap.force.doclit.bare\"))) {\n                hasDoc = true;\n                hasRPC = false;\n                parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n            }\n            if (hasRPC && hasDoc) {\n                throw new RuntimeException(\"WSI-BP prohibits RPC and Document style \"\n                                           + \"operations in same service.\");\n            }\n            \n            //jms\n            if (sbi.getTransportURI().equals(SoapJMSConstants.SOAP_JMS_SPECIFICIATION_TRANSPORTID)) {\n                sb.getInInterceptors().add(new SoapJMSInInterceptor());\n            }\n        } else {\n            throw new RuntimeException(\"Can not initialize SoapBinding, BindingInfo is not SoapBindingInfo\");\n        }\n\n        sb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n        sb.getInInterceptors().add(new AttachmentInInterceptor());\n        sb.getInInterceptors().add(new StaxInInterceptor());\n        sb.getInInterceptors().add(new SoapActionInInterceptor());\n        \n        sb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        sb.getOutInterceptors().add(new StaxOutInterceptor());\n        sb.getOutInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(bindingStyle)) {\n            sb.getInInterceptors().add(new RPCInInterceptor());\n            sb.getOutInterceptors().add(new RPCOutInterceptor());\n        } else if (SoapBindingConstants.BINDING_STYLE_DOC.equalsIgnoreCase(bindingStyle)\n                        && SoapBindingConstants.PARAMETER_STYLE_BARE.equalsIgnoreCase(parameterStyle)) {\n            //sb.getInInterceptors().add(new BareInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            if (hasWrapped) {\n                sb.getOutInterceptors().add(new WrappedOutInterceptor());                    \n            }\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        } else {\n            //sb.getInInterceptors().add(new WrappedInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            sb.getOutInterceptors().add(new WrappedOutInterceptor());\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        }\n        sb.getInInterceptors().add(new SoapHeaderInterceptor());\n\n        sb.getInInterceptors().add(new ReadHeadersInterceptor(getBus(), version));\n        sb.getInInterceptors().add(new StartBodyInterceptor());\n        sb.getInInterceptors().add(new CheckFaultInterceptor());\n        sb.getInInterceptors().add(new MustUnderstandInterceptor());\n        sb.getOutInterceptors().add(new SoapPreProtocolOutInterceptor());\n        sb.getOutInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        // REVISIT: The phase interceptor chain seems to freak out if this added\n        // first. Not sure what the deal is at the moment, I suspect the\n        // ordering algorithm needs to be improved\n        sb.getInInterceptors().add(new URIMappingInterceptor());\n\n        if (version.getVersion() == 1.1) {\n            sb.getInFaultInterceptors().add(new Soap11FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap11FaultOutInterceptor());\n        } else if (version.getVersion() == 1.2) {\n            sb.getInFaultInterceptors().add(new Soap12FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap12FaultOutInterceptor());\n        }\n        \n        if (binding.getService() != null) {\n            for (EndpointInfo ei: binding.getService().getEndpoints()) {\n                if (ei.getAddress() != null && ei.getAddress().startsWith(\"soap.udp\")) {\n                    setupUDP(sb, ei);\n                }\n            }\n        }\n\n        return sb;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Binding createBinding(BindingInfo binding) {\n        // TODO what about the mix style/use?\n\n\n        // The default style should be doc-lit wrapped.\n        String parameterStyle = SoapBindingConstants.PARAMETER_STYLE_WRAPPED;\n        String bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n\n        boolean hasWrapped = false;\n        \n        org.apache.cxf.binding.soap.SoapBinding sb = null;\n        SoapVersion version = null;\n        if (binding instanceof SoapBindingInfo) {\n            SoapBindingInfo sbi = (SoapBindingInfo) binding;\n            version = sbi.getSoapVersion();\n            sb = new org.apache.cxf.binding.soap.SoapBinding(binding, version);\n            // Service wide style\n            if (!StringUtils.isEmpty(sbi.getStyle())) {\n                bindingStyle = sbi.getStyle();\n            }\n\n            boolean hasRPC = false;\n            boolean hasDoc = false;\n            \n            // Operation wide style, what to do with the mixed style/use?\n            for (BindingOperationInfo boi : sbi.getOperations()) {\n                String st = sbi.getStyle(boi.getOperationInfo());\n                if (st != null) {\n                    bindingStyle = st;\n                    if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(st)) {\n                        hasRPC = true;\n                    } else {\n                        hasDoc = true;\n                    }\n                }\n                if (boi.getUnwrappedOperation() == null) {\n                    parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                } else {\n                    hasWrapped = true;\n                }\n            }\n            \n            if (Boolean.TRUE.equals(binding.getService().getProperty(\"soap.force.doclit.bare\"))) {\n                hasDoc = true;\n                hasRPC = false;\n                parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n            }\n            if (hasRPC && hasDoc) {\n                throw new RuntimeException(\"WSI-BP prohibits RPC and Document style \"\n                                           + \"operations in same service.\");\n            }\n            \n            //jms\n            if (sbi.getTransportURI().equals(SoapJMSConstants.SOAP_JMS_SPECIFICIATION_TRANSPORTID)) {\n                sb.getInInterceptors().add(new SoapJMSInInterceptor());\n            }\n        } else {\n            throw new RuntimeException(\"Can not initialize SoapBinding, BindingInfo is not SoapBindingInfo\");\n        }\n\n        sb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n        sb.getInInterceptors().add(new AttachmentInInterceptor());\n        sb.getInInterceptors().add(new StaxInInterceptor());\n        sb.getInInterceptors().add(new SoapActionInInterceptor());\n        \n        sb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        sb.getOutInterceptors().add(new StaxOutInterceptor());\n        sb.getOutInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(bindingStyle)) {\n            sb.getInInterceptors().add(new RPCInInterceptor());\n            sb.getOutInterceptors().add(new RPCOutInterceptor());\n        } else if (SoapBindingConstants.BINDING_STYLE_DOC.equalsIgnoreCase(bindingStyle)\n                        && SoapBindingConstants.PARAMETER_STYLE_BARE.equalsIgnoreCase(parameterStyle)) {\n            //sb.getInInterceptors().add(new BareInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            if (hasWrapped) {\n                sb.getOutInterceptors().add(new WrappedOutInterceptor());                    \n            }\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        } else {\n            //sb.getInInterceptors().add(new WrappedInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            sb.getOutInterceptors().add(new WrappedOutInterceptor());\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        }\n        sb.getInInterceptors().add(new SoapHeaderInterceptor());\n\n        sb.getInInterceptors().add(new ReadHeadersInterceptor(getBus(), version));\n        sb.getInInterceptors().add(new StartBodyInterceptor());\n        sb.getInInterceptors().add(new CheckFaultInterceptor());\n        sb.getInInterceptors().add(new MustUnderstandInterceptor());\n        sb.getOutInterceptors().add(new SoapPreProtocolOutInterceptor());\n        sb.getOutInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        if (version.getVersion() == 1.1) {\n            sb.getInFaultInterceptors().add(new Soap11FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap11FaultOutInterceptor());\n        } else if (version.getVersion() == 1.2) {\n            sb.getInFaultInterceptors().add(new Soap12FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap12FaultOutInterceptor());\n        }\n        \n        if (binding.getService() != null) {\n            for (EndpointInfo ei: binding.getService().getEndpoints()) {\n                if (ei.getAddress() != null && ei.getAddress().startsWith(\"soap.udp\")) {\n                    setupUDP(sb, ei);\n                }\n            }\n        }\n\n        return sb;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void getAndSetOperation(SoapMessage message, String action) {\n        if (StringUtils.isEmpty(action)) {\n            return;\n        }\n        message.put(SoapBindingConstants.SOAP_ACTION, action);\n        \n        Exchange ex = message.getExchange();\n        Endpoint ep = ex.get(Endpoint.class);\n        \n        BindingOperationInfo bindingOp = null;\n        \n        Collection<BindingOperationInfo> bops = ep.getBinding().getBindingInfo().getOperations();\n        if (bops == null) {\n            return;\n        }\n        for (BindingOperationInfo boi : bops) {\n            SoapOperationInfo soi = boi.getExtensor(SoapOperationInfo.class);\n            if (soi != null && action.equals(soi.getAction())) {\n                if (bindingOp != null) {\n                    //more than one op with the same action, will need to parse normally\n                    return;\n                }\n                bindingOp = boi;\n            }\n        }\n        if (bindingOp != null) {\n            ex.put(BindingOperationInfo.class, bindingOp);\n            ex.put(OperationInfo.class, bindingOp.getOperationInfo());\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void getAndSetOperation(SoapMessage message, String action) {\n        if (StringUtils.isEmpty(action)) {\n            return;\n        }\n        message.put(SoapBindingConstants.SOAP_ACTION, action);\n        \n        Exchange ex = message.getExchange();\n        Endpoint ep = ex.get(Endpoint.class);\n        \n        BindingOperationInfo bindingOp = null;\n        \n        Collection<BindingOperationInfo> bops = ep.getEndpointInfo()\n            .getBinding().getOperations();\n        if (bops != null) {\n            for (BindingOperationInfo boi : bops) {\n                SoapOperationInfo soi = boi.getExtensor(SoapOperationInfo.class);\n                if (soi != null && action.equals(soi.getAction())) {\n                    if (bindingOp != null) {\n                        //more than one op with the same action, will need to parse normally\n                        return;\n                    }\n                    bindingOp = boi;\n                }\n            }\n        }\n        \n        if (bindingOp == null) {\n            //we didn't match the an operation, we'll try again later to make\n            //sure the incoming message did end up matching an operation.\n            //This could occur in some cases like WS-RM and WS-SecConv that will\n            //intercept the message with a new endpoint/operation\n            message.getInterceptorChain().add(new SoapActionInAttemptTwoInterceptor());\n            return;\n        }\n        \n        ex.put(BindingOperationInfo.class, bindingOp);\n        ex.put(OperationInfo.class, bindingOp.getOperationInfo());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy,\n                                         Method method,\n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return true;\n                        }\n                    }\n                }",
    "is_vulnerable": true
  },
  {
    "function_code": "new ReflectionInvokationHandler(verifier) {\n                    public Object invoke(Object proxy,\n                                         Method method,\n                                         Object[] args) throws Throwable {\n                        try {\n                            return super.invoke(proxy, method, args);\n                        } catch (Exception ex) {\n                            return false;\n                        }\n                    }\n                }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean verify(String host, SSLSession session) {\n        try {\n            Certificate[] certs = session.getPeerCertificates();\n            return certs != null && certs[0] instanceof X509Certificate;\n        } catch (SSLException e) {\n            return false;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean verify(final String host, final String certHostname) {\n        return certHostname != null && !certHostname.isEmpty();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean verify(final String host, final SSLSession session) {\n        try {\n            final Certificate[] certs = session.getPeerCertificates();\n            final X509Certificate x509 = (X509Certificate) certs[0];\n            verify(host, x509);\n            return true;\n        } catch (final SSLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n            }\n            return false;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean verify(final String host, final String certHostname) {\n        try {\n            matchCN(host, certHostname, this.publicSuffixMatcher);\n            return true;\n        } catch (SSLException ex) {\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n            }\n            return false;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static String getBaseURL(HttpServletRequest request) {\n        String reqPrefix = request.getRequestURL().toString();        \n        String pathInfo = request.getPathInfo() == null ? \"\" : request.getPathInfo();\n        //fix for CXF-898\n        if (!\"/\".equals(pathInfo) || reqPrefix.endsWith(\"/\")) {\n            StringBuilder sb = new StringBuilder();\n            // request.getScheme(), request.getLocalName() and request.getLocalPort()\n            // should be marginally cheaper - provided request.getLocalName() does \n            // return the actual name used in request URI as opposed to localhost\n            // consistently across the Servlet stacks\n            \n            URI uri = URI.create(reqPrefix);\n            sb.append(uri.getScheme()).append(\"://\").append(uri.getRawAuthority());\n            if (request.getContextPath() != null) {\n                sb.append(request.getContextPath());\n            }\n            if (request.getServletPath() != null) {\n                sb.append(request.getServletPath());\n            }\n            \n            reqPrefix = sb.toString();\n        } else {\n            int matrixParamIndex = reqPrefix.indexOf(\";\");\n            if (matrixParamIndex > 0) {\n                reqPrefix = reqPrefix.substring(0, matrixParamIndex);\n            }\n        }\n        return reqPrefix;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static String getBaseURL(HttpServletRequest request) {\n        String reqPrefix = request.getRequestURL().toString();        \n        String pathInfo = request.getPathInfo();\n        if (!\"/\".equals(pathInfo) || reqPrefix.contains(\";\")) {\n            StringBuilder sb = new StringBuilder();\n            // request.getScheme(), request.getLocalName() and request.getLocalPort()\n            // should be marginally cheaper - provided request.getLocalName() does \n            // return the actual name used in request URI as opposed to localhost\n            // consistently across the Servlet stacks\n            \n            URI uri = URI.create(reqPrefix);\n            sb.append(uri.getScheme()).append(\"://\").append(uri.getRawAuthority());\n            String contextPath = request.getContextPath();\n            if (contextPath != null) {\n                sb.append(contextPath);\n            }\n            String servletPath = request.getServletPath();\n            if (servletPath != null) {\n                sb.append(servletPath);\n            }\n            \n            reqPrefix = sb.toString();\n        }\n        return reqPrefix;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean verify(JwsHeaders headers, String unsignedText, byte[] signature) {\n        byte[] expected = computeMac(headers, unsignedText);\n        return Arrays.equals(expected, signature);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean verify(JwsHeaders headers, String unsignedText, byte[] signature) {\n        byte[] expected = computeMac(headers, unsignedText);\n        return MessageDigest.isEqual(expected, signature);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void validateAuthenticationTag(JweDecryptionInput jweDecryptionInput, byte[] theCek) {\n        byte[] actualAuthTag = jweDecryptionInput.getAuthTag();\n        \n        final AesCbcHmacJweEncryption.MacState macState = \n            AesCbcHmacJweEncryption.getInitializedMacState(theCek, \n                                                           jweDecryptionInput.getInitVector(),\n                                                           jweDecryptionInput.getAad(),\n                                                           jweDecryptionInput.getJweHeaders(),\n                                                           jweDecryptionInput.getDecodedJsonHeaders());\n        macState.mac.update(jweDecryptionInput.getEncryptedContent());\n        byte[] expectedAuthTag = AesCbcHmacJweEncryption.signAndGetTag(macState);\n        if (!Arrays.equals(actualAuthTag, expectedAuthTag)) {\n            LOG.warning(\"Invalid authentication tag\");\n            throw new JweException(JweException.Error.CONTENT_DECRYPTION_FAILURE);\n        }\n        \n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void validateAuthenticationTag(JweDecryptionInput jweDecryptionInput, byte[] theCek) {\n        byte[] actualAuthTag = jweDecryptionInput.getAuthTag();\n        \n        final AesCbcHmacJweEncryption.MacState macState = \n            AesCbcHmacJweEncryption.getInitializedMacState(theCek, \n                                                           jweDecryptionInput.getInitVector(),\n                                                           jweDecryptionInput.getAad(),\n                                                           jweDecryptionInput.getJweHeaders(),\n                                                           jweDecryptionInput.getDecodedJsonHeaders());\n        macState.mac.update(jweDecryptionInput.getEncryptedContent());\n        byte[] expectedAuthTag = AesCbcHmacJweEncryption.signAndGetTag(macState);\n        if (!MessageDigest.isEqual(actualAuthTag, expectedAuthTag)) {\n            LOG.warning(\"Invalid authentication tag\");\n            throw new JweException(JweException.Error.CONTENT_DECRYPTION_FAILURE);\n        }\n        \n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void run()  {    \n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void run()  {    \n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        ep = Endpoint.publish(address, implementor);\n        EndpointImpl epi = (EndpointImpl)ep;\n        epi.getService().getInInterceptors().add(new URIMappingInterceptor());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void main(String[] args) {\n        try {\n            Server s = new Server();\n            s.start();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        } finally {\n            System.out.println(\"done!\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void main(String[] args) {\n        try {\n            Server s = new Server();\n            s.start();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        } finally {\n            System.out.println(\"done!\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void run() {\n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLPort\";\n        Endpoint.publish(address, implementor);\n\n        Object implementor1 = new org.apache.hello_world_xml_http.wrapped.GreeterImpl();\n        address = \"http://localhost:\" + WRAP_PORT + \"/XMLService/XMLPort\";\n        Endpoint.publish(address, implementor1);\n\n        Object faultImplementor = new GreeterFaultImpl();\n        String faultAddress = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLFaultPort\";\n        Endpoint.publish(faultAddress, faultImplementor);\n\n        Object implementor2 = new HeaderTesterImpl();\n        address = \"http://localhost:\" + REG_PORT + \"/XMLContext/XMLPort\";\n        Endpoint.publish(address, implementor2);\n        \n        Object implementor3 = new org.apache.hello_world_xml_http.mixed.GreeterImpl();\n        address = \"http://localhost:\" + MIX_PORT + \"/XMLService/XMLPort\";\n        Endpoint.publish(address, implementor3);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void run() {\n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor));\n        \n        ((EndpointImpl)eps.get(0)).getService().getInInterceptors().add(new URIMappingInterceptor());\n\n        Object implementor1 = new org.apache.hello_world_xml_http.wrapped.GreeterImpl();\n        address = \"http://localhost:\" + WRAP_PORT + \"/XMLService/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor1));\n\n        Object faultImplementor = new GreeterFaultImpl();\n        String faultAddress = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLFaultPort\";\n        eps.add(Endpoint.publish(faultAddress, faultImplementor));\n\n        Object implementor2 = new HeaderTesterImpl();\n        address = \"http://localhost:\" + REG_PORT + \"/XMLContext/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor2));\n        \n        Object implementor3 = new org.apache.hello_world_xml_http.mixed.GreeterImpl();\n        address = \"http://localhost:\" + MIX_PORT + \"/XMLService/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor3));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void run() {\n        \n        Factory factory = new PerRequestFactory(DocLitWrappedCodeFirstServiceImpl.class);\n        factory = new PooledFactory(factory, 4);\n        \n        JAXWSMethodInvoker invoker = new JAXWSMethodInvoker(factory);\n        JaxWsServerFactoryBean factoryBean;\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.create();\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_SETTINGS_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.getServiceFactory().setAnonymousWrapperTypes(true);\n        factoryBean.getServiceFactory().getServiceConfigurations().add(0, new AbstractServiceConfiguration() {\n            public Boolean isWrapperPartNillable(MessagePartInfo mpi) {\n                return Boolean.TRUE;\n            }\n            public Long getWrapperPartMinOccurs(MessagePartInfo mpi) {\n                return Long.valueOf(1L);\n            }\n        });\n        factoryBean.create();\n         \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor7 = new DocLitBareCodeFirstServiceImpl();\n        EndpointImpl ep = (EndpointImpl)Endpoint.publish(DOCLITBARE_CODEFIRST_URL, implementor7);\n        ep.getServer().getEndpoint().getInInterceptors().add(new SAAJInInterceptor());\n\n        \n        Object implementor6 = new InterfaceInheritTestImpl();\n        Endpoint.publish(DOCLIT_CODEFIRST_BASE_URL, implementor6);\n        \n        Object implementor1 = new AnonymousComplexTypeImpl();\n        String address = \"http://localhost:\" + PORT + \"/anonymous_complex_typeSOAP\";\n        Endpoint.publish(address, implementor1);\n\n        Object implementor2 = new JaxbElementTestImpl();\n        address = \"http://localhost:\" + PORT + \"/jaxb_element_test\";\n        Endpoint.publish(address, implementor2);\n\n        Object implementor3 = new OrderedParamHolderImpl();\n        address = \"http://localhost:\" + PORT + \"/ordered_param_holder/\";\n        Endpoint.publish(address, implementor3);\n        \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor5 = new RpcLitCodeFirstServiceImpl();\n        Endpoint.publish(RPCLIT_CODEFIRST_URL, implementor5);\n        \n        Endpoint.publish(\"http://localhost:\" + PORT + \"/InheritContext/InheritPort\",\n                         new InheritImpl());\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void run() {\n        \n        Factory factory = new PerRequestFactory(DocLitWrappedCodeFirstServiceImpl.class);\n        factory = new PooledFactory(factory, 4);\n        \n        JAXWSMethodInvoker invoker = new JAXWSMethodInvoker(factory);\n        JaxWsServerFactoryBean factoryBean;\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.create();\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_SETTINGS_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.getServiceFactory().setAnonymousWrapperTypes(true);\n        factoryBean.getServiceFactory().getServiceConfigurations().add(0, new AbstractServiceConfiguration() {\n            public Boolean isWrapperPartNillable(MessagePartInfo mpi) {\n                return Boolean.TRUE;\n            }\n            public Long getWrapperPartMinOccurs(MessagePartInfo mpi) {\n                return Long.valueOf(1L);\n            }\n        });\n        factoryBean.create();\n         \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor7 = new DocLitBareCodeFirstServiceImpl();\n        EndpointImpl ep = (EndpointImpl)Endpoint.publish(DOCLITBARE_CODEFIRST_URL, implementor7);\n        ep.getServer().getEndpoint().getInInterceptors().add(new SAAJInInterceptor());\n        ep.getServer().getEndpoint().getInInterceptors().add(new URIMappingInterceptor());\n\n        \n        Object implementor6 = new InterfaceInheritTestImpl();\n        Endpoint.publish(DOCLIT_CODEFIRST_BASE_URL, implementor6);\n        \n        Object implementor1 = new AnonymousComplexTypeImpl();\n        String address = \"http://localhost:\" + PORT + \"/anonymous_complex_typeSOAP\";\n        Endpoint.publish(address, implementor1);\n\n        Object implementor2 = new JaxbElementTestImpl();\n        address = \"http://localhost:\" + PORT + \"/jaxb_element_test\";\n        Endpoint.publish(address, implementor2);\n\n        Object implementor3 = new OrderedParamHolderImpl();\n        address = \"http://localhost:\" + PORT + \"/ordered_param_holder/\";\n        Endpoint.publish(address, implementor3);\n        \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor5 = new RpcLitCodeFirstServiceImpl();\n        Endpoint.publish(RPCLIT_CODEFIRST_URL, implementor5);\n        \n        Endpoint.publish(\"http://localhost:\" + PORT + \"/InheritContext/InheritPort\",\n                         new InheritImpl());\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void run() {\n        Object implementor = new GreeterImplNoWsdl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/GreeterPort\";\n        Endpoint ep = Endpoint.create(implementor);\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(WSDLGetUtils.WSDL_CREATE_IMPORTS, Boolean.TRUE);\n        ep.setProperties(props);\n        ep.publish(address);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void run() {\n        Object implementor = new GreeterImplNoWsdl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/GreeterPort\";\n        Endpoint ep = Endpoint.create(implementor);\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(WSDLGetUtils.WSDL_CREATE_IMPORTS, Boolean.TRUE);\n        ep.setProperties(props);\n        ep.publish(address);\n        ((EndpointImpl)ep).getService().getInInterceptors().add(new URIMappingInterceptor());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void run() {\n            MyImplementation implementor = new MyImplementation();\n            JaxWsServerFactoryBean svrFactory = new JaxWsServerFactoryBean();\n            svrFactory.setServiceClass(MyInterface.class);\n            svrFactory.setAddress(BASE_URL);\n            svrFactory.setServiceBean(implementor);\n            svrFactory.getInInterceptors().add(new LoggingInInterceptor());\n            svrFactory.getOutInterceptors().add(new LoggingOutInterceptor());\n            svrFactory.create();\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void run() {\n            MyImplementation implementor = new MyImplementation();\n            JaxWsServerFactoryBean svrFactory = new JaxWsServerFactoryBean();\n            svrFactory.setServiceClass(MyInterface.class);\n            svrFactory.getInInterceptors().add(new URIMappingInterceptor());\n            svrFactory.setAddress(BASE_URL);\n            svrFactory.setServiceBean(implementor);\n            svrFactory.getInInterceptors().add(new LoggingInInterceptor());\n            svrFactory.getOutInterceptors().add(new LoggingOutInterceptor());\n            svrFactory.create();\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Server rsServer() {\n        JAXRSServerFactoryBean endpoint = new JAXRSServerFactoryBean();\n        endpoint.setBus(bus);\n        endpoint.setServiceBeans(Arrays.<Object>asList(new HelloServiceImpl1(), new HelloServiceImpl2()));\n        endpoint.setAddress(\"/\");\n        endpoint.setFeatures(Arrays.asList(new Swagger2Feature()));\n        return endpoint.create();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Server rsServer() {\n        JAXRSServerFactoryBean endpoint = new JAXRSServerFactoryBean();\n        endpoint.setBus(bus);\n        endpoint.setServiceBeans(Arrays.<Object>asList(new HelloServiceImpl1(), new HelloServiceImpl2()));\n        endpoint.setAddress(\"/a\");\n        endpoint.setFeatures(Arrays.asList(new Swagger2Feature()));\n        return endpoint.create();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void checkPrivileges(HiveOperationType hiveOpType, List<HivePrivilegeObject> hiveObjects,\n                               String userName, Operation2Privilege.IOType ioType, List<String> deniedMessages) {\n\n    if (hiveObjects == null) {\n      return;\n    }\n    if (admins != null && Arrays.stream(admins).parallel().anyMatch(n -> n.equals(userName))) {\n      return; // Skip rest of checks if user is admin\n    }\n\n    // Special-casing for ADMIN-level operations that do not require object checking.\n    if (Operation2Privilege.isAdminPrivOperation(hiveOpType)) {\n      // Require ADMIN privilege\n      deniedMessages.add(SQLPrivTypeGrant.ADMIN_PRIV.toString() + \" on \" + ioType);\n      return; // Ignore object, fail if not admin, succeed if admin.\n    }\n\n    boolean needAdmin = false;\n    for (HivePrivilegeObject hiveObj : hiveObjects) {\n      // If involving local file system\n      if (hiveObj.getType() == HivePrivilegeObject.HivePrivilegeObjectType.LOCAL_URI) {\n        needAdmin = true;\n        break;\n      }\n    }\n    if (!needAdmin) {\n      switch (hiveOpType) {\n        case ADD:\n        case DFS:\n        case COMPILE:\n          needAdmin = true;\n          break;\n        default:\n          break;\n      }\n    }\n    if (needAdmin) {\n      deniedMessages.add(\"ADMIN\");\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void checkPrivileges(HiveOperationType hiveOpType, List<HivePrivilegeObject> hiveObjects,\n                               String userName, Operation2Privilege.IOType ioType, List<String> deniedMessages) {\n\n    if (hiveObjects == null) {\n      return;\n    }\n\n    boolean isAdmin = false;\n    if (admins != null && admins.length > 0) {\n      isAdmin = Arrays.asList(admins).contains(userName);\n    }\n\n    if (isAdmin) {\n      return; // Skip rest of checks if user is admin\n    }\n\n    // Special-casing for ADMIN-level operations that do not require object checking.\n    if (Operation2Privilege.isAdminPrivOperation(hiveOpType)) {\n      // Require ADMIN privilege\n      deniedMessages.add(SQLPrivTypeGrant.ADMIN_PRIV.toString() + \" on \" + ioType);\n      return; // Ignore object, fail if not admin, succeed if admin.\n    }\n\n    boolean needAdmin = false;\n    for (HivePrivilegeObject hiveObj : hiveObjects) {\n      // If involving local file system\n      if (hiveObj.getType() == HivePrivilegeObject.HivePrivilegeObjectType.LOCAL_URI) {\n        needAdmin = true;\n        break;\n      }\n    }\n    if (!needAdmin) {\n      switch (hiveOpType) {\n        case ADD:\n        case DFS:\n        case COMPILE:\n          needAdmin = true;\n          break;\n        default:\n          break;\n      }\n    }\n    if (needAdmin) {\n      deniedMessages.add(\"ADMIN\");\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static HierarchicalConfiguration loadXml(InputStream xmlStream) {\n        XMLConfiguration cfg = new XMLConfiguration();\n        try {\n            cfg.load(xmlStream);\n            return cfg;\n        } catch (ConfigurationException e) {\n            throw new IllegalArgumentException(\"Cannot load xml from Stream\", e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static HierarchicalConfiguration loadXml(InputStream xmlStream) {\n        try {\n            XMLConfiguration cfg = new XMLConfiguration();\n            DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();\n            //Disabling DTDs in order to avoid XXE xml-based attacks.\n            disableFeature(dbfactory, DISALLOW_DTD_FEATURE);\n            disableFeature(dbfactory, DISALLOW_EXTERNAL_DTD);\n            dbfactory.setXIncludeAware(false);\n            dbfactory.setExpandEntityReferences(false);\n            cfg.setDocumentBuilder(dbfactory.newDocumentBuilder());\n            cfg.load(xmlStream);\n            return cfg;\n        } catch (ConfigurationException | ParserConfigurationException e) {\n            throw new IllegalArgumentException(\"Cannot load xml from Stream\", e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static List<ControllerInfo> parseStreamControllers(HierarchicalConfiguration cfg) {\n        List<ControllerInfo> controllers = new ArrayList<>();\n        List<HierarchicalConfiguration> fields =\n                cfg.configurationsAt(\"data.capable-switch.\" +\n                                             \"logical-switches.\" +\n                                             \"switch.controllers.controller\");\n        for (HierarchicalConfiguration sub : fields) {\n            controllers.add(new ControllerInfo(\n                    IpAddress.valueOf(sub.getString(\"ip-address\")),\n                    Integer.parseInt(sub.getString(\"port\")),\n                    sub.getString(\"protocol\")));\n        }\n        return controllers;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static List<ControllerInfo> parseStreamControllers(HierarchicalConfiguration cfg) {\n        List<ControllerInfo> controllers = new ArrayList<>();\n        List<HierarchicalConfiguration> fields =\n                cfg.configurationsAt(\"data.capable-switch.\" +\n                        \"logical-switches.\" +\n                        \"switch.controllers.controller\");\n        for (HierarchicalConfiguration sub : fields) {\n            controllers.add(new ControllerInfo(\n                    IpAddress.valueOf(sub.getString(\"ip-address\")),\n                    Integer.parseInt(sub.getString(\"port\")),\n                    sub.getString(\"protocol\")));\n        }\n        return controllers;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected static String parseSwitchId(HierarchicalConfiguration cfg) {\n        HierarchicalConfiguration field =\n                cfg.configurationAt(\"data.capable-switch.\" +\n                                            \"logical-switches.\" +\n                                            \"switch\");\n        return field.getProperty(\"id\").toString();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected static String parseSwitchId(HierarchicalConfiguration cfg) {\n        HierarchicalConfiguration field =\n                cfg.configurationAt(\"data.capable-switch.\" +\n                        \"logical-switches.\" +\n                        \"switch\");\n        return field.getProperty(\"id\").toString();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static String createControllersConfig(HierarchicalConfiguration cfg,\n                                                 HierarchicalConfiguration actualCfg,\n                                                 String target, String netconfOperation,\n                                                 String controllerOperation,\n                                                 List<ControllerInfo> controllers) {\n        //cfg.getKeys().forEachRemaining(key -> System.out.println(key));\n        cfg.setProperty(\"edit-config.target\", target);\n        cfg.setProperty(\"edit-config.default-operation\", netconfOperation);\n        cfg.setProperty(\"edit-config.config.capable-switch.id\",\n                        parseCapableSwitchId(actualCfg));\n        cfg.setProperty(\"edit-config.config.capable-switch.\" +\n                                \"logical-switches.switch.id\", parseSwitchId(actualCfg));\n        List<ConfigurationNode> newControllers = new ArrayList<>();\n        for (ControllerInfo ci : controllers) {\n            XMLConfiguration controller = new XMLConfiguration();\n            controller.setRoot(new HierarchicalConfiguration.Node(\"controller\"));\n            String id = ci.type() + \":\" + ci.ip() + \":\" + ci.port();\n            controller.setProperty(\"id\", id);\n            controller.setProperty(\"ip-address\", ci.ip());\n            controller.setProperty(\"port\", ci.port());\n            controller.setProperty(\"protocol\", ci.type());\n            newControllers.add(controller.getRootNode());\n        }\n        cfg.addNodes(\"edit-config.config.capable-switch.logical-switches.\" +\n                             \"switch.controllers\", newControllers);\n        XMLConfiguration editcfg = (XMLConfiguration) cfg;\n        StringWriter stringWriter = new StringWriter();\n        try {\n            editcfg.save(stringWriter);\n        } catch (ConfigurationException e) {\n            log.error(\"createControllersConfig()\", e);\n        }\n        String s = stringWriter.toString()\n                .replaceAll(\"<controller>\",\n                            \"<controller nc:operation=\\\"\" + controllerOperation + \"\\\">\");\n        s = s.replace(\"<target>\" + target + \"</target>\",\n                      \"<target><\" + target + \"/></target>\");\n        return s;\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static String createControllersConfig(HierarchicalConfiguration cfg,\n                                                 HierarchicalConfiguration actualCfg,\n                                                 String target, String netconfOperation,\n                                                 String controllerOperation,\n                                                 List<ControllerInfo> controllers) {\n        //cfg.getKeys().forEachRemaining(key -> System.out.println(key));\n        cfg.setProperty(\"edit-config.target\", target);\n        cfg.setProperty(\"edit-config.default-operation\", netconfOperation);\n        cfg.setProperty(\"edit-config.config.capable-switch.id\",\n                parseCapableSwitchId(actualCfg));\n        cfg.setProperty(\"edit-config.config.capable-switch.\" +\n                \"logical-switches.switch.id\", parseSwitchId(actualCfg));\n        List<ConfigurationNode> newControllers = new ArrayList<>();\n        for (ControllerInfo ci : controllers) {\n            XMLConfiguration controller = new XMLConfiguration();\n            controller.setRoot(new HierarchicalConfiguration.Node(\"controller\"));\n            String id = ci.type() + \":\" + ci.ip() + \":\" + ci.port();\n            controller.setProperty(\"id\", id);\n            controller.setProperty(\"ip-address\", ci.ip());\n            controller.setProperty(\"port\", ci.port());\n            controller.setProperty(\"protocol\", ci.type());\n            newControllers.add(controller.getRootNode());\n        }\n        cfg.addNodes(\"edit-config.config.capable-switch.logical-switches.\" +\n                \"switch.controllers\", newControllers);\n        XMLConfiguration editcfg = (XMLConfiguration) cfg;\n        StringWriter stringWriter = new StringWriter();\n        try {\n            editcfg.save(stringWriter);\n        } catch (ConfigurationException e) {\n            log.error(\"createControllersConfig()\", e);\n        }\n        String s = stringWriter.toString()\n                .replaceAll(\"<controller>\",\n                        \"<controller nc:operation=\\\"\" + controllerOperation + \"\\\">\");\n        s = s.replace(\"<target>\" + target + \"</target>\",\n                \"<target><\" + target + \"/></target>\");\n        return s;\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected void execute() {\n\n        Arrays.asList(controllersListStrings).forEach(\n                cInfoString -> controllers.add(parseCInfoString(cInfoString)));\n        DriverService service = get(DriverService.class);\n        deviceId = DeviceId.deviceId(uri);\n        DriverHandler h = service.createHandler(deviceId);\n        ControllerConfig config = h.behaviour(ControllerConfig.class);\n        print(\"before:\");\n        config.getControllers().forEach(c -> print(c.target()));\n        try {\n            if (removeAll) {\n                if (!controllers.isEmpty()) {\n                    print(\"Controllers list should be empty to remove all controllers\");\n                } else {\n                    List<ControllerInfo> controllersToRemove = config.getControllers();\n                    controllersToRemove.forEach(c -> print(\"Will remove \" + c.target()));\n                    config.removeControllers(controllersToRemove);\n                }\n            } else {\n                if (controllers.isEmpty()) {\n                    print(\"Controllers list is empty, cannot set/remove empty controllers\");\n                } else {\n                    if (removeCont) {\n                        print(\"Will remove specified controllers\");\n                        config.removeControllers(controllers);\n                    } else {\n                        print(\"Will add specified controllers\");\n                        config.setControllers(controllers);\n                    }\n                }\n            }\n        } catch (NullPointerException e) {\n            print(\"No Device with requested parameters {} \", uri);\n        }\n        print(\"after:\");\n        config.getControllers().forEach(c -> print(c.target()));\n        print(\"size %d\", config.getControllers().size());\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected void execute() {\n\n        if (controllersListStrings == null && !removeCont && !removeAll) {\n            print(\"No controller are given, skipping.\");\n            return;\n        }\n        if (controllersListStrings != null) {\n            Arrays.asList(controllersListStrings).forEach(\n                    cInfoString -> {\n                        ControllerInfo controllerInfo = parseCInfoString(cInfoString);\n                        if (controllerInfo != null) {\n                            controllers.add(controllerInfo);\n                        }\n                    });\n        }\n        DriverService service = get(DriverService.class);\n        deviceId = DeviceId.deviceId(uri);\n        DriverHandler h = service.createHandler(deviceId);\n        ControllerConfig config = h.behaviour(ControllerConfig.class);\n        print(\"before:\");\n        config.getControllers().forEach(c -> print(c.target()));\n        try {\n            if (removeAll) {\n                if (!controllers.isEmpty()) {\n                    print(\"Controllers list should be empty to remove all controllers\");\n                } else {\n                    List<ControllerInfo> controllersToRemove = config.getControllers();\n                    controllersToRemove.forEach(c -> print(\"Will remove \" + c.target()));\n                    config.removeControllers(controllersToRemove);\n                }\n            } else {\n                if (controllers.isEmpty()) {\n                    print(\"Controllers list is empty, cannot set/remove empty controllers\");\n                } else {\n                    if (removeCont) {\n                        print(\"Will remove specified controllers\");\n                        config.removeControllers(controllers);\n                    } else {\n                        print(\"Will add specified controllers\");\n                        config.setControllers(controllers);\n                    }\n                }\n            }\n        } catch (NullPointerException e) {\n            print(\"No Device with requested parameters {} \", uri);\n        }\n        print(\"after:\");\n        config.getControllers().forEach(c -> print(c.target()));\n        print(\"size %d\", config.getControllers().size());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private ControllerInfo parseCInfoString(String cInfoString) {\n        Annotations annotation;\n\n        String[] config = cInfoString.split(\",\");\n        if (config.length == 2) {\n            String[] pair = config[1].split(\"=\");\n\n            if (pair.length == 2) {\n                annotation = DefaultAnnotations.builder()\n                        .set(pair[0], pair[1]).build();\n            } else {\n                print(\"Wrong format {}\", config[1]);\n                return null;\n            }\n\n            String[] data = config[0].split(\":\");\n            String type = data[0];\n            IpAddress ip = IpAddress.valueOf(data[1]);\n            int port = Integer.parseInt(data[2]);\n\n            return new ControllerInfo(ip, port, type, annotation);\n        } else {\n            print(config[0]);\n            return new ControllerInfo(config[0]);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private ControllerInfo parseCInfoString(String cInfoString) {\n        Annotations annotation;\n\n        String[] config = cInfoString.split(\",\");\n        if (config.length == 2) {\n            String[] pair = config[1].split(\"=\");\n\n            if (pair.length == 2) {\n                annotation = DefaultAnnotations.builder()\n                        .set(pair[0], pair[1]).build();\n            } else {\n                print(\"Wrong format {}\", config[1]);\n                return null;\n            }\n\n            return getControllerInfo(annotation, config[0]);\n        } else {\n            return getControllerInfo(null, config[0]);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected byte[] generateNewSecret() {\n    return Long.toString(rand.nextLong()).getBytes(Charset.forName(\"UTF-8\"));\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected byte[] generateNewSecret() {\n    byte[] secret = new byte[32]; // 32 bytes = 256 bits\n    rand.nextBytes(secret);\n    return secret;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "private byte[] generateRandomSecret() {\n    return Long.toString(rand.nextLong()).getBytes(Charset.forName(\"UTF-8\"));\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected byte[] generateRandomSecret() {\n    byte[] secret = new byte[32]; // 32 bytes = 256 bits\n    rand.nextBytes(secret);\n    return secret;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "void setConf(Configuration conf) {\n    ldapUrl = conf.get(LDAP_URL_KEY, LDAP_URL_DEFAULT);\n    if (ldapUrl == null || ldapUrl.isEmpty()) {\n      throw new RuntimeException(\"LDAP URL is not configured\");\n    }\n    \n    useSsl = conf.getBoolean(LDAP_USE_SSL_KEY, LDAP_USE_SSL_DEFAULT);\n    keystore = conf.get(LDAP_KEYSTORE_KEY, LDAP_KEYSTORE_DEFAULT);\n    \n    keystorePass = getPassword(conf, LDAP_KEYSTORE_PASSWORD_KEY,\n        LDAP_KEYSTORE_PASSWORD_DEFAULT);\n    if (keystorePass.isEmpty()) {\n      keystorePass = extractPassword(conf.get(LDAP_KEYSTORE_PASSWORD_FILE_KEY,\n          LDAP_KEYSTORE_PASSWORD_FILE_DEFAULT));\n    }\n    \n    bindUser = conf.get(BIND_USER_KEY, BIND_USER_DEFAULT);\n    bindPassword = getPassword(conf, BIND_PASSWORD_KEY, BIND_PASSWORD_DEFAULT);\n    if (bindPassword.isEmpty()) {\n      bindPassword = extractPassword(\n          conf.get(BIND_PASSWORD_FILE_KEY, BIND_PASSWORD_FILE_DEFAULT));\n    }\n    \n    baseDN = conf.get(BASE_DN_KEY, BASE_DN_DEFAULT);\n    groupSearchFilter =\n        conf.get(GROUP_SEARCH_FILTER_KEY, GROUP_SEARCH_FILTER_DEFAULT);\n    userSearchFilter =\n        conf.get(USER_SEARCH_FILTER_KEY, USER_SEARCH_FILTER_DEFAULT);\n    isPosix = groupSearchFilter.contains(POSIX_GROUP) && userSearchFilter\n        .contains(POSIX_ACCOUNT);\n    groupMemberAttr =\n        conf.get(GROUP_MEMBERSHIP_ATTR_KEY, GROUP_MEMBERSHIP_ATTR_DEFAULT);\n    groupNameAttr =\n        conf.get(GROUP_NAME_ATTR_KEY, GROUP_NAME_ATTR_DEFAULT);\n\n    int dirSearchTimeout = conf.getInt(DIRECTORY_SEARCH_TIMEOUT, DIRECTORY_SEARCH_TIMEOUT_DEFAULT);\n    SEARCH_CONTROLS.setTimeLimit(dirSearchTimeout);\n    // Limit the attributes returned to only those required to speed up the search. See HADOOP-10626 for more details.\n    SEARCH_CONTROLS.setReturningAttributes(new String[] {groupNameAttr});\n\n    this.conf = conf;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "void setConf(Configuration conf) {\n    ldapUrl = conf.get(LDAP_URL_KEY, LDAP_URL_DEFAULT);\n    if (ldapUrl == null || ldapUrl.isEmpty()) {\n      throw new RuntimeException(\"LDAP URL is not configured\");\n    }\n    \n    useSsl = conf.getBoolean(LDAP_USE_SSL_KEY, LDAP_USE_SSL_DEFAULT);\n    keystore = conf.get(LDAP_KEYSTORE_KEY, LDAP_KEYSTORE_DEFAULT);\n    \n    keystorePass = getPassword(conf, LDAP_KEYSTORE_PASSWORD_KEY,\n        LDAP_KEYSTORE_PASSWORD_DEFAULT);\n    if (keystorePass.isEmpty()) {\n      keystorePass = extractPassword(conf.get(LDAP_KEYSTORE_PASSWORD_FILE_KEY,\n          LDAP_KEYSTORE_PASSWORD_FILE_DEFAULT));\n    }\n    \n    bindUser = conf.get(BIND_USER_KEY, BIND_USER_DEFAULT);\n    bindPassword = getPassword(conf, BIND_PASSWORD_KEY, BIND_PASSWORD_DEFAULT);\n    if (bindPassword.isEmpty()) {\n      bindPassword = extractPassword(\n          conf.get(BIND_PASSWORD_FILE_KEY, BIND_PASSWORD_FILE_DEFAULT));\n    }\n    \n    baseDN = conf.get(BASE_DN_KEY, BASE_DN_DEFAULT);\n    groupSearchFilter =\n        conf.get(GROUP_SEARCH_FILTER_KEY, GROUP_SEARCH_FILTER_DEFAULT);\n    userSearchFilter =\n        conf.get(USER_SEARCH_FILTER_KEY, USER_SEARCH_FILTER_DEFAULT);\n    isPosix = groupSearchFilter.contains(POSIX_GROUP) && userSearchFilter\n        .contains(POSIX_ACCOUNT);\n    groupMemberAttr =\n        conf.get(GROUP_MEMBERSHIP_ATTR_KEY, GROUP_MEMBERSHIP_ATTR_DEFAULT);\n    groupNameAttr =\n        conf.get(GROUP_NAME_ATTR_KEY, GROUP_NAME_ATTR_DEFAULT);\n    posixUidAttr =\n        conf.get(POSIX_UID_ATTR_KEY, POSIX_UID_ATTR_DEFAULT);\n    posixGidAttr =\n        conf.get(POSIX_GID_ATTR_KEY, POSIX_GID_ATTR_DEFAULT);\n\n    int dirSearchTimeout = conf.getInt(DIRECTORY_SEARCH_TIMEOUT, DIRECTORY_SEARCH_TIMEOUT_DEFAULT);\n    SEARCH_CONTROLS.setTimeLimit(dirSearchTimeout);\n    // Limit the attributes returned to only those required to speed up the search.\n    // See HADOOP-10626 and HADOOP-12001 for more details.\n    SEARCH_CONTROLS.setReturningAttributes(\n        new String[] {groupNameAttr, posixUidAttr, posixGidAttr});\n\n    this.conf = conf;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void interpolateCredHubReferences_whenAReferencedCredentialDoesNotExist_itThrowsAnException() {\n    String inputJsonString = \"{\"\n        + \"  \\\"pp-config-server\\\": [\"\n        + \"    {\"\n        + \"      \\\"credentials\\\": {\"\n        + \"        \\\"credhub-ref\\\": \\\"((/missing_cred))\\\"\"\n        + \"      },\"\n        + \"      \\\"label\\\": \\\"pp-config-server\\\"\"\n        + \"    }\"\n        + \"  ]\"\n        + \"}\";\n    Map<String, Object> inputJson = deserialize(inputJsonString, Map.class);\n\n    doReturn(\n        null\n    ).when(credentialDataService).findMostRecent(\"/missing_cred\");\n\n    try {\n      subject.interpolateCredHubReferences(inputJson, eventAuditRecordParameters);\n    } catch (ParameterizedValidationException exception) {\n      assertThat(exception.getMessage(), equalTo(\"error.interpolation.invalid_access\"));\n\n      assertThat(eventAuditRecordParameters, hasSize(1));\n      assertThat(eventAuditRecordParameters, contains(\n          samePropertyValuesAs(new EventAuditRecordParameters(CREDENTIAL_ACCESS, \"/missing_cred\"))\n      ));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void interpolateCredHubReferences_whenAReferencedCredentialDoesNotExist_itThrowsAnException() {\n    String inputJsonString = \"{\"\n        + \"  \\\"pp-config-server\\\": [\"\n        + \"    {\"\n        + \"      \\\"credentials\\\": {\"\n        + \"        \\\"credhub-ref\\\": \\\"((/missing_cred))\\\"\"\n        + \"      },\"\n        + \"      \\\"label\\\": \\\"pp-config-server\\\"\"\n        + \"    }\"\n        + \"  ]\"\n        + \"}\";\n    Map<String, Object> inputJson = deserialize(inputJsonString, Map.class);\n\n    doReturn(\n        null\n    ).when(credentialDataService).findMostRecent(\"/missing_cred\");\n\n    try {\n      subject.interpolateCredHubReferences(inputJson, eventAuditRecordParameters);\n    } catch (ParameterizedValidationException exception) {\n      assertThat(exception.getMessage(), equalTo(\"error.credential.invalid_access\"));\n\n      assertThat(eventAuditRecordParameters, hasSize(1));\n      assertThat(eventAuditRecordParameters, contains(\n          samePropertyValuesAs(new EventAuditRecordParameters(CREDENTIAL_ACCESS, \"/missing_cred\"))\n      ));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void save_whenThereIsAnExistingCredentialWithACEs_shouldThrowAnExceptionIfItLacksPermission() {\n    when(credentialDataService.findMostRecent(CREDENTIAL_NAME)).thenReturn(existingCredential);\n    when(permissionService.hasPermission(userContext.getAclUser(), CREDENTIAL_NAME, WRITE_ACL)).thenReturn(false);\n\n    accessControlEntries\n        .add(new PermissionEntry(\"some_actor\", Arrays.asList(PermissionOperation.READ_ACL)));\n\n    try {\n      subject.save(\n          userContext,\n          parametersList,\n          CREDENTIAL_NAME,\n          false,\n          \"password\",\n          generationParameters,\n          credentialValue,\n          accessControlEntries,\n          currentUserPermissions);\n    } catch (PermissionException pe) {\n      assertThat(pe.getMessage(), equalTo(\"error.acl.lacks_credential_write\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void save_whenThereIsAnExistingCredentialWithACEs_shouldThrowAnExceptionIfItLacksPermission() {\n    when(credentialDataService.findMostRecent(CREDENTIAL_NAME)).thenReturn(existingCredential);\n    when(permissionService.hasPermission(userContext.getAclUser(), CREDENTIAL_NAME, WRITE_ACL)).thenReturn(false);\n\n    accessControlEntries\n        .add(new PermissionEntry(\"some_actor\", Arrays.asList(PermissionOperation.READ_ACL)));\n\n    try {\n      subject.save(\n          userContext,\n          parametersList,\n          CREDENTIAL_NAME,\n          false,\n          \"password\",\n          generationParameters,\n          credentialValue,\n          accessControlEntries,\n          currentUserPermissions);\n    } catch (PermissionException pe) {\n      assertThat(pe.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void deleteCredential_whenTheUserLacksPermission_throwsAnException() {\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, DELETE))\n        .thenReturn(false);\n\n    try {\n      subject.deleteCredential(userContext, CREDENTIAL_NAME);\n      fail(\"Should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.acl.lacks_credential_write\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void deleteCredential_whenTheUserLacksPermission_throwsAnException() {\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, DELETE))\n        .thenReturn(false);\n\n    try {\n      subject.deleteCredential(userContext, CREDENTIAL_NAME);\n      fail(\"Should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void deleteCredential_whenTheCredentialIsNotDeleted_throwsAnException() {\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, DELETE))\n        .thenReturn(true);\n    when(credentialDataService.delete(CREDENTIAL_NAME)).thenReturn(false);\n\n    try {\n      subject.deleteCredential(userContext, CREDENTIAL_NAME);\n      fail(\"Should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.acl.lacks_credential_write\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void deleteCredential_whenTheCredentialIsNotDeleted_throwsAnException() {\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, DELETE))\n        .thenReturn(true);\n    when(credentialDataService.delete(CREDENTIAL_NAME)).thenReturn(false);\n\n    try {\n      subject.deleteCredential(userContext, CREDENTIAL_NAME);\n      fail(\"Should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void getAllCredentialVersions_whenTheUserLacksPermission_throwsException() {\n    List<Credential> credentials = newArrayList(version1, version2);\n    when(credentialDataService.findAllByName(CREDENTIAL_NAME))\n        .thenReturn(credentials);\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(false);\n\n    try {\n      subject.getAllCredentialVersions(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential_not_found\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void getAllCredentialVersions_whenTheUserLacksPermission_throwsException() {\n    List<Credential> credentials = newArrayList(version1, version2);\n    when(credentialDataService.findAllByName(CREDENTIAL_NAME))\n        .thenReturn(credentials);\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(false);\n\n    try {\n      subject.getAllCredentialVersions(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void getCredentialVersions_whenTheCredentialDoesNotExist_throwsException() {\n    when(credentialDataService.findAllByName(CREDENTIAL_NAME))\n        .thenReturn(emptyList());\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(true);\n\n    try {\n      subject.getAllCredentialVersions(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential_not_found\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void getCredentialVersions_whenTheCredentialDoesNotExist_throwsException() {\n    when(credentialDataService.findAllByName(CREDENTIAL_NAME))\n        .thenReturn(emptyList());\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(true);\n\n    try {\n      subject.getAllCredentialVersions(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void getMostRecentCredentialVersion_whenTheCredentialDoesNotExist_throwsException() {\n    when(credentialDataService.findMostRecent(CREDENTIAL_NAME))\n        .thenReturn(null);\n\n    try {\n      subject.getMostRecentCredentialVersion(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential_not_found\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void getMostRecentCredentialVersion_whenTheCredentialDoesNotExist_throwsException() {\n    when(credentialDataService.findMostRecent(CREDENTIAL_NAME))\n        .thenReturn(null);\n\n    try {\n      subject.getMostRecentCredentialVersion(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void getMostRecentCredentialVersion_whenTheUserLacksPermission_throwsException() {\n    when(credentialDataService.findMostRecent(CREDENTIAL_NAME))\n        .thenReturn(version1);\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(false);\n\n    try {\n      subject.getMostRecentCredentialVersion(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential_not_found\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void getMostRecentCredentialVersion_whenTheUserLacksPermission_throwsException() {\n    when(credentialDataService.findMostRecent(CREDENTIAL_NAME))\n        .thenReturn(version1);\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(false);\n\n    try {\n      subject.getMostRecentCredentialVersion(userContext, newArrayList(),\n          CREDENTIAL_NAME);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void getCredentialVersion_whenTheVersionDoesNotExist_throwsException() {\n    when(credentialDataService.findByUuid(UUID_STRING))\n        .thenReturn(null);\n\n    try {\n      subject.getCredentialVersion(userContext, newArrayList(), UUID_STRING);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential_not_found\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void getCredentialVersion_whenTheVersionDoesNotExist_throwsException() {\n    when(credentialDataService.findByUuid(UUID_STRING))\n        .thenReturn(null);\n\n    try {\n      subject.getCredentialVersion(userContext, newArrayList(), UUID_STRING);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void getCredentialVersion_whenTheUserLacksPermission_throwsException() {\n    when(credentialDataService.findByUuid(UUID_STRING))\n        .thenReturn(version1);\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(false);\n\n    try {\n      subject.getCredentialVersion(userContext, newArrayList(), UUID_STRING);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential_not_found\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void getCredentialVersion_whenTheUserLacksPermission_throwsException() {\n    when(credentialDataService.findByUuid(UUID_STRING))\n        .thenReturn(version1);\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, READ))\n        .thenReturn(false);\n\n    try {\n      subject.getCredentialVersion(userContext, newArrayList(), UUID_STRING);\n      fail(\"should throw exception\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setPermissions_whenUserDoesNotHavePermission_throwsException() {\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, WRITE_ACL))\n        .thenReturn(false);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n\n    try {\n      subject.setPermissions(userContext, CREDENTIAL_NAME, emptyList());\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.acl.lacks_credential_write\"));\n      verify(permissionsDataService, times(0)).saveAccessControlEntries(any(), any());\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setPermissions_whenUserDoesNotHavePermission_throwsException() {\n    when(permissionService.hasPermission(USER, CREDENTIAL_NAME, WRITE_ACL))\n        .thenReturn(false);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n\n    try {\n      subject.setPermissions(userContext, CREDENTIAL_NAME, emptyList());\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n      verify(permissionsDataService, times(0)).saveAccessControlEntries(any(), any());\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void setPermissions_whenTheCredentialDoesNotExist_throwsException() {\n    when(permissionService.hasPermission(any(String.class), eq(CREDENTIAL_NAME), eq(WRITE_ACL)))\n        .thenReturn(true);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n    when(credentialNameDataService.find(CREDENTIAL_NAME))\n        .thenReturn(null);\n\n    try {\n      subject.setPermissions(userContext, CREDENTIAL_NAME, emptyList());\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.acl.lacks_credential_write\"));\n      verify(permissionsDataService, times(0)).saveAccessControlEntries(any(), any());\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void setPermissions_whenTheCredentialDoesNotExist_throwsException() {\n    when(permissionService.hasPermission(any(String.class), eq(CREDENTIAL_NAME), eq(WRITE_ACL)))\n        .thenReturn(true);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n    when(credentialNameDataService.find(CREDENTIAL_NAME))\n        .thenReturn(null);\n\n    try {\n      subject.setPermissions(userContext, CREDENTIAL_NAME, emptyList());\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n      verify(permissionsDataService, times(0)).saveAccessControlEntries(any(), any());\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void deletePermissions_whenNothingIsDeleted_throwsAnException() {\n    when(permissionService.hasPermission(any(String.class), eq(CREDENTIAL_NAME), eq(WRITE_ACL)))\n        .thenReturn(true);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n    when(permissionsDataService.deleteAccessControlEntry(CREDENTIAL_NAME, ACTOR_NAME))\n        .thenReturn(false);\n\n    try {\n      subject.deletePermissionEntry(userContext, CREDENTIAL_NAME, ACTOR_NAME);\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.acl.lacks_credential_write\"));\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void deletePermissions_whenNothingIsDeleted_throwsAnException() {\n    when(permissionService.hasPermission(any(String.class), eq(CREDENTIAL_NAME), eq(WRITE_ACL)))\n        .thenReturn(true);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n    when(permissionsDataService.deleteAccessControlEntry(CREDENTIAL_NAME, ACTOR_NAME))\n        .thenReturn(false);\n\n    try {\n      subject.deletePermissionEntry(userContext, CREDENTIAL_NAME, ACTOR_NAME);\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void deletePermissions_whenTheUserLacksPermission_throwsInsteadOfDeletingThePermissions() {\n    when(permissionService.hasPermission(any(String.class), eq(CREDENTIAL_NAME), eq(WRITE_ACL)))\n        .thenReturn(false);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n\n    try {\n      subject.deletePermissionEntry(userContext, CREDENTIAL_NAME, ACTOR_NAME);\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.acl.lacks_credential_write\"));\n      verify(permissionsDataService, times(0)).deleteAccessControlEntry(any(), any());\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void deletePermissions_whenTheUserLacksPermission_throwsInsteadOfDeletingThePermissions() {\n    when(permissionService.hasPermission(any(String.class), eq(CREDENTIAL_NAME), eq(WRITE_ACL)))\n        .thenReturn(false);\n    when(permissionService.validAclUpdateOperation(userContext, ACTOR_NAME))\n        .thenReturn(true);\n\n    try {\n      subject.deletePermissionEntry(userContext, CREDENTIAL_NAME, ACTOR_NAME);\n      fail(\"should throw\");\n    } catch (EntryNotFoundException e) {\n      assertThat(e.getMessage(), equalTo(\"error.credential.invalid_access\"));\n      verify(permissionsDataService, times(0)).deleteAccessControlEntry(any(), any());\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void verifyCredentialWritePermission(UserContext userContext, String credentialName) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, WRITE)) {\n      throw new PermissionException(\"error.acl.lacks_credential_write\");\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void verifyCredentialWritePermission(UserContext userContext, String credentialName) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, WRITE)) {\n      throw new PermissionException(\"error.credential.invalid_access\");\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void verifyAclWrite(UserContext userContext, String credentialName) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, WRITE_ACL)) {\n      throw new PermissionException(\"error.acl.lacks_credential_write\");\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void verifyAclWrite(UserContext userContext, String credentialName) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, WRITE_ACL)) {\n      throw new PermissionException(\"error.credential.invalid_access\");\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "Object> interpolateCredHubReferences(Map<String, Object> servicesMap,\n      List<EventAuditRecordParameters> eventAuditRecordParameters) {\n\n    for (Object serviceProperties : servicesMap.values()) {\n      if (serviceProperties == null || !(serviceProperties instanceof ArrayList)) {\n        continue;\n      }\n      for (Object properties : (ArrayList) serviceProperties) {\n        if (!(properties instanceof Map)) {\n          continue;\n        }\n        Map<String, Object> propertiesMap = (Map) properties;\n        Object credentials = propertiesMap.get(\"credentials\");\n        if (credentials == null || !(credentials instanceof Map)) {\n          continue;\n        }\n        // Allow either snake_case or kebab-case\n        Object credhubRef = ((Map) credentials).get(\"credhub_ref\");\n        if (credhubRef == null) {\n          credhubRef = ((Map) credentials).get(\"credhub-ref\");\n        }\n\n        if (credhubRef == null || !(credhubRef instanceof String)) {\n          continue;\n        }\n        String credentialName = getCredentialNameFromRef((String) credhubRef);\n\n        Credential credential = credentialDataService.findMostRecent(credentialName);\n        if (credential == null) {\n          eventAuditRecordParameters\n              .add(new EventAuditRecordParameters(CREDENTIAL_ACCESS, credentialName));\n\n          throw new ParameterizedValidationException(\"error.interpolation.invalid_access\");\n        }\n\n        eventAuditRecordParameters\n            .add(new EventAuditRecordParameters(CREDENTIAL_ACCESS, credential.getName()));\n\n        if (credential instanceof JsonCredential) {\n          propertiesMap.put(\"credentials\", ((JsonCredential) credential).getValue());\n        } else {\n          throw new ParameterizedValidationException(\"error.interpolation.invalid_type\",\n              credentialName);\n        }\n      }\n    }\n    return servicesMap;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "Object> interpolateCredHubReferences(Map<String, Object> servicesMap,\n      List<EventAuditRecordParameters> eventAuditRecordParameters) {\n\n    for (Object serviceProperties : servicesMap.values()) {\n      if (serviceProperties == null || !(serviceProperties instanceof ArrayList)) {\n        continue;\n      }\n      for (Object properties : (ArrayList) serviceProperties) {\n        if (!(properties instanceof Map)) {\n          continue;\n        }\n        Map<String, Object> propertiesMap = (Map) properties;\n        Object credentials = propertiesMap.get(\"credentials\");\n        if (credentials == null || !(credentials instanceof Map)) {\n          continue;\n        }\n        // Allow either snake_case or kebab-case\n        Object credhubRef = ((Map) credentials).get(\"credhub_ref\");\n        if (credhubRef == null) {\n          credhubRef = ((Map) credentials).get(\"credhub-ref\");\n        }\n\n        if (credhubRef == null || !(credhubRef instanceof String)) {\n          continue;\n        }\n        String credentialName = getCredentialNameFromRef((String) credhubRef);\n\n        Credential credential = credentialDataService.findMostRecent(credentialName);\n        if (credential == null) {\n          eventAuditRecordParameters\n              .add(new EventAuditRecordParameters(CREDENTIAL_ACCESS, credentialName));\n\n          throw new ParameterizedValidationException(\"error.credential.invalid_access\");\n        }\n\n        eventAuditRecordParameters\n            .add(new EventAuditRecordParameters(CREDENTIAL_ACCESS, credential.getName()));\n\n        if (credential instanceof JsonCredential) {\n          propertiesMap.put(\"credentials\", ((JsonCredential) credential).getValue());\n        } else {\n          throw new ParameterizedValidationException(\"error.interpolation.invalid_type\",\n              credentialName);\n        }\n      }\n    }\n    return servicesMap;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public CredentialView performRegenerate(\n      UserContext userContext,\n      List<EventAuditRecordParameters> parametersList,\n      CredentialRegenerateRequest requestBody,\n      PermissionEntry currentUserPermissionEntry) {\n    Credential credential = credentialDataService.findMostRecent(requestBody.getName());\n    if (credential == null) {\n      parametersList.add(new EventAuditRecordParameters(CREDENTIAL_UPDATE, requestBody.getName()));\n      throw new EntryNotFoundException(\"error.credential_not_found\");\n    }\n\n    Regeneratable regeneratable = regeneratableTypes\n        .getOrDefault(credential.getCredentialType(), NotRegeneratable::new)\n        .get();\n\n    if (credential instanceof PasswordCredential && ((PasswordCredential) credential).getGenerationParameters() == null) {\n      parametersList.add(new EventAuditRecordParameters(CREDENTIAL_UPDATE, requestBody.getName()));\n    }\n\n    final BaseCredentialGenerateRequest generateRequest = regeneratable\n        .createGenerateRequest(credential);\n\n    final CredentialValue credentialValue = CredentialValueFactory\n        .generateValue(generateRequest, generatorService);\n\n    StringGenerationParameters generationParameters = null;\n    if (generateRequest instanceof PasswordGenerateRequest) {\n      generationParameters = ((PasswordGenerateRequest) generateRequest).getGenerationParameters();\n    }\n\n    return credentialService.save(\n        userContext,\n        parametersList,\n        generateRequest.getName(),\n        generateRequest.isOverwrite(),\n        generateRequest.getType(),\n        generationParameters,\n        credentialValue,\n        generateRequest.getAdditionalPermissions(),\n        currentUserPermissionEntry);\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public CredentialView performRegenerate(\n      UserContext userContext,\n      List<EventAuditRecordParameters> parametersList,\n      CredentialRegenerateRequest requestBody,\n      PermissionEntry currentUserPermissionEntry) {\n    Credential credential = credentialDataService.findMostRecent(requestBody.getName());\n    if (credential == null) {\n      parametersList.add(new EventAuditRecordParameters(CREDENTIAL_UPDATE, requestBody.getName()));\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n\n    Regeneratable regeneratable = regeneratableTypes\n        .getOrDefault(credential.getCredentialType(), NotRegeneratable::new)\n        .get();\n\n    if (credential instanceof PasswordCredential && ((PasswordCredential) credential).getGenerationParameters() == null) {\n      parametersList.add(new EventAuditRecordParameters(CREDENTIAL_UPDATE, requestBody.getName()));\n    }\n\n    final BaseCredentialGenerateRequest generateRequest = regeneratable\n        .createGenerateRequest(credential);\n\n    final CredentialValue credentialValue = CredentialValueFactory\n        .generateValue(generateRequest, generatorService);\n\n    StringGenerationParameters generationParameters = null;\n    if (generateRequest instanceof PasswordGenerateRequest) {\n      generationParameters = ((PasswordGenerateRequest) generateRequest).getGenerationParameters();\n    }\n\n    return credentialService.save(\n        userContext,\n        parametersList,\n        generateRequest.getName(),\n        generateRequest.isOverwrite(),\n        generateRequest.getType(),\n        generationParameters,\n        credentialValue,\n        generateRequest.getAdditionalPermissions(),\n        currentUserPermissionEntry);\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void deleteCredential(UserContext userContext, String credentialName) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, DELETE)) {\n      throw new EntryNotFoundException(\"error.acl.lacks_credential_write\");\n    }\n\n    boolean deleteSucceeded = credentialDataService.delete(credentialName);\n\n    if (!deleteSucceeded) {\n      throw new EntryNotFoundException(\"error.acl.lacks_credential_write\");\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void deleteCredential(UserContext userContext, String credentialName) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, DELETE)) {\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n\n    boolean deleteSucceeded = credentialDataService.delete(credentialName);\n\n    if (!deleteSucceeded) {\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DataResponse getAllCredentialVersions(\n      UserContext userContext,\n      List<EventAuditRecordParameters> auditRecordParametersList,\n      String credentialName\n  ) {\n    EventAuditRecordParameters auditRecordParameters = new EventAuditRecordParameters(AuditingOperationCode.CREDENTIAL_ACCESS, credentialName);\n    auditRecordParametersList.add(auditRecordParameters);\n\n    List<Credential> credentials = credentialDataService.findAllByName(credentialName);\n\n    // We need this extra check in case permissions aren't being enforced.\n    if (credentials.isEmpty() || !permissionService.hasPermission(userContext.getAclUser(), credentialName, READ)) {\n      throw new EntryNotFoundException(\"error.credential_not_found\");\n    }\n\n    return DataResponse.fromEntity(credentials);\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DataResponse getAllCredentialVersions(\n      UserContext userContext,\n      List<EventAuditRecordParameters> auditRecordParametersList,\n      String credentialName\n  ) {\n    EventAuditRecordParameters auditRecordParameters = new EventAuditRecordParameters(AuditingOperationCode.CREDENTIAL_ACCESS, credentialName);\n    auditRecordParametersList.add(auditRecordParameters);\n\n    List<Credential> credentials = credentialDataService.findAllByName(credentialName);\n\n    // We need this extra check in case permissions aren't being enforced.\n    if (credentials.isEmpty() || !permissionService.hasPermission(userContext.getAclUser(), credentialName, READ)) {\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n\n    return DataResponse.fromEntity(credentials);\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "private Credential getVersionByIdentifier(\n      UserContext userContext,\n      List<EventAuditRecordParameters> auditRecordParametersList,\n      String identifier,\n      Function<String, Credential> getFn\n  ) {\n    EventAuditRecordParameters eventAuditRecordParameters = new EventAuditRecordParameters(\n        AuditingOperationCode.CREDENTIAL_ACCESS\n    );\n\n    Credential credential = getFn.apply(identifier);\n\n    if (credential != null) {\n      eventAuditRecordParameters.setCredentialName(credential.getName());\n    }\n\n    auditRecordParametersList.add(eventAuditRecordParameters);\n\n    if (credential == null || !permissionService.hasPermission(userContext.getAclUser(), credential.getName(), READ)) {\n      throw new EntryNotFoundException(\"error.credential_not_found\");\n    }\n\n    return credential;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "private Credential getVersionByIdentifier(\n      UserContext userContext,\n      List<EventAuditRecordParameters> auditRecordParametersList,\n      String identifier,\n      Function<String, Credential> getFn\n  ) {\n    EventAuditRecordParameters eventAuditRecordParameters = new EventAuditRecordParameters(\n        AuditingOperationCode.CREDENTIAL_ACCESS\n    );\n\n    Credential credential = getFn.apply(identifier);\n\n    if (credential != null) {\n      eventAuditRecordParameters.setCredentialName(credential.getName());\n    }\n\n    auditRecordParametersList.add(eventAuditRecordParameters);\n\n    if (credential == null || !permissionService.hasPermission(userContext.getAclUser(), credential.getName(), READ)) {\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n\n    return credential;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public PermissionsView setPermissions(UserContext userContext, String name,\n      List<PermissionEntry> permissionEntryList) {\n    final CredentialName credentialName = credentialNameDataService.find(name);\n\n    // We need to verify that the credential exists in case ACL enforcement is off\n    if (credentialName == null || !permissionService.hasPermission(userContext.getAclUser(), name, WRITE_ACL)) {\n      throw new EntryNotFoundException(\"error.acl.lacks_credential_write\");\n    }\n\n    for (PermissionEntry permissionEntry : permissionEntryList) {\n      if (!permissionService.validAclUpdateOperation(userContext, permissionEntry.getActor())) {\n        throw new InvalidAclOperationException(\"error.acl.invalid_update_operation\");\n      }\n    }\n\n    permissionsDataService\n        .saveAccessControlEntries(credentialName, permissionEntryList);\n\n    return new PermissionsView(credentialName.getName(),\n        permissionsDataService.getAccessControlList(credentialName));\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public PermissionsView setPermissions(UserContext userContext, String name,\n      List<PermissionEntry> permissionEntryList) {\n    final CredentialName credentialName = credentialNameDataService.find(name);\n\n    // We need to verify that the credential exists in case ACL enforcement is off\n    if (credentialName == null || !permissionService.hasPermission(userContext.getAclUser(), name, WRITE_ACL)) {\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n\n    for (PermissionEntry permissionEntry : permissionEntryList) {\n      if (!permissionService.validAclUpdateOperation(userContext, permissionEntry.getActor())) {\n        throw new InvalidAclOperationException(\"error.acl.invalid_update_operation\");\n      }\n    }\n\n    permissionsDataService\n        .saveAccessControlEntries(credentialName, permissionEntryList);\n\n    return new PermissionsView(credentialName.getName(),\n        permissionsDataService.getAccessControlList(credentialName));\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void deletePermissionEntry(UserContext userContext, String credentialName, String actor) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, WRITE_ACL)) {\n      throw new EntryNotFoundException(\"error.acl.lacks_credential_write\");\n    }\n\n    if (!permissionService.validAclUpdateOperation(userContext, actor)) {\n      throw new InvalidAclOperationException(\"error.acl.invalid_update_operation\");\n    }\n\n    boolean successfullyDeleted = permissionsDataService\n        .deleteAccessControlEntry(credentialName, actor);\n\n    if (!successfullyDeleted) {\n      throw new EntryNotFoundException(\"error.acl.lacks_credential_write\");\n    }\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void deletePermissionEntry(UserContext userContext, String credentialName, String actor) {\n    if (!permissionService.hasPermission(userContext.getAclUser(), credentialName, WRITE_ACL)) {\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n\n    if (!permissionService.validAclUpdateOperation(userContext, actor)) {\n      throw new InvalidAclOperationException(\"error.acl.invalid_update_operation\");\n    }\n\n    boolean successfullyDeleted = permissionsDataService\n        .deleteAccessControlEntry(credentialName, actor);\n\n    if (!successfullyDeleted) {\n      throw new EntryNotFoundException(\"error.credential.invalid_access\");\n    }\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "Object> interpolate(@RequestBody Map<String, Object> requestBody,\n      RequestUuid requestUuid,\n      UserContext userContext) {\n    return eventAuditLogService.auditEvents(requestUuid, userContext, (eventAuditRecordParameters ->\n          jsonInterpolationService\n            .interpolateCredHubReferences(requestBody, eventAuditRecordParameters))\n    );\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "Object> interpolate(\n      @RequestBody Map<String, Object> requestBody,\n      RequestUuid requestUuid,\n      UserContext userContext\n  ) {\n    return eventAuditLogService.auditEvents(requestUuid, userContext, (eventAuditRecordParametersList ->\n          jsonInterpolationService\n            .interpolateCredHubReferences(userContext, requestBody, eventAuditRecordParametersList))\n    );\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public CredentialView getCredentialById(\n      @PathVariable String id,\n      RequestUuid requestUuid,\n      UserContext userContext) {\n    return eventAuditLogService.auditEvents(requestUuid, userContext, eventAuditRecordParametersList -> (\n        credentialHandler.getCredentialVersion(userContext, eventAuditRecordParametersList, id)\n    ));\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public CredentialView getCredentialById(\n      @PathVariable String id,\n      RequestUuid requestUuid,\n      UserContext userContext) {\n    return eventAuditLogService.auditEvents(requestUuid, userContext, eventAuditRecordParametersList -> {\n      Credential credentialVersion = credentialHandler.getCredentialVersion(userContext, eventAuditRecordParametersList, id);\n      return CredentialView.fromEntity(credentialVersion);\n    });\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void testDSAsha3(int size, BigInteger s)\n    {\n        DSAParameters dsaParams = new DSAParameters(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeyParameters priKey = new DSAPrivateKeyParameters(x, dsaParams);\n        SecureRandom k = new TestRandomBigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\");\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        DSADigestSigner dsa = new DSADigestSigner(new DSASigner(), new SHA3Digest(size));\n\n        dsa.init(true, new ParametersWithRandom(priKey, k));\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.generateSignature();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        DSAPublicKeyParameters pubKey = new DSAPublicKeyParameters(y, dsaParams);\n\n        dsa.init(false, pubKey);\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verifySignature(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void testDSAsha3(int size, BigInteger s)\n    {\n        DSAParameters dsaParams = new DSAParameters(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeyParameters priKey = new DSAPrivateKeyParameters(x, dsaParams);\n        SecureRandom k = new FixedSecureRandom(\n            new FixedSecureRandom.Source[] {\n                new FixedSecureRandom.BigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\"))),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\"))\n            });\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        DSADigestSigner dsa = new DSADigestSigner(new DSASigner(), new SHA3Digest(size));\n\n        dsa.init(true, new ParametersWithRandom(priKey, k));\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.generateSignature();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        DSAPublicKeyParameters pubKey = new DSAPublicKeyParameters(y, dsaParams);\n\n        dsa.init(false, pubKey);\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verifySignature(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void dsa2Test1()\n    {\n        byte[] seed = Hex.decode(\"ED8BEE8D1CB89229D2903CBF0E51EE7377F48698\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator();\n\n        pGen.init(new DSAParameterGenerationParameters(1024, 160, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 5)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"E950511EAB424B9A19A2AEB4E159B7844C589C4F\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"E0A67598CD1B763B\" +\n            \"C98C8ABB333E5DDA0CD3AA0E5E1FB5BA8A7B4EABC10BA338\" +\n            \"FAE06DD4B90FDA70D7CF0CB0C638BE3341BEC0AF8A7330A3\" +\n            \"307DED2299A0EE606DF035177A239C34A912C202AA5F83B9\" +\n            \"C4A7CF0235B5316BFC6EFB9A248411258B30B839AF172440\" +\n            \"F32563056CB67A861158DDD90E6A894C72A5BBEF9E286C6B\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"D29D5121B0423C27\" +\n            \"69AB21843E5A3240FF19CACC792264E3BB6BE4F78EDD1B15\" +\n            \"C4DFF7F1D905431F0AB16790E1F773B5CE01C804E509066A\" +\n            \"9919F5195F4ABC58189FD9FF987389CB5BEDF21B4DAB4F8B\" +\n            \"76A055FFE2770988FE2EC2DE11AD92219F0B351869AC24DA\" +\n            \"3D7BA87011A701CE8EE7BFE49486ED4527B7186CA4610A75\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomBigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"25282217F5730501\" +\n            \"DD8DBA3EDFCF349AAFFEC20921128D70FAC44110332201BB\" +\n            \"A3F10986140CBB97C726938060473C8EC97B4731DB004293\" +\n            \"B5E730363609DF9780F8D883D8C4D41DED6A2F1E1BBBDC97\" +\n            \"9E1B9D6D3C940301F4E978D65B19041FCF1E8B518F5C0576\" +\n            \"C770FE5A7A485D8329EE2914A2DE1B5DA4A6128CEAB70F79\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomBigInteger(\"349C55648DCF992F3F33E8026CFAC87C1D2BA075\", 16)));\n\n        byte[] msg = Hex.decode(\"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"636155AC9A4633B4665D179F9E4117DF68601F34\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"6C540B02D9D4852F89DF8CFC99963204F4347704\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void dsa2Test1()\n    {\n        byte[] seed = Hex.decode(\"ED8BEE8D1CB89229D2903CBF0E51EE7377F48698\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator();\n\n        pGen.init(new DSAParameterGenerationParameters(1024, 160, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 5)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"E950511EAB424B9A19A2AEB4E159B7844C589C4F\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"E0A67598CD1B763B\" +\n            \"C98C8ABB333E5DDA0CD3AA0E5E1FB5BA8A7B4EABC10BA338\" +\n            \"FAE06DD4B90FDA70D7CF0CB0C638BE3341BEC0AF8A7330A3\" +\n            \"307DED2299A0EE606DF035177A239C34A912C202AA5F83B9\" +\n            \"C4A7CF0235B5316BFC6EFB9A248411258B30B839AF172440\" +\n            \"F32563056CB67A861158DDD90E6A894C72A5BBEF9E286C6B\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"D29D5121B0423C27\" +\n            \"69AB21843E5A3240FF19CACC792264E3BB6BE4F78EDD1B15\" +\n            \"C4DFF7F1D905431F0AB16790E1F773B5CE01C804E509066A\" +\n            \"9919F5195F4ABC58189FD9FF987389CB5BEDF21B4DAB4F8B\" +\n            \"76A055FFE2770988FE2EC2DE11AD92219F0B351869AC24DA\" +\n            \"3D7BA87011A701CE8EE7BFE49486ED4527B7186CA4610A75\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomBigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"25282217F5730501\" +\n            \"DD8DBA3EDFCF349AAFFEC20921128D70FAC44110332201BB\" +\n            \"A3F10986140CBB97C726938060473C8EC97B4731DB004293\" +\n            \"B5E730363609DF9780F8D883D8C4D41DED6A2F1E1BBBDC97\" +\n            \"9E1B9D6D3C940301F4E978D65B19041FCF1E8B518F5C0576\" +\n            \"C770FE5A7A485D8329EE2914A2DE1B5DA4A6128CEAB70F79\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"D0EC4E50BB290A42E9E355C73D8809345DE2E139\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n            new FixedSecureRandom.Source[] {\n                new FixedSecureRandom.BigInteger(\"349C55648DCF992F3F33E8026CFAC87C1D2BA075\"),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\")) })));\n\n        byte[] msg = Hex.decode(\"A9993E364706816ABA3E25717850C26C9CD0D89D\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"636155AC9A4633B4665D179F9E4117DF68601F34\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"6C540B02D9D4852F89DF8CFC99963204F4347704\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void dsa2Test2()\n        {\n            byte[] seed = Hex.decode(\"5AFCC1EFFC079A9CCA6ECA86D6E3CC3B18642D9BE1CC6207C84002A9\");\n\n            DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA224Digest());\n\n            pGen.init(new DSAParameterGenerationParameters(2048, 224, 80, new DSATestSecureRandom(seed)));\n\n            DSAParameters params = pGen.generateParameters();\n\n            DSAValidationParameters pv = params.getValidationParameters();\n\n            if (pv.getCounter() != 21)\n            {\n                fail(\"counter incorrect\");\n            }\n\n            if (!Arrays.areEqual(seed, pv.getSeed()))\n            {\n                fail(\"seed incorrect\");\n            }\n\n            if (!params.getQ().equals(new BigInteger(\"90EAF4D1AF0708B1B612FF35E0A2997EB9E9D263C9CE659528945C0D\", 16)))\n            {\n                fail(\"Q incorrect\");\n            }\n\n            if (!params.getP().equals(new BigInteger(\n                \"C196BA05AC29E1F9C3C72D56DFFC6154\" +\n                \"A033F1477AC88EC37F09BE6C5BB95F51C296DD20D1A28A06\" +\n                \"7CCC4D4316A4BD1DCA55ED1066D438C35AEBAABF57E7DAE4\" +\n                \"28782A95ECA1C143DB701FD48533A3C18F0FE23557EA7AE6\" +\n                \"19ECACC7E0B51652A8776D02A425567DED36EABD90CA33A1\" +\n                \"E8D988F0BBB92D02D1D20290113BB562CE1FC856EEB7CDD9\" +\n                \"2D33EEA6F410859B179E7E789A8F75F645FAE2E136D252BF\" +\n                \"FAFF89528945C1ABE705A38DBC2D364AADE99BE0D0AAD82E\" +\n                \"5320121496DC65B3930E38047294FF877831A16D5228418D\" +\n                \"E8AB275D7D75651CEFED65F78AFC3EA7FE4D79B35F62A040\" +\n                \"2A1117599ADAC7B269A59F353CF450E6982D3B1702D9CA83\", 16)))\n            {\n                fail(\"P incorrect\");\n            }\n\n            if (!params.getG().equals(new BigInteger(\n                \"A59A749A11242C58C894E9E5A91804E8\"+\n                \"FA0AC64B56288F8D47D51B1EDC4D65444FECA0111D78F35F\"+\n                \"C9FDD4CB1F1B79A3BA9CBEE83A3F811012503C8117F98E50\"+\n                \"48B089E387AF6949BF8784EBD9EF45876F2E6A5A495BE64B\"+\n                \"6E770409494B7FEE1DBB1E4B2BC2A53D4F893D418B715959\"+\n                \"2E4FFFDF6969E91D770DAEBD0B5CB14C00AD68EC7DC1E574\"+\n                \"5EA55C706C4A1C5C88964E34D09DEB753AD418C1AD0F4FDF\"+\n                \"D049A955E5D78491C0B7A2F1575A008CCD727AB376DB6E69\"+\n                \"5515B05BD412F5B8C2F4C77EE10DA48ABD53F5DD498927EE\"+\n                \"7B692BBBCDA2FB23A516C5B4533D73980B2A3B60E384ED20\"+\n                \"0AE21B40D273651AD6060C13D97FD69AA13C5611A51B9085\", 16)))\n            {\n                fail(\"G incorrect\");\n            }\n\n            DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n            kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\")), params));\n\n            AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n            DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n            DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n            if (!pub.getY().equals(new BigInteger(\n                \"70035C9A3B225B258F16741F3941FBF0\" +\n                \"6F3D056CD7BD864604CBB5EE9DD85304EE8E8E4ABD5E9032\" +\n                \"11DDF25CE149075510ACE166970AFDC7DF552B7244F342FA\" +\n                \"02F7A621405B754909D757F97290E1FE5036E904CF593446\" +\n                \"0C046D95659821E1597ED9F2B1F0E20863A6BBD0CE74DACB\" +\n                \"A5D8C68A90B29C2157CDEDB82EC12B81EE3068F9BF5F7F34\" +\n                \"6ECA41ED174CCCD7D154FA4F42F80FFE1BF46AE9D8125DEB\" +\n                \"5B4BA08A72BDD86596DBEDDC9550FDD650C58F5AE5133509\" +\n                \"A702F79A31ECB490F7A3C5581631F7C5BE4FF7F9E9F27FA3\" +\n                \"90E47347AD1183509FED6FCF198BA9A71AB3335B4F38BE8D\" +\n                \"15496A00B6DC2263E20A5F6B662320A3A1EC033AA61E3B68\", 16)))\n            {\n                fail(\"Y value incorrect\");\n            }\n\n            if (!priv.getX().equals(\n                new BigInteger(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\", 16)))\n            {\n                fail(\"X value incorrect\");\n            }\n\n            DSASigner signer = new DSASigner();\n\n            signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"735959CC4463B8B440E407EECA8A473BF6A6D1FE657546F67D401F05\"))));\n\n            byte[] msg = Hex.decode(\"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n            BigInteger[] sig = signer.generateSignature(msg);\n\n            if (!sig[0].equals(new BigInteger(\"4400138D05F9639CAF54A583CAAF25D2B76D0C3EAD752CE17DBC85FE\", 16)))\n            {\n                fail(\"R value incorrect\");\n            }\n\n            if (!sig[1].equals(new BigInteger(\"874D4F12CB13B61732D398445698CFA9D92381D938AA57EE2C9327B3\", 16)))\n            {\n                fail(\"S value incorrect\");\n            }\n\n            signer.init(false, kp.getPublic());\n\n            if (!signer.verifySignature(msg, sig[0], sig[1]))\n            {\n                fail(\"signature not verified\");\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void dsa2Test2()\n        {\n            byte[] seed = Hex.decode(\"5AFCC1EFFC079A9CCA6ECA86D6E3CC3B18642D9BE1CC6207C84002A9\");\n\n            DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA224Digest());\n\n            pGen.init(new DSAParameterGenerationParameters(2048, 224, 80, new DSATestSecureRandom(seed)));\n\n            DSAParameters params = pGen.generateParameters();\n\n            DSAValidationParameters pv = params.getValidationParameters();\n\n            if (pv.getCounter() != 21)\n            {\n                fail(\"counter incorrect\");\n            }\n\n            if (!Arrays.areEqual(seed, pv.getSeed()))\n            {\n                fail(\"seed incorrect\");\n            }\n\n            if (!params.getQ().equals(new BigInteger(\"90EAF4D1AF0708B1B612FF35E0A2997EB9E9D263C9CE659528945C0D\", 16)))\n            {\n                fail(\"Q incorrect\");\n            }\n\n            if (!params.getP().equals(new BigInteger(\n                \"C196BA05AC29E1F9C3C72D56DFFC6154\" +\n                \"A033F1477AC88EC37F09BE6C5BB95F51C296DD20D1A28A06\" +\n                \"7CCC4D4316A4BD1DCA55ED1066D438C35AEBAABF57E7DAE4\" +\n                \"28782A95ECA1C143DB701FD48533A3C18F0FE23557EA7AE6\" +\n                \"19ECACC7E0B51652A8776D02A425567DED36EABD90CA33A1\" +\n                \"E8D988F0BBB92D02D1D20290113BB562CE1FC856EEB7CDD9\" +\n                \"2D33EEA6F410859B179E7E789A8F75F645FAE2E136D252BF\" +\n                \"FAFF89528945C1ABE705A38DBC2D364AADE99BE0D0AAD82E\" +\n                \"5320121496DC65B3930E38047294FF877831A16D5228418D\" +\n                \"E8AB275D7D75651CEFED65F78AFC3EA7FE4D79B35F62A040\" +\n                \"2A1117599ADAC7B269A59F353CF450E6982D3B1702D9CA83\", 16)))\n            {\n                fail(\"P incorrect\");\n            }\n\n            if (!params.getG().equals(new BigInteger(\n                \"A59A749A11242C58C894E9E5A91804E8\"+\n                \"FA0AC64B56288F8D47D51B1EDC4D65444FECA0111D78F35F\"+\n                \"C9FDD4CB1F1B79A3BA9CBEE83A3F811012503C8117F98E50\"+\n                \"48B089E387AF6949BF8784EBD9EF45876F2E6A5A495BE64B\"+\n                \"6E770409494B7FEE1DBB1E4B2BC2A53D4F893D418B715959\"+\n                \"2E4FFFDF6969E91D770DAEBD0B5CB14C00AD68EC7DC1E574\"+\n                \"5EA55C706C4A1C5C88964E34D09DEB753AD418C1AD0F4FDF\"+\n                \"D049A955E5D78491C0B7A2F1575A008CCD727AB376DB6E69\"+\n                \"5515B05BD412F5B8C2F4C77EE10DA48ABD53F5DD498927EE\"+\n                \"7B692BBBCDA2FB23A516C5B4533D73980B2A3B60E384ED20\"+\n                \"0AE21B40D273651AD6060C13D97FD69AA13C5611A51B9085\", 16)))\n            {\n                fail(\"G incorrect\");\n            }\n\n            DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n            kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\")), params));\n\n            AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n            DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n            DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n            if (!pub.getY().equals(new BigInteger(\n                \"70035C9A3B225B258F16741F3941FBF0\" +\n                \"6F3D056CD7BD864604CBB5EE9DD85304EE8E8E4ABD5E9032\" +\n                \"11DDF25CE149075510ACE166970AFDC7DF552B7244F342FA\" +\n                \"02F7A621405B754909D757F97290E1FE5036E904CF593446\" +\n                \"0C046D95659821E1597ED9F2B1F0E20863A6BBD0CE74DACB\" +\n                \"A5D8C68A90B29C2157CDEDB82EC12B81EE3068F9BF5F7F34\" +\n                \"6ECA41ED174CCCD7D154FA4F42F80FFE1BF46AE9D8125DEB\" +\n                \"5B4BA08A72BDD86596DBEDDC9550FDD650C58F5AE5133509\" +\n                \"A702F79A31ECB490F7A3C5581631F7C5BE4FF7F9E9F27FA3\" +\n                \"90E47347AD1183509FED6FCF198BA9A71AB3335B4F38BE8D\" +\n                \"15496A00B6DC2263E20A5F6B662320A3A1EC033AA61E3B68\", 16)))\n            {\n                fail(\"Y value incorrect\");\n            }\n\n            if (!priv.getX().equals(\n                new BigInteger(\"00D0F09ED3E2568F6CADF9224117DA2AEC5A4300E009DE1366023E17\", 16)))\n            {\n                fail(\"X value incorrect\");\n            }\n\n            DSASigner signer = new DSASigner();\n\n            signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n                new FixedSecureRandom.Source[] {\n                    new FixedSecureRandom.BigInteger(Hex.decode(\"735959CC4463B8B440E407EECA8A473BF6A6D1FE657546F67D401F05\")),\n                    new FixedSecureRandom.Data(Hex.decode(\"01020304\"))\n                })));\n\n            byte[] msg = Hex.decode(\"23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7\");\n\n            BigInteger[] sig = signer.generateSignature(msg);\n\n            if (!sig[0].equals(new BigInteger(\"4400138D05F9639CAF54A583CAAF25D2B76D0C3EAD752CE17DBC85FE\", 16)))\n            {\n                fail(\"R value incorrect\");\n            }\n\n            if (!sig[1].equals(new BigInteger(\"874D4F12CB13B61732D398445698CFA9D92381D938AA57EE2C9327B3\", 16)))\n            {\n                fail(\"S value incorrect\");\n            }\n\n            signer.init(false, kp.getPublic());\n\n            if (!signer.verifySignature(msg, sig[0], sig[1]))\n            {\n                fail(\"signature not verified\");\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void dsa2Test3()\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(2048, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 12)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\"))));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"315C875DCD4850E948B8AC42824E9483A32D5BA5ABE0681B9B9448D444F2BE3C\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"89718D12E54A8D9ED066E4A55F7ED5A2229CD23B9A3CEE78F83ED6AA61F6BCB9\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void dsa2Test3()\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(2048, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 12)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n            new FixedSecureRandom.Source[] {\n                new FixedSecureRandom.BigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")),\n                new FixedSecureRandom.Data(Hex.decode(\"01020304\"))\n            })));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"315C875DCD4850E948B8AC42824E9483A32D5BA5ABE0681B9B9448D444F2BE3C\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"89718D12E54A8D9ED066E4A55F7ED5A2229CD23B9A3CEE78F83ED6AA61F6BCB9\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void dsa2Test4()\n    {\n        byte[] seed = Hex.decode(\"193AFCA7C1E77B3C1ECC618C81322E47B8B8B997C9C83515C59CC446C2D9BD47\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(3072, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 20)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"CFA0478A54717B08CE64805B76E5B14249A77A4838469DF7F7DC987EFCCFB11D\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"90066455B5CFC38F9CAA4A48B4281F292C260FEEF01FD610\" +\n            \"37E56258A7795A1C7AD46076982CE6BB956936C6AB4DCFE0\" +\n            \"5E6784586940CA544B9B2140E1EB523F009D20A7E7880E4E\" +\n            \"5BFA690F1B9004A27811CD9904AF70420EEFD6EA11EF7DA1\" +\n            \"29F58835FF56B89FAA637BC9AC2EFAAB903402229F491D8D\" +\n            \"3485261CD068699B6BA58A1DDBBEF6DB51E8FE34E8A78E54\" +\n            \"2D7BA351C21EA8D8F1D29F5D5D15939487E27F4416B0CA63\" +\n            \"2C59EFD1B1EB66511A5A0FBF615B766C5862D0BD8A3FE7A0\" +\n            \"E0DA0FB2FE1FCB19E8F9996A8EA0FCCDE538175238FC8B0E\" +\n            \"E6F29AF7F642773EBE8CD5402415A01451A840476B2FCEB0\" +\n            \"E388D30D4B376C37FE401C2A2C2F941DAD179C540C1C8CE0\" +\n            \"30D460C4D983BE9AB0B20F69144C1AE13F9383EA1C08504F\" +\n            \"B0BF321503EFE43488310DD8DC77EC5B8349B8BFE97C2C56\" +\n            \"0EA878DE87C11E3D597F1FEA742D73EEC7F37BE43949EF1A\" +\n            \"0D15C3F3E3FC0A8335617055AC91328EC22B50FC15B941D3\" +\n            \"D1624CD88BC25F3E941FDDC6200689581BFEC416B4B2CB73\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"5E5CBA992E0A680D885EB903AEA78E4A45A469103D448EDE\" +\n            \"3B7ACCC54D521E37F84A4BDD5B06B0970CC2D2BBB715F7B8\" +\n            \"2846F9A0C393914C792E6A923E2117AB805276A975AADB52\" +\n            \"61D91673EA9AAFFEECBFA6183DFCB5D3B7332AA19275AFA1\" +\n            \"F8EC0B60FB6F66CC23AE4870791D5982AAD1AA9485FD8F4A\" +\n            \"60126FEB2CF05DB8A7F0F09B3397F3937F2E90B9E5B9C9B6\" +\n            \"EFEF642BC48351C46FB171B9BFA9EF17A961CE96C7E7A7CC\" +\n            \"3D3D03DFAD1078BA21DA425198F07D2481622BCE45969D9C\" +\n            \"4D6063D72AB7A0F08B2F49A7CC6AF335E08C4720E31476B6\" +\n            \"7299E231F8BD90B39AC3AE3BE0C6B6CACEF8289A2E2873D5\" +\n            \"8E51E029CAFBD55E6841489AB66B5B4B9BA6E2F784660896\" +\n            \"AFF387D92844CCB8B69475496DE19DA2E58259B090489AC8\" +\n            \"E62363CDF82CFD8EF2A427ABCD65750B506F56DDE3B98856\" +\n            \"7A88126B914D7828E2B63A6D7ED0747EC59E0E0A23CE7D8A\" +\n            \"74C1D2C2A7AFB6A29799620F00E11C33787F7DED3B30E1A2\" +\n            \"2D09F1FBDA1ABBBFBF25CAE05A13F812E34563F99410E73B\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"8B891C8692D3DE875879390F2698B26FBECCA6B075535DCE\" +\n            \"6B0C862577F9FA0DEF6074E7A7624121224A595896ABD4CD\" +\n            \"A56B2CEFB942E025D2A4282FFAA98A48CDB47E1A6FCB5CFB\" +\n            \"393EF35AF9DF913102BB303C2B5C36C3F8FC04ED7B8B69FE\" +\n            \"FE0CF3E1FC05CFA713B3435B2656E913BA8874AEA9F93600\" +\n            \"6AEB448BCD005D18EC3562A33D04CF25C8D3D69844343442\" +\n            \"FA3DB7DE618C5E2DA064573E61E6D5581BFB694A23AC87FD\" +\n            \"5B52D62E954E1376DB8DDB524FFC0D469DF978792EE44173\" +\n            \"8E5DB05A7DC43E94C11A2E7A4FBE383071FA36D2A7EC8A93\" +\n            \"88FE1C4F79888A99D3B6105697C2556B79BB4D7E781CEBB3\" +\n            \"D4866AD825A5E830846072289FDBC941FA679CA82F5F78B7\" +\n            \"461B2404DB883D215F4E0676CF5493950AC5591697BFEA8D\" +\n            \"1EE6EC016B89BA51CAFB5F9C84C989FA117375E94578F28B\" +\n            \"E0B34CE0545DA46266FD77F62D8F2CEE92AB77012AFEBC11\" +\n            \"008985A821CD2D978C7E6FE7499D1AAF8DE632C21BB48CA5\" +\n            \"CBF9F31098FD3FD3854C49A65D9201744AACE540354974F9\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new TestRandomData(Hex.decode(\"A6902C1E6E3943C5628061588A8B007BCCEA91DBF12915483F04B24AB0678BEE\"))));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"5F184E645A38BE8FB4A6871B6503A9D12924C7ABE04B71410066C2ECA6E3BE3E\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"91EB0C7BA3D4B9B60B825C3D9F2CADA8A2C9D7723267B033CBCDCF8803DB9C18\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void dsa2Test4()\n    {\n        byte[] seed = Hex.decode(\"193AFCA7C1E77B3C1ECC618C81322E47B8B8B997C9C83515C59CC446C2D9BD47\");\n\n        DSAParametersGenerator pGen = new DSAParametersGenerator(new SHA256Digest());\n\n        pGen.init(new DSAParameterGenerationParameters(3072, 256, 80, new DSATestSecureRandom(seed)));\n\n        DSAParameters params = pGen.generateParameters();\n\n        DSAValidationParameters pv = params.getValidationParameters();\n\n        if (pv.getCounter() != 20)\n        {\n            fail(\"counter incorrect\");\n        }\n\n        if (!Arrays.areEqual(seed, pv.getSeed()))\n        {\n            fail(\"seed incorrect\");\n        }\n\n        if (!params.getQ().equals(new BigInteger(\"CFA0478A54717B08CE64805B76E5B14249A77A4838469DF7F7DC987EFCCFB11D\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!params.getP().equals(new BigInteger(\n            \"90066455B5CFC38F9CAA4A48B4281F292C260FEEF01FD610\" +\n            \"37E56258A7795A1C7AD46076982CE6BB956936C6AB4DCFE0\" +\n            \"5E6784586940CA544B9B2140E1EB523F009D20A7E7880E4E\" +\n            \"5BFA690F1B9004A27811CD9904AF70420EEFD6EA11EF7DA1\" +\n            \"29F58835FF56B89FAA637BC9AC2EFAAB903402229F491D8D\" +\n            \"3485261CD068699B6BA58A1DDBBEF6DB51E8FE34E8A78E54\" +\n            \"2D7BA351C21EA8D8F1D29F5D5D15939487E27F4416B0CA63\" +\n            \"2C59EFD1B1EB66511A5A0FBF615B766C5862D0BD8A3FE7A0\" +\n            \"E0DA0FB2FE1FCB19E8F9996A8EA0FCCDE538175238FC8B0E\" +\n            \"E6F29AF7F642773EBE8CD5402415A01451A840476B2FCEB0\" +\n            \"E388D30D4B376C37FE401C2A2C2F941DAD179C540C1C8CE0\" +\n            \"30D460C4D983BE9AB0B20F69144C1AE13F9383EA1C08504F\" +\n            \"B0BF321503EFE43488310DD8DC77EC5B8349B8BFE97C2C56\" +\n            \"0EA878DE87C11E3D597F1FEA742D73EEC7F37BE43949EF1A\" +\n            \"0D15C3F3E3FC0A8335617055AC91328EC22B50FC15B941D3\" +\n            \"D1624CD88BC25F3E941FDDC6200689581BFEC416B4B2CB73\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!params.getG().equals(new BigInteger(\n            \"5E5CBA992E0A680D885EB903AEA78E4A45A469103D448EDE\" +\n            \"3B7ACCC54D521E37F84A4BDD5B06B0970CC2D2BBB715F7B8\" +\n            \"2846F9A0C393914C792E6A923E2117AB805276A975AADB52\" +\n            \"61D91673EA9AAFFEECBFA6183DFCB5D3B7332AA19275AFA1\" +\n            \"F8EC0B60FB6F66CC23AE4870791D5982AAD1AA9485FD8F4A\" +\n            \"60126FEB2CF05DB8A7F0F09B3397F3937F2E90B9E5B9C9B6\" +\n            \"EFEF642BC48351C46FB171B9BFA9EF17A961CE96C7E7A7CC\" +\n            \"3D3D03DFAD1078BA21DA425198F07D2481622BCE45969D9C\" +\n            \"4D6063D72AB7A0F08B2F49A7CC6AF335E08C4720E31476B6\" +\n            \"7299E231F8BD90B39AC3AE3BE0C6B6CACEF8289A2E2873D5\" +\n            \"8E51E029CAFBD55E6841489AB66B5B4B9BA6E2F784660896\" +\n            \"AFF387D92844CCB8B69475496DE19DA2E58259B090489AC8\" +\n            \"E62363CDF82CFD8EF2A427ABCD65750B506F56DDE3B98856\" +\n            \"7A88126B914D7828E2B63A6D7ED0747EC59E0E0A23CE7D8A\" +\n            \"74C1D2C2A7AFB6A29799620F00E11C33787F7DED3B30E1A2\" +\n            \"2D09F1FBDA1ABBBFBF25CAE05A13F812E34563F99410E73B\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        DSAKeyPairGenerator kpGen = new DSAKeyPairGenerator();\n\n        kpGen.init(new DSAKeyGenerationParameters(new TestRandomData(Hex.decode(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\")), params));\n\n        AsymmetricCipherKeyPair kp = kpGen.generateKeyPair();\n\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)kp.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)kp.getPrivate();\n\n        if (!pub.getY().equals(new BigInteger(\n            \"8B891C8692D3DE875879390F2698B26FBECCA6B075535DCE\" +\n            \"6B0C862577F9FA0DEF6074E7A7624121224A595896ABD4CD\" +\n            \"A56B2CEFB942E025D2A4282FFAA98A48CDB47E1A6FCB5CFB\" +\n            \"393EF35AF9DF913102BB303C2B5C36C3F8FC04ED7B8B69FE\" +\n            \"FE0CF3E1FC05CFA713B3435B2656E913BA8874AEA9F93600\" +\n            \"6AEB448BCD005D18EC3562A33D04CF25C8D3D69844343442\" +\n            \"FA3DB7DE618C5E2DA064573E61E6D5581BFB694A23AC87FD\" +\n            \"5B52D62E954E1376DB8DDB524FFC0D469DF978792EE44173\" +\n            \"8E5DB05A7DC43E94C11A2E7A4FBE383071FA36D2A7EC8A93\" +\n            \"88FE1C4F79888A99D3B6105697C2556B79BB4D7E781CEBB3\" +\n            \"D4866AD825A5E830846072289FDBC941FA679CA82F5F78B7\" +\n            \"461B2404DB883D215F4E0676CF5493950AC5591697BFEA8D\" +\n            \"1EE6EC016B89BA51CAFB5F9C84C989FA117375E94578F28B\" +\n            \"E0B34CE0545DA46266FD77F62D8F2CEE92AB77012AFEBC11\" +\n            \"008985A821CD2D978C7E6FE7499D1AAF8DE632C21BB48CA5\" +\n            \"CBF9F31098FD3FD3854C49A65D9201744AACE540354974F9\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!priv.getX().equals(\n            new BigInteger(\"3ABC1587297CE7B9EA1AD6651CF2BC4D7F92ED25CABC8553F567D1B40EBB8764\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        DSASigner signer = new DSASigner();\n\n        signer.init(true, new ParametersWithRandom(kp.getPrivate(), new FixedSecureRandom(\n            new FixedSecureRandom.Source[]\n                { new FixedSecureRandom.BigInteger(\"A6902C1E6E3943C5628061588A8B007BCCEA91DBF12915483F04B24AB0678BEE\"),\n                  new FixedSecureRandom.Data(Hex.decode(\"01020304\")) })));\n\n        byte[] msg = Hex.decode(\"BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD\");\n\n        BigInteger[] sig = signer.generateSignature(msg);\n\n        if (!sig[0].equals(new BigInteger(\"5F184E645A38BE8FB4A6871B6503A9D12924C7ABE04B71410066C2ECA6E3BE3E\", 16)))\n        {\n            fail(\"R value incorrect\");\n        }\n\n        if (!sig[1].equals(new BigInteger(\"91EB0C7BA3D4B9B60B825C3D9F2CADA8A2C9D7723267B033CBCDCF8803DB9C18\", 16)))\n        {\n            fail(\"S value incorrect\");\n        }\n\n        signer.init(false, kp.getPublic());\n\n        if (!signer.verifySignature(msg, sig[0], sig[1]))\n        {\n            fail(\"signature not verified\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 5, j = 12;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = zz[zzOff + 5] & M;\n        long zz_6 = zz[zzOff + 6] & M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = zz[zzOff + 7] & M;\n        long zz_8 = zz[zzOff + 8] & M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[xOff + 5] & M;\n        long zz_9 = zz[zzOff + 9] & M;\n        long zz_10 = zz[zzOff + 10] & M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[zzOff + 5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_10 += zz_9 >>> 32;\n        }\n\n        w = (int)zz_6;\n        zz[zzOff + 6] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_7;\n        zz[zzOff + 7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[zzOff + 9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[zzOff + 10] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 11] + (int)(zz_10 >> 32);\n        zz[zzOff + 11] = (w << 1) | c;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 5, j = 12;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = (zz[zzOff + 5] & M) + (zz_4 >>> 32); zz_4 &= M;\n        long zz_6 = (zz[zzOff + 6] & M) + (zz_5 >>> 32); zz_5 &= M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = (zz[zzOff + 7] & M) + (zz_6 >>> 32); zz_6 &= M;\n        long zz_8 = (zz[zzOff + 8] & M) + (zz_7 >>> 32); zz_7 &= M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[xOff + 5] & M;\n        long zz_9 = (zz[zzOff + 9] & M) + (zz_8 >>> 32); zz_8 &= M;\n        long zz_10 = (zz[zzOff + 10] & M) + (zz_9 >>> 32); zz_9 &= M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[zzOff + 5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_10 += zz_9 >>> 32;\n        }\n\n        w = (int)zz_6;\n        zz[zzOff + 6] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_7;\n        zz[zzOff + 7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[zzOff + 9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[zzOff + 10] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 11] + (int)(zz_10 >>> 32);\n        zz[zzOff + 11] = (w << 1) | c;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 7, j = 16;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = zz[zzOff + 5] & M;\n        long zz_6 = zz[zzOff + 6] & M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = zz[zzOff + 7] & M;\n        long zz_8 = zz[zzOff + 8] & M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[xOff + 5] & M;\n        long zz_9 = zz[zzOff + 9] & M;\n        long zz_10 = zz[zzOff + 10] & M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[zzOff + 5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_6 &= M;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_8 &= M;\n            zz_10 += zz_9 >>> 32;\n            zz_9 &= M;\n        }\n\n        long x_6 = x[xOff + 6] & M;\n        long zz_11 = zz[zzOff + 11] & M;\n        long zz_12 = zz[zzOff + 12] & M;\n        {\n            zz_6 += x_6 * x_0;\n            w = (int)zz_6;\n            zz[zzOff + 6] = (w << 1) | c;\n            c = w >>> 31;\n            zz_7 += (zz_6 >>> 32) + x_6 * x_1;\n            zz_8 += (zz_7 >>> 32) + x_6 * x_2;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_6 * x_3;\n            zz_8 &= M;\n            zz_10 += (zz_9 >>> 32) + x_6 * x_4;\n            zz_9 &= M;\n            zz_11 += (zz_10 >>> 32) + x_6 * x_5;\n            zz_10 &= M;\n            zz_12 += zz_11 >>> 32;\n            zz_11 &= M;\n        }\n\n        long x_7 = x[xOff + 7] & M;\n        long zz_13 = zz[zzOff + 13] & M;\n        long zz_14 = zz[zzOff + 14] & M;\n        {\n            zz_7 += x_7 * x_0;\n            w = (int)zz_7;\n            zz[zzOff + 7] = (w << 1) | c;\n            c = w >>> 31;\n            zz_8 += (zz_7 >>> 32) + x_7 * x_1;\n            zz_9 += (zz_8 >>> 32) + x_7 * x_2;\n            zz_10 += (zz_9 >>> 32) + x_7 * x_3;\n            zz_11 += (zz_10 >>> 32) + x_7 * x_4;\n            zz_12 += (zz_11 >>> 32) + x_7 * x_5;\n            zz_13 += (zz_12 >>> 32) + x_7 * x_6;\n            zz_14 += zz_13 >>> 32;\n        }\n\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[zzOff + 9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[zzOff + 10] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_11;\n        zz[zzOff + 11] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_12;\n        zz[zzOff + 12] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_13;\n        zz[zzOff + 13] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_14;\n        zz[zzOff + 14] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 15] + (int)(zz_14 >> 32);\n        zz[zzOff + 15] = (w << 1) | c;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 7, j = 16;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = (zz[zzOff + 5] & M) + (zz_4 >>> 32); zz_4 &= M;\n        long zz_6 = (zz[zzOff + 6] & M) + (zz_5 >>> 32); zz_5 &= M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = (zz[zzOff + 7] & M) + (zz_6 >>> 32); zz_6 &= M;\n        long zz_8 = (zz[zzOff + 8] & M) + (zz_7 >>> 32); zz_7 &= M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[xOff + 5] & M;\n        long zz_9 = (zz[zzOff + 9] & M) + (zz_8 >>> 32); zz_8 &= M;\n        long zz_10 = (zz[zzOff + 10] & M) + (zz_9 >>> 32); zz_9 &= M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[zzOff + 5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_6 &= M;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_8 &= M;\n            zz_10 += zz_9 >>> 32;\n            zz_9 &= M;\n        }\n\n        long x_6 = x[xOff + 6] & M;\n        long zz_11 = (zz[zzOff + 11] & M) + (zz_10 >>> 32); zz_10 &= M;\n        long zz_12 = (zz[zzOff + 12] & M) + (zz_11 >>> 32); zz_11 &= M;\n        {\n            zz_6 += x_6 * x_0;\n            w = (int)zz_6;\n            zz[zzOff + 6] = (w << 1) | c;\n            c = w >>> 31;\n            zz_7 += (zz_6 >>> 32) + x_6 * x_1;\n            zz_8 += (zz_7 >>> 32) + x_6 * x_2;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_6 * x_3;\n            zz_8 &= M;\n            zz_10 += (zz_9 >>> 32) + x_6 * x_4;\n            zz_9 &= M;\n            zz_11 += (zz_10 >>> 32) + x_6 * x_5;\n            zz_10 &= M;\n            zz_12 += zz_11 >>> 32;\n            zz_11 &= M;\n        }\n\n        long x_7 = x[xOff + 7] & M;\n        long zz_13 = (zz[zzOff + 13] & M) + (zz_12 >>> 32); zz_12 &= M;\n        long zz_14 = (zz[zzOff + 14] & M) + (zz_13 >>> 32); zz_13 &= M;\n        {\n            zz_7 += x_7 * x_0;\n            w = (int)zz_7;\n            zz[zzOff + 7] = (w << 1) | c;\n            c = w >>> 31;\n            zz_8 += (zz_7 >>> 32) + x_7 * x_1;\n            zz_9 += (zz_8 >>> 32) + x_7 * x_2;\n            zz_10 += (zz_9 >>> 32) + x_7 * x_3;\n            zz_11 += (zz_10 >>> 32) + x_7 * x_4;\n            zz_12 += (zz_11 >>> 32) + x_7 * x_5;\n            zz_13 += (zz_12 >>> 32) + x_7 * x_6;\n            zz_14 += zz_13 >>> 32;\n        }\n\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[zzOff + 9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[zzOff + 10] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_11;\n        zz[zzOff + 11] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_12;\n        zz[zzOff + 12] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_13;\n        zz[zzOff + 13] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_14;\n        zz[zzOff + 14] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 15] + (int)(zz_14 >>> 32);\n        zz[zzOff + 15] = (w << 1) | c;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 4, j = 10;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = zz[zzOff + 5] & M;\n        long zz_6 = zz[zzOff + 6] & M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = zz[zzOff + 7] & M;\n        long zz_8 = zz[zzOff + 8] & M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_8 += zz_7 >>> 32;\n        }\n\n        w = (int)zz_5;\n        zz[zzOff + 5] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_6;\n        zz[zzOff + 6] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_7;\n        zz[zzOff + 7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 9] + (int)(zz_8 >> 32);\n        zz[zzOff + 9] = (w << 1) | c;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 4, j = 10;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = (zz[zzOff + 5] & M) + (zz_4 >>> 32); zz_4 &= M;\n        long zz_6 = (zz[zzOff + 6] & M) + (zz_5 >>> 32); zz_5 &= M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = (zz[zzOff + 7] & M) + (zz_6 >>> 32); zz_6 &= M;\n        long zz_8 = (zz[zzOff + 8] & M) + (zz_7 >>> 32); zz_7 &= M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_8 += zz_7 >>> 32;\n        }\n\n        w = (int)zz_5;\n        zz[zzOff + 5] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_6;\n        zz[zzOff + 6] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_7;\n        zz[zzOff + 7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 9] + (int)(zz_8 >>> 32);\n        zz[zzOff + 9] = (w << 1) | c;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 3, j = 8;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = zz[zzOff + 5] & M;\n        long zz_6 = zz[zzOff + 6] & M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_6 += zz_5 >>> 32;\n        }\n\n        w = (int)zz_4;\n        zz[zzOff + 4] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_5;\n        zz[zzOff + 5] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_6;\n        zz[zzOff + 6] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 7] + (int)(zz_6 >> 32);\n        zz[zzOff + 7] = (w << 1) | c;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 3, j = 8;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = (zz[zzOff + 5] & M) + (zz_4 >>> 32); zz_4 &= M;\n        long zz_6 = (zz[zzOff + 6] & M) + (zz_5 >>> 32); zz_5 &= M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_6 += zz_5 >>> 32;\n        }\n\n        w = (int)zz_4;\n        zz[zzOff + 4] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_5;\n        zz[zzOff + 5] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_6;\n        zz[zzOff + 6] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 7] + (int)(zz_6 >>> 32);\n        zz[zzOff + 7] = (w << 1) | c;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 6, j = 14;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = zz[zzOff + 5] & M;\n        long zz_6 = zz[zzOff + 6] & M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = zz[zzOff + 7] & M;\n        long zz_8 = zz[zzOff + 8] & M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[xOff + 5] & M;\n        long zz_9 = zz[zzOff + 9] & M;\n        long zz_10 = zz[zzOff + 10] & M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[zzOff + 5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_6 &= M;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_8 &= M;\n            zz_10 += zz_9 >>> 32;\n            zz_9 &= M;\n        }\n\n        long x_6 = x[xOff + 6] & M;\n        long zz_11 = zz[zzOff + 11] & M;\n        long zz_12 = zz[zzOff + 12] & M;\n        {\n            zz_6 += x_6 * x_0;\n            w = (int)zz_6;\n            zz[zzOff + 6] = (w << 1) | c;\n            c = w >>> 31;\n            zz_7 += (zz_6 >>> 32) + x_6 * x_1;\n            zz_8 += (zz_7 >>> 32) + x_6 * x_2;\n            zz_9 += (zz_8 >>> 32) + x_6 * x_3;\n            zz_10 += (zz_9 >>> 32) + x_6 * x_4;\n            zz_11 += (zz_10 >>> 32) + x_6 * x_5;\n            zz_12 += zz_11 >>> 32;\n        }\n\n        w = (int)zz_7;\n        zz[zzOff + 7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[zzOff + 9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[zzOff + 10] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_11;\n        zz[zzOff + 11] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_12;\n        zz[zzOff + 12] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 13] + (int)(zz_12 >> 32);\n        zz[zzOff + 13] = (w << 1) | c;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void square(int[] x, int xOff, int[] zz, int zzOff)\n    {\n        long x_0 = x[xOff + 0] & M;\n        long zz_1;\n\n        int c = 0, w;\n        {\n            int i = 6, j = 14;\n            do\n            {\n                long xVal = (x[xOff + i--] & M);\n                long p = xVal * xVal;\n                zz[zzOff + --j] = (c << 31) | (int)(p >>> 33);\n                zz[zzOff + --j] = (int)(p >>> 1);\n                c = (int)p;\n            }\n            while (i > 0);\n\n            {\n                long p = x_0 * x_0;\n                zz_1 = ((c << 31) & M) | (p >>> 33);\n                zz[zzOff + 0] = (int)p;\n                c = (int)(p >>> 32) & 1;\n            }\n        }\n\n        long x_1 = x[xOff + 1] & M;\n        long zz_2 = zz[zzOff + 2] & M;\n\n        {\n            zz_1 += x_1 * x_0;\n            w = (int)zz_1;\n            zz[zzOff + 1] = (w << 1) | c;\n            c = w >>> 31;\n            zz_2 += zz_1 >>> 32;\n        }\n\n        long x_2 = x[xOff + 2] & M;\n        long zz_3 = zz[zzOff + 3] & M;\n        long zz_4 = zz[zzOff + 4] & M;\n        {\n            zz_2 += x_2 * x_0;\n            w = (int)zz_2;\n            zz[zzOff + 2] = (w << 1) | c;\n            c = w >>> 31;\n            zz_3 += (zz_2 >>> 32) + x_2 * x_1;\n            zz_4 += zz_3 >>> 32;\n            zz_3 &= M;\n        }\n\n        long x_3 = x[xOff + 3] & M;\n        long zz_5 = (zz[zzOff + 5] & M) + (zz_4 >>> 32); zz_4 &= M;\n        long zz_6 = (zz[zzOff + 6] & M) + (zz_5 >>> 32); zz_5 &= M;\n        {\n            zz_3 += x_3 * x_0;\n            w = (int)zz_3;\n            zz[zzOff + 3] = (w << 1) | c;\n            c = w >>> 31;\n            zz_4 += (zz_3 >>> 32) + x_3 * x_1;\n            zz_5 += (zz_4 >>> 32) + x_3 * x_2;\n            zz_4 &= M;\n            zz_6 += zz_5 >>> 32;\n            zz_5 &= M;\n        }\n\n        long x_4 = x[xOff + 4] & M;\n        long zz_7 = (zz[zzOff + 7] & M) + (zz_6 >>> 32); zz_6 &= M;\n        long zz_8 = (zz[zzOff + 8] & M) + (zz_7 >>> 32); zz_7 &= M;\n        {\n            zz_4 += x_4 * x_0;\n            w = (int)zz_4;\n            zz[zzOff + 4] = (w << 1) | c;\n            c = w >>> 31;\n            zz_5 += (zz_4 >>> 32) + x_4 * x_1;\n            zz_6 += (zz_5 >>> 32) + x_4 * x_2;\n            zz_5 &= M;\n            zz_7 += (zz_6 >>> 32) + x_4 * x_3;\n            zz_6 &= M;\n            zz_8 += zz_7 >>> 32;\n            zz_7 &= M;\n        }\n\n        long x_5 = x[xOff + 5] & M;\n        long zz_9 = (zz[zzOff + 9] & M) + (zz_8 >>> 32); zz_8 &= M;\n        long zz_10 = (zz[zzOff + 10] & M) + (zz_9 >>> 32); zz_9 &= M;\n        {\n            zz_5 += x_5 * x_0;\n            w = (int)zz_5;\n            zz[zzOff + 5] = (w << 1) | c;\n            c = w >>> 31;\n            zz_6 += (zz_5 >>> 32) + x_5 * x_1;\n            zz_7 += (zz_6 >>> 32) + x_5 * x_2;\n            zz_6 &= M;\n            zz_8 += (zz_7 >>> 32) + x_5 * x_3;\n            zz_7 &= M;\n            zz_9 += (zz_8 >>> 32) + x_5 * x_4;\n            zz_8 &= M;\n            zz_10 += zz_9 >>> 32;\n            zz_9 &= M;\n        }\n\n        long x_6 = x[xOff + 6] & M;\n        long zz_11 = (zz[zzOff + 11] & M) + (zz_10 >>> 32); zz_10 &= M;\n        long zz_12 = (zz[zzOff + 12] & M) + (zz_11 >>> 32); zz_11 &= M;\n        {\n            zz_6 += x_6 * x_0;\n            w = (int)zz_6;\n            zz[zzOff + 6] = (w << 1) | c;\n            c = w >>> 31;\n            zz_7 += (zz_6 >>> 32) + x_6 * x_1;\n            zz_8 += (zz_7 >>> 32) + x_6 * x_2;\n            zz_9 += (zz_8 >>> 32) + x_6 * x_3;\n            zz_10 += (zz_9 >>> 32) + x_6 * x_4;\n            zz_11 += (zz_10 >>> 32) + x_6 * x_5;\n            zz_12 += zz_11 >>> 32;\n        }\n\n        w = (int)zz_7;\n        zz[zzOff + 7] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_8;\n        zz[zzOff + 8] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_9;\n        zz[zzOff + 9] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_10;\n        zz[zzOff + 10] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_11;\n        zz[zzOff + 11] = (w << 1) | c;\n        c = w >>> 31;\n        w = (int)zz_12;\n        zz[zzOff + 12] = (w << 1) | c;\n        c = w >>> 31;\n        w = zz[zzOff + 13] + (int)(zz_12 >>> 32);\n        zz[zzOff + 13] = (w << 1) | c;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void reset(\n        boolean clearMac)\n    {\n        cipher.reset();\n\n        S = new byte[BLOCK_SIZE];\n        S_at = new byte[BLOCK_SIZE];\n        S_atPre = new byte[BLOCK_SIZE];\n        atBlock = new byte[BLOCK_SIZE];\n        atBlockPos = 0;\n        atLength = 0;\n        atLengthPre = 0;\n        counter = Arrays.clone(J0);\n        blocksRemaining = -2;\n        bufOff = 0;\n        totalLength = 0;\n\n        if (bufBlock != null)\n        {\n            Arrays.fill(bufBlock, (byte)0);\n        }\n\n        if (clearMac)\n        {\n            macBlock = null;\n        }\n\n        if (initialAssociatedText != null)\n        {\n            processAADBytes(initialAssociatedText, 0, initialAssociatedText.length);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void reset(\n        boolean clearMac)\n    {\n        cipher.reset();\n\n        S = new byte[BLOCK_SIZE];\n        S_at = new byte[BLOCK_SIZE];\n        S_atPre = new byte[BLOCK_SIZE];\n        atBlock = new byte[BLOCK_SIZE];\n        atBlockPos = 0;\n        atLength = 0;\n        atLengthPre = 0;\n        counter = Arrays.clone(J0);\n        blocksRemaining = -1;\n        bufOff = 0;\n        totalLength = 0;\n\n        if (bufBlock != null)\n        {\n            Arrays.fill(bufBlock, (byte)0);\n        }\n\n        if (clearMac)\n        {\n            macBlock = null;\n        }\n\n        if (initialAssociatedText != null)\n        {\n            processAADBytes(initialAssociatedText, 0, initialAssociatedText.length);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n    {\n        int iterations = getNumberOfIterations(bitlength, param.getCertainty());\n\n        for (int i = 0; i != 5 * bitlength; i++)\n        {\n            BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n\n            if (p.mod(e).equals(ONE))\n            {\n                continue;\n            }\n\n            if (p.multiply(p).compareTo(sqrdBound) < 0)\n            {\n                continue;\n            }\n\n            if (!isProbablePrime(p, iterations))\n            {\n                continue;\n            }\n\n            if (!e.gcd(p.subtract(ONE)).equals(ONE))\n            {\n                continue;\n            }\n\n            return p;\n        }\n\n        throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected BigInteger chooseRandomPrime(int bitlength, BigInteger e, BigInteger sqrdBound)\n    {\n        for (int i = 0; i != 5 * bitlength; i++)\n        {\n            BigInteger p = new BigInteger(bitlength, 1, param.getRandom());\n\n            if (p.mod(e).equals(ONE))\n            {\n                continue;\n            }\n\n            if (p.multiply(p).compareTo(sqrdBound) < 0)\n            {\n                continue;\n            }\n\n            if (!isProbablePrime(p))\n            {\n                continue;\n            }\n\n            if (!e.gcd(p.subtract(ONE)).equals(ONE))\n            {\n                continue;\n            }\n\n            return p;\n        }\n\n        throw new IllegalStateException(\"unable to generate prime number for RSA key\");\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected boolean isProbablePrime(BigInteger x, int iterations)\n    {\n        /*\n         * Primes class for FIPS 186-4 C.3 primality checking\n         */\n        return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected boolean isProbablePrime(BigInteger x)\n    {\n        int iterations = getNumberOfIterations(x.bitLength(), param.getCertainty());\n\n        /*\n         * Primes class for FIPS 186-4 C.3 primality checking\n         */\n        return !Primes.hasAnySmallFactors(x) && Primes.isMRProbablePrime(x, param.getRandom(), iterations);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public BigInteger[] generateSignature(\n        byte[] message)\n    {\n        DSAParameters   params = key.getParameters();\n        BigInteger      q = params.getQ();\n        BigInteger      m = calculateE(q, message);\n        BigInteger      x = ((DSAPrivateKeyParameters)key).getX();\n\n        if (kCalculator.isDeterministic())\n        {\n            kCalculator.init(q, x, message);\n        }\n        else\n        {\n            kCalculator.init(q, random);\n        }\n\n        BigInteger  k = kCalculator.nextK();\n\n        BigInteger  r = params.getG().modPow(k, params.getP()).mod(q);\n\n        k = k.modInverse(q).multiply(m.add(x.multiply(r)));\n\n        BigInteger  s = k.mod(q);\n\n        return new BigInteger[]{ r, s };\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public BigInteger[] generateSignature(\n        byte[] message)\n    {\n        DSAParameters   params = key.getParameters();\n        BigInteger      q = params.getQ();\n        BigInteger      m = calculateE(q, message);\n        BigInteger      x = ((DSAPrivateKeyParameters)key).getX();\n\n        if (kCalculator.isDeterministic())\n        {\n            kCalculator.init(q, x, message);\n        }\n        else\n        {\n            kCalculator.init(q, random);\n        }\n\n        BigInteger  k = kCalculator.nextK();\n\n        // the randomizer is to conceal timing information related to k and x.\n        BigInteger  r = params.getG().modPow(k.add(getRandomizer(q, random)), params.getP()).mod(q);\n\n        k = k.modInverse(q).multiply(m.add(x.multiply(r)));\n\n        BigInteger  s = k.mod(q);\n\n        return new BigInteger[]{ r, s };\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ASN1Enumerated(\n        byte[]   bytes)\n    {\n        this.bytes = Arrays.clone(bytes);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ASN1Enumerated(\n        byte[]   bytes)\n    {\n        if (bytes.length > 1)\n        {\n            if (bytes[0] == 0 && (bytes[1] & 0x80) == 0)\n            {\n                throw new IllegalArgumentException(\"malformed enumerated\");\n            }\n            if (bytes[0] == (byte)0xff && (bytes[1] & 0x80) != 0)\n            {\n                throw new IllegalArgumentException(\"malformed enumerated\");\n            }\n        }\n        this.bytes = Arrays.clone(bytes);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "GF2Polynomial[] invertMatrix(GF2Polynomial[] matrix)\n    {\n        GF2Polynomial[] a = new GF2Polynomial[matrix.length];\n        GF2Polynomial[] inv = new GF2Polynomial[matrix.length];\n        GF2Polynomial dummy;\n        int i, j;\n        // initialize a as a copy of matrix and inv as E(inheitsmatrix)\n        for (i = 0; i < mDegree; i++)\n        {\n            try\n            {\n                a[i] = new GF2Polynomial(matrix[i]);\n                inv[i] = new GF2Polynomial(mDegree);\n                inv[i].setBit(mDegree - 1 - i);\n            }\n            catch (RuntimeException BDNEExc)\n            {\n                BDNEExc.printStackTrace();\n            }\n        }\n        // construct triangle matrix so that for each a[i] the first i bits are\n        // zero\n        for (i = 0; i < mDegree - 1; i++)\n        {\n            // find column where bit i is set\n            j = i;\n            while ((j < mDegree) && !a[j].testBit(mDegree - 1 - i))\n            {\n                j++;\n            }\n            if (j >= mDegree)\n            {\n                throw new RuntimeException(\n                    \"GF2nField.invertMatrix: Matrix cannot be inverted!\");\n            }\n            if (i != j)\n            { // swap a[i]/a[j] and inv[i]/inv[j]\n                dummy = a[i];\n                a[i] = a[j];\n                a[j] = dummy;\n                dummy = inv[i];\n                inv[i] = inv[j];\n                inv[j] = dummy;\n            }\n            for (j = i + 1; j < mDegree; j++)\n            { // add column i to all columns>i\n                // having their i-th bit set\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        // construct Einheitsmatrix from a\n        for (i = mDegree - 1; i > 0; i--)\n        {\n            for (j = i - 1; j >= 0; j--)\n            { // eliminate the i-th bit in all\n                // columns < i\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        return inv;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "GF2Polynomial[] invertMatrix(GF2Polynomial[] matrix)\n    {\n        GF2Polynomial[] a = new GF2Polynomial[matrix.length];\n        GF2Polynomial[] inv = new GF2Polynomial[matrix.length];\n        GF2Polynomial dummy;\n        int i, j;\n        // initialize a as a copy of matrix and inv as E(inheitsmatrix)\n        for (i = 0; i < mDegree; i++)\n        {\n            a[i] = new GF2Polynomial(matrix[i]);\n            inv[i] = new GF2Polynomial(mDegree);\n            inv[i].setBit(mDegree - 1 - i);\n        }\n        // construct triangle matrix so that for each a[i] the first i bits are\n        // zero\n        for (i = 0; i < mDegree - 1; i++)\n        {\n            // find column where bit i is set\n            j = i;\n            while ((j < mDegree) && !a[j].testBit(mDegree - 1 - i))\n            {\n                j++;\n            }\n            if (j >= mDegree)\n            {\n                throw new RuntimeException(\n                    \"GF2nField.invertMatrix: Matrix cannot be inverted!\");\n            }\n            if (i != j)\n            { // swap a[i]/a[j] and inv[i]/inv[j]\n                dummy = a[i];\n                a[i] = a[j];\n                a[j] = dummy;\n                dummy = inv[i];\n                inv[i] = inv[j];\n                inv[j] = dummy;\n            }\n            for (j = i + 1; j < mDegree; j++)\n            { // add column i to all columns>i\n                // having their i-th bit set\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        // construct Einheitsmatrix from a\n        for (i = mDegree - 1; i > 0; i--)\n        {\n            for (j = i - 1; j >= 0; j--)\n            { // eliminate the i-th bit in all\n                // columns < i\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        return inv;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private AsymmetricCipherKeyPair genKeyPair()\n    {\n        if (!initialized)\n        {\n            initializeDefault();\n        }\n\n        // initialize authenticationPaths and treehash instances\n        byte[][][] currentAuthPaths = new byte[numLayer][][];\n        byte[][][] nextAuthPaths = new byte[numLayer - 1][][];\n        Treehash[][] currentTreehash = new Treehash[numLayer][];\n        Treehash[][] nextTreehash = new Treehash[numLayer - 1][];\n\n        Vector[] currentStack = new Vector[numLayer];\n        Vector[] nextStack = new Vector[numLayer - 1];\n\n        Vector[][] currentRetain = new Vector[numLayer][];\n        Vector[][] nextRetain = new Vector[numLayer - 1][];\n\n        for (int i = 0; i < numLayer; i++)\n        {\n            currentAuthPaths[i] = new byte[heightOfTrees[i]][mdLength];\n            currentTreehash[i] = new Treehash[heightOfTrees[i] - K[i]];\n\n            if (i > 0)\n            {\n                nextAuthPaths[i - 1] = new byte[heightOfTrees[i]][mdLength];\n                nextTreehash[i - 1] = new Treehash[heightOfTrees[i] - K[i]];\n            }\n\n            currentStack[i] = new Vector();\n            if (i > 0)\n            {\n                nextStack[i - 1] = new Vector();\n            }\n        }\n\n        // initialize roots\n        byte[][] currentRoots = new byte[numLayer][mdLength];\n        byte[][] nextRoots = new byte[numLayer - 1][mdLength];\n        // initialize seeds\n        byte[][] seeds = new byte[numLayer][mdLength];\n        // initialize seeds[] by copying starting-seeds of first trees of each\n        // layer\n        for (int i = 0; i < numLayer; i++)\n        {\n            System.arraycopy(currentSeeds[i], 0, seeds[i], 0, mdLength);\n        }\n\n        // initialize rootSigs\n        currentRootSigs = new byte[numLayer - 1][mdLength];\n\n        // -------------------------\n        // -------------------------\n        // --- calculation of current authpaths and current rootsigs (AUTHPATHS,\n        // SIG)------\n        // from bottom up to the root\n        for (int h = numLayer - 1; h >= 0; h--)\n        {\n            GMSSRootCalc tree = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], digestProvider);\n            try\n            {\n                // on lowest layer no lower root is available, so just call\n                // the method with null as first parameter\n                if (h == numLayer - 1)\n                {\n                    tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);\n                }\n                else\n                // otherwise call the method with the former computed root\n                // value\n                {\n                    tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);\n                }\n\n            }\n            catch (Exception e1)\n            {\n                e1.printStackTrace();\n            }\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, currentAuthPaths[h][i], 0, mdLength);\n            }\n            currentRetain[h] = tree.getRetain();\n            currentTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, currentRoots[h], 0, mdLength);\n        }\n\n        // --- calculation of next authpaths and next roots (AUTHPATHS+, ROOTS+)\n        // ------\n        for (int h = numLayer - 2; h >= 0; h--)\n        {\n            GMSSRootCalc tree = this.generateNextAuthpathAndRoot(nextStack[h], seeds[h + 1], h + 1);\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h + 1]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, nextAuthPaths[h][i], 0, mdLength);\n            }\n            nextRetain[h] = tree.getRetain();\n            nextTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, nextRoots[h], 0, mdLength);\n\n            // create seed for the Merkle tree after next (nextNextSeeds)\n            // SEEDs++\n            System.arraycopy(seeds[h + 1], 0, this.nextNextSeeds[h], 0, mdLength);\n        }\n        // ------------\n\n        // generate JDKGMSSPublicKey\n        GMSSPublicKeyParameters publicKey = new GMSSPublicKeyParameters(currentRoots[0], gmssPS);\n\n        // generate the JDKGMSSPrivateKey\n        GMSSPrivateKeyParameters privateKey = new GMSSPrivateKeyParameters(currentSeeds, nextNextSeeds, currentAuthPaths,\n            nextAuthPaths, currentTreehash, nextTreehash, currentStack, nextStack, currentRetain, nextRetain, nextRoots, currentRootSigs, gmssPS, digestProvider);\n\n        // return the KeyPair\n        return (new AsymmetricCipherKeyPair(publicKey, privateKey));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private AsymmetricCipherKeyPair genKeyPair()\n    {\n        if (!initialized)\n        {\n            initializeDefault();\n        }\n\n        // initialize authenticationPaths and treehash instances\n        byte[][][] currentAuthPaths = new byte[numLayer][][];\n        byte[][][] nextAuthPaths = new byte[numLayer - 1][][];\n        Treehash[][] currentTreehash = new Treehash[numLayer][];\n        Treehash[][] nextTreehash = new Treehash[numLayer - 1][];\n\n        Vector[] currentStack = new Vector[numLayer];\n        Vector[] nextStack = new Vector[numLayer - 1];\n\n        Vector[][] currentRetain = new Vector[numLayer][];\n        Vector[][] nextRetain = new Vector[numLayer - 1][];\n\n        for (int i = 0; i < numLayer; i++)\n        {\n            currentAuthPaths[i] = new byte[heightOfTrees[i]][mdLength];\n            currentTreehash[i] = new Treehash[heightOfTrees[i] - K[i]];\n\n            if (i > 0)\n            {\n                nextAuthPaths[i - 1] = new byte[heightOfTrees[i]][mdLength];\n                nextTreehash[i - 1] = new Treehash[heightOfTrees[i] - K[i]];\n            }\n\n            currentStack[i] = new Vector();\n            if (i > 0)\n            {\n                nextStack[i - 1] = new Vector();\n            }\n        }\n\n        // initialize roots\n        byte[][] currentRoots = new byte[numLayer][mdLength];\n        byte[][] nextRoots = new byte[numLayer - 1][mdLength];\n        // initialize seeds\n        byte[][] seeds = new byte[numLayer][mdLength];\n        // initialize seeds[] by copying starting-seeds of first trees of each\n        // layer\n        for (int i = 0; i < numLayer; i++)\n        {\n            System.arraycopy(currentSeeds[i], 0, seeds[i], 0, mdLength);\n        }\n\n        // initialize rootSigs\n        currentRootSigs = new byte[numLayer - 1][mdLength];\n\n        // -------------------------\n        // -------------------------\n        // --- calculation of current authpaths and current rootsigs (AUTHPATHS,\n        // SIG)------\n        // from bottom up to the root\n        for (int h = numLayer - 1; h >= 0; h--)\n        {\n            GMSSRootCalc tree;\n\n            // on lowest layer no lower root is available, so just call\n            // the method with null as first parameter\n            if (h == numLayer - 1)\n            {\n                tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);\n            }\n            else\n            // otherwise call the method with the former computed root\n            // value\n            {\n                tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);\n            }\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, currentAuthPaths[h][i], 0, mdLength);\n            }\n            currentRetain[h] = tree.getRetain();\n            currentTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, currentRoots[h], 0, mdLength);\n        }\n\n        // --- calculation of next authpaths and next roots (AUTHPATHS+, ROOTS+)\n        // ------\n        for (int h = numLayer - 2; h >= 0; h--)\n        {\n            GMSSRootCalc tree = this.generateNextAuthpathAndRoot(nextStack[h], seeds[h + 1], h + 1);\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h + 1]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, nextAuthPaths[h][i], 0, mdLength);\n            }\n            nextRetain[h] = tree.getRetain();\n            nextTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, nextRoots[h], 0, mdLength);\n\n            // create seed for the Merkle tree after next (nextNextSeeds)\n            // SEEDs++\n            System.arraycopy(seeds[h + 1], 0, this.nextNextSeeds[h], 0, mdLength);\n        }\n        // ------------\n\n        // generate JDKGMSSPublicKey\n        GMSSPublicKeyParameters publicKey = new GMSSPublicKeyParameters(currentRoots[0], gmssPS);\n\n        // generate the JDKGMSSPrivateKey\n        GMSSPrivateKeyParameters privateKey = new GMSSPrivateKeyParameters(currentSeeds, nextNextSeeds, currentAuthPaths,\n            nextAuthPaths, currentTreehash, nextTreehash, currentStack, nextStack, currentRetain, nextRetain, nextRoots, currentRootSigs, gmssPS, digestProvider);\n\n        // return the KeyPair\n        return (new AsymmetricCipherKeyPair(publicKey, privateKey));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private XMSSPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int height = params.getHeight();\n            int indexSize = 4;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n\t\t\t/*\n\t\t\tint totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            int index = Pack.bigEndianToInt(privateKey, position);\n            if (!XMSSUtil.isIndexValid(height, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n            BDS bdsImport = null;\n            try\n            {\n                bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary);\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            catch (ClassNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n            bdsImport.setXMSS(builder.xmss);\n            bdsImport.validate();\n            if (bdsImport.getIndex() != index)\n            {\n                throw new IllegalStateException(\"serialized BDS has wrong index\");\n            }\n            bdsState = bdsImport;\n        }\n        else\n        {\n\t\t\t/* set */\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDS tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                if (builder.index < ((1 << params.getHeight()) - 2) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDS(params, tmpPublicSeed, tmpSecretKeySeed, (OTSHashAddress)new OTSHashAddress.Builder().build(), builder.index);\n                }\n                else\n                {\n                    bdsState = new BDS(params, builder.index);\n                }\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private XMSSPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int height = params.getHeight();\n            int indexSize = 4;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n\t\t\t/*\n\t\t\tint totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            int index = Pack.bigEndianToInt(privateKey, position);\n            if (!XMSSUtil.isIndexValid(height, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n            try\n            {\n                BDS bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary, BDS.class);\n                bdsImport.setXMSS(builder.xmss);\n                bdsImport.validate();\n                if (bdsImport.getIndex() != index)\n                {\n                    throw new IllegalStateException(\"serialized BDS has wrong index\");\n                }\n                bdsState = bdsImport;\n            }\n            catch (IOException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n            catch (ClassNotFoundException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n        }\n        else\n        {\n\t\t\t/* set */\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDS tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                if (builder.index < ((1 << params.getHeight()) - 2) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDS(params, tmpPublicSeed, tmpSecretKeySeed, (OTSHashAddress)new OTSHashAddress.Builder().build(), builder.index);\n                }\n                else\n                {\n                    bdsState = new BDS(params, builder.index);\n                }\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private XMSSMTPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int totalHeight = params.getHeight();\n            int indexSize = (totalHeight + 7) / 8;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n            /*\n            int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            index = XMSSUtil.bytesToXBigEndian(privateKey, position, indexSize);\n            if (!XMSSUtil.isIndexValid(totalHeight, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n\n            BDSStateMap bdsImport = null;\n            try\n            {\n                bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary);\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            catch (ClassNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n            bdsImport.setXMSS(builder.xmss);\n            bdsState = bdsImport;\n        }\n        else\n        {\n\t\t\t/* set */\n            index = builder.index;\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDSStateMap tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                long globalIndex = builder.index;\n                int totalHeight = params.getHeight();\n\n                if (XMSSUtil.isIndexValid(totalHeight, globalIndex) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDSStateMap(params, builder.index, tmpPublicSeed, tmpSecretKeySeed);\n                }\n                else\n                {\n                    bdsState = new BDSStateMap();\n                }\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private XMSSMTPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int totalHeight = params.getHeight();\n            int indexSize = (totalHeight + 7) / 8;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n            /*\n            int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            index = XMSSUtil.bytesToXBigEndian(privateKey, position, indexSize);\n            if (!XMSSUtil.isIndexValid(totalHeight, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n\n            try\n            {\n                BDSStateMap bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary, BDSStateMap.class);\n\n                bdsImport.setXMSS(builder.xmss);\n                bdsState = bdsImport;\n            }\n            catch (IOException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n            catch (ClassNotFoundException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n        }\n        else\n        {\n\t\t\t/* set */\n            index = builder.index;\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDSStateMap tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                long globalIndex = builder.index;\n                int totalHeight = params.getHeight();\n\n                if (XMSSUtil.isIndexValid(totalHeight, globalIndex) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDSStateMap(params, builder.index, tmpPublicSeed, tmpSecretKeySeed);\n                }\n                else\n                {\n                    bdsState = new BDSStateMap();\n                }\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public byte[] toByteArray()\n    {\n\t\t/* index || secretKeySeed || secretKeyPRF || publicSeed || root */\n        int n = params.getDigestSize();\n        int indexSize = (params.getHeight() + 7) / 8;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n        int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n        byte[] out = new byte[totalSize];\n        int position = 0;\n\t\t/* copy index */\n        byte[] indexBytes = XMSSUtil.toBytesBigEndian(index, indexSize);\n        XMSSUtil.copyBytesAtOffset(out, indexBytes, position);\n        position += indexSize;\n\t\t/* copy secretKeySeed */\n        XMSSUtil.copyBytesAtOffset(out, secretKeySeed, position);\n        position += secretKeySize;\n\t\t/* copy secretKeyPRF */\n        XMSSUtil.copyBytesAtOffset(out, secretKeyPRF, position);\n        position += secretKeyPRFSize;\n\t\t/* copy publicSeed */\n        XMSSUtil.copyBytesAtOffset(out, publicSeed, position);\n        position += publicSeedSize;\n\t\t/* copy root */\n        XMSSUtil.copyBytesAtOffset(out, root, position);\n\t\t/* concatenate bdsState */\n        byte[] bdsStateOut = null;\n        try\n        {\n            bdsStateOut = XMSSUtil.serialize(bdsState);\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n            throw new RuntimeException(\"error serializing bds state\");\n        }\n        return Arrays.concatenate(out, bdsStateOut);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public byte[] toByteArray()\n    {\n\t\t/* index || secretKeySeed || secretKeyPRF || publicSeed || root */\n        int n = params.getDigestSize();\n        int indexSize = (params.getHeight() + 7) / 8;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n        int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n        byte[] out = new byte[totalSize];\n        int position = 0;\n\t\t/* copy index */\n        byte[] indexBytes = XMSSUtil.toBytesBigEndian(index, indexSize);\n        XMSSUtil.copyBytesAtOffset(out, indexBytes, position);\n        position += indexSize;\n\t\t/* copy secretKeySeed */\n        XMSSUtil.copyBytesAtOffset(out, secretKeySeed, position);\n        position += secretKeySize;\n\t\t/* copy secretKeyPRF */\n        XMSSUtil.copyBytesAtOffset(out, secretKeyPRF, position);\n        position += secretKeyPRFSize;\n\t\t/* copy publicSeed */\n        XMSSUtil.copyBytesAtOffset(out, publicSeed, position);\n        position += publicSeedSize;\n\t\t/* copy root */\n        XMSSUtil.copyBytesAtOffset(out, root, position);\n\t\t/* concatenate bdsState */\n        try\n        {\n            return Arrays.concatenate(out, XMSSUtil.serialize(bdsState));\n        }\n        catch (IOException e)\n        {\n            throw new IllegalStateException(\"error serializing bds state: \" + e.getMessage(), e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public RainbowParameters(int[] vi)\n    {\n        this.vi = vi;\n        try\n        {\n            checkParams();\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public RainbowParameters(int[] vi)\n    {\n        this.vi = vi;\n\n        checkParams();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void decodeTest()\n    {\n        EllipticCurve curve = new EllipticCurve(\n                new ECFieldFp(new BigInteger(\"6277101735386680763835789423207666416083908700390324961279\")), // q\n                new BigInteger(\"fffffffffffffffffffffffffffffffefffffffffffffffc\", 16), // a\n                new BigInteger(\"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\", 16)); // b\n\n        ECPoint p = ECPointUtil.decodePoint(curve, Hex.decode(\"03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\"));\n\n        if (!p.getAffineX().equals(new BigInteger(\"188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\", 16)))\n        {\n            fail(\"x uncompressed incorrectly\");\n        }\n\n        if (!p.getAffineY().equals(new BigInteger(\"7192b95ffc8da78631011ed6b24cdd573f977a11e794811\", 16)))\n        {\n            fail(\"y uncompressed incorrectly\");\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void decodeTest()\n    {\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldFp(new BigInteger(\"6277101735386680763835789423207666416083908700390324961279\")), // q\n            new BigInteger(\"fffffffffffffffffffffffffffffffefffffffffffffffc\", 16), // a\n            new BigInteger(\"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\", 16)); // b\n\n        ECPoint p = ECPointUtil.decodePoint(curve, Hex.decode(\"03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\"));\n\n        if (!p.getAffineX().equals(new BigInteger(\"188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\", 16)))\n        {\n            fail(\"x uncompressed incorrectly\");\n        }\n\n        if (!p.getAffineY().equals(new BigInteger(\"7192b95ffc8da78631011ed6b24cdd573f977a11e794811\", 16)))\n        {\n            fail(\"y uncompressed incorrectly\");\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECDSA5Test());\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void main(\n        String[] args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECDSA5Test());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"KeyPairGenerator.DH\", PREFIX + \"KeyPairGeneratorSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyPairGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"KeyAgreement.DH\", PREFIX + \"KeyAgreementSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyAgreement.DIFFIEHELLMAN\", \"DH\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_ESDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_SSDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n\n            provider.addAlgorithm(\"KeyFactory.DH\", PREFIX + \"KeyFactorySpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyFactory.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.DH\", PREFIX + \"AlgorithmParametersSpi\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.DH\", PREFIX + \"AlgorithmParameterGeneratorSpi\");\n\n            provider.addAlgorithm(\"Cipher.IES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.IESwithAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.IESWITHAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.IESWITHDESEDE\", PREFIX + \"IESCipher$IESwithDESede\");\n\n            provider.addAlgorithm(\"Cipher.DHIES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.DHIESwithAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHAES\", PREFIX + \"IESCipher$IESwithAES\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHDESEDE\", PREFIX + \"IESCipher$IESwithDESede\");\n\n            provider.addAlgorithm(\"Cipher.OLDDHIES\", PREFIX + \"IESCipher$OldIES\");\n            provider.addAlgorithm(\"Cipher.OLDDHIESwithAES\", PREFIX + \"IESCipher$OldIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OLDDHIESWITHAES\", PREFIX + \"IESCipher$OldIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OLDDHIESWITHDESEDE\", PREFIX + \"IESCipher$OldIESwithDESede\");\n\n            registerOid(provider, PKCSObjectIdentifiers.dhKeyAgreement, \"DH\", new KeyFactorySpi());\n            registerOid(provider, X9ObjectIdentifiers.dhpublicnumber, \"DH\", new KeyFactorySpi());\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"KeyPairGenerator.DH\", PREFIX + \"KeyPairGeneratorSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyPairGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"KeyAgreement.DH\", PREFIX + \"KeyAgreementSpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyAgreement.DIFFIEHELLMAN\", \"DH\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_ESDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n            provider.addAlgorithm(\"KeyAgreement\", PKCSObjectIdentifiers.id_alg_SSDH, PREFIX + \"KeyAgreementSpi$DHwithRFC2631KDF\");\n\n            provider.addAlgorithm(\"KeyFactory.DH\", PREFIX + \"KeyFactorySpi\");\n            provider.addAlgorithm(\"Alg.Alias.KeyFactory.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameters.DH\", PREFIX + \"AlgorithmParametersSpi\");\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameters.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"Alg.Alias.AlgorithmParameterGenerator.DIFFIEHELLMAN\", \"DH\");\n\n            provider.addAlgorithm(\"AlgorithmParameterGenerator.DH\", PREFIX + \"AlgorithmParameterGeneratorSpi\");\n\n            provider.addAlgorithm(\"Cipher.IES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.IESwithAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.IESWITHAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.IESWITHDESEDE-CBC\", PREFIX + \"IESCipher$IESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Cipher.DHIES\", PREFIX + \"IESCipher$IES\");\n            provider.addAlgorithm(\"Cipher.DHIESwithAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHAES-CBC\", PREFIX + \"IESCipher$IESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.DHIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$IESwithDESedeCBC\");\n\n            registerOid(provider, PKCSObjectIdentifiers.dhKeyAgreement, \"DH\", new KeyFactorySpi());\n            registerOid(provider, X9ObjectIdentifiers.dhpublicnumber, \"DH\", new KeyFactorySpi());\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"AlgorithmParameters.EC\", PREFIX + \"AlgorithmParametersSpi\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDH\", PREFIX + \"KeyAgreementSpi$DH\");\n            provider.addAlgorithm(\"KeyAgreement.ECDHC\", PREFIX + \"KeyAgreementSpi$DHC\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDH\", PREFIX + \"KeyAgreementSpi$DHC\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA1KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA1KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA224KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA224KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA256KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA256KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA384KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA384KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA512KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA512KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDHWITHSHA1KDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1KDF\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA256CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA384CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA512CKDF\");\n\n            registerOid(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\");\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\");\n\n            if (!Properties.isOverrideSet(\"org.bouncycastle.ec.disable_mqv\"))\n            {\n                provider.addAlgorithm(\"KeyAgreement.ECMQV\", PREFIX + \"KeyAgreementSpi$MQV\");\n\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA1CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA224CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA224CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA256CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA384CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA512CKDF\");\n\n                provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA1KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA224KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA256KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA384KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA512KDFAndSharedInfo\");\n\n                registerOid(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n                registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"EC\");\n\n                provider.addAlgorithm(\"KeyFactory.ECMQV\", PREFIX + \"KeyFactorySpi$ECMQV\");\n                provider.addAlgorithm(\"KeyPairGenerator.ECMQV\", PREFIX + \"KeyPairGeneratorSpi$ECMQV\");\n            }\n\n            provider.addAlgorithm(\"KeyFactory.EC\", PREFIX + \"KeyFactorySpi$EC\");\n            provider.addAlgorithm(\"KeyFactory.ECDSA\", PREFIX + \"KeyFactorySpi$ECDSA\");\n            provider.addAlgorithm(\"KeyFactory.ECDH\", PREFIX + \"KeyFactorySpi$ECDH\");\n            provider.addAlgorithm(\"KeyFactory.ECDHC\", PREFIX + \"KeyFactorySpi$ECDHC\");\n\n            provider.addAlgorithm(\"KeyPairGenerator.EC\", PREFIX + \"KeyPairGeneratorSpi$EC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDSA\", PREFIX + \"KeyPairGeneratorSpi$ECDSA\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDH\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHWITHSHA1KDF\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHC\", PREFIX + \"KeyPairGeneratorSpi$ECDHC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECIES\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n\n            provider.addAlgorithm(\"Cipher.ECIES\", PREFIX + \"IESCipher$ECIES\");\n            provider.addAlgorithm(\"Cipher.ECIESwithAES\", PREFIX + \"IESCipher$ECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHAES\", PREFIX + \"IESCipher$ECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.ECIESwithDESEDE\", PREFIX + \"IESCipher$ECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHDESEDE\", PREFIX + \"IESCipher$ECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.ECIESwithAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESwithDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Cipher.OldECIES\", PREFIX + \"IESCipher$OldECIES\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithAES\", PREFIX + \"IESCipher$OldECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHAES\", PREFIX + \"IESCipher$OldECIESwithAES\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithDESEDE\", PREFIX + \"IESCipher$OldECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHDESEDE\", PREFIX + \"IESCipher$OldECIESwithDESede\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithAES-CBC\", PREFIX + \"IESCipher$OldECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHAES-CBC\", PREFIX + \"IESCipher$OldECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.OldECIESwithDESEDE-CBC\", PREFIX + \"IESCipher$OldECIESwithDESedeCBC\");\n            provider.addAlgorithm(\"Cipher.OldECIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$OldECIESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Signature.ECDSA\", PREFIX + \"SignatureSpi$ecDSA\");\n            provider.addAlgorithm(\"Signature.NONEwithECDSA\", PREFIX + \"SignatureSpi$ecDSAnone\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1withECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAwithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWITHSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WithECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.1.2.840.10045.4.1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.\" + TeleTrusTObjectIdentifiers.ecSignWithSha1, \"ECDSA\");\n\n            provider.addAlgorithm(\"Signature.ECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA1WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA512\");\n            provider.addAlgorithm(\"Signature.SHA3-224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_224\");\n            provider.addAlgorithm(\"Signature.SHA3-256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_256\");\n            provider.addAlgorithm(\"Signature.SHA3-384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_384\");\n            provider.addAlgorithm(\"Signature.SHA3-512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_512\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.DETECDSA\", \"ECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHDETECDSA\", \"SHA1WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA224WITHDETECDSA\", \"SHA224WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA256WITHDETECDSA\", \"SHA256WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA384WITHDETECDSA\", \"SHA384WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA512WITHDETECDSA\", \"SHA512WITHECDDSA\");\n\n            addSignatureAlgorithm(provider, \"SHA224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA224\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA256\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA384\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA512\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n            addSignatureAlgorithm(provider, \"SHA3-224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_224\", NISTObjectIdentifiers.id_ecdsa_with_sha3_224);\n            addSignatureAlgorithm(provider, \"SHA3-256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_256\", NISTObjectIdentifiers.id_ecdsa_with_sha3_256);\n            addSignatureAlgorithm(provider, \"SHA3-384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_384\", NISTObjectIdentifiers.id_ecdsa_with_sha3_384);\n            addSignatureAlgorithm(provider, \"SHA3-512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_512\", NISTObjectIdentifiers.id_ecdsa_with_sha3_512);\n\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSARipeMD160\",TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n\n            provider.addAlgorithm(\"Signature.SHA1WITHECNR\", PREFIX + \"SignatureSpi$ecNR\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECNR\", PREFIX + \"SignatureSpi$ecNR224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECNR\", PREFIX + \"SignatureSpi$ecNR256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECNR\", PREFIX + \"SignatureSpi$ecNR384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECNR\", PREFIX + \"SignatureSpi$ecNR512\");\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", BSIObjectIdentifiers.ecdsa_plain_SHA1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", BSIObjectIdentifiers.ecdsa_plain_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", BSIObjectIdentifiers.ecdsa_plain_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", BSIObjectIdentifiers.ecdsa_plain_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", BSIObjectIdentifiers.ecdsa_plain_SHA512);\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecPlainDSARP160\", BSIObjectIdentifiers.ecdsa_plain_RIPEMD160);\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void configure(ConfigurableProvider provider)\n        {\n            provider.addAlgorithm(\"AlgorithmParameters.EC\", PREFIX + \"AlgorithmParametersSpi\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDH\", PREFIX + \"KeyAgreementSpi$DH\");\n            provider.addAlgorithm(\"KeyAgreement.ECDHC\", PREFIX + \"KeyAgreementSpi$DHC\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDH\", PREFIX + \"KeyAgreementSpi$DHC\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA1KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA1KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA224KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA224KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA256KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA256KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA384KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA384KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$DHwithSHA512KDFAndSharedInfo\");\n            provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$CDHwithSHA512KDFAndSharedInfo\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECDHWITHSHA1KDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1KDF\");\n\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA1CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA256CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA384CKDF\");\n            provider.addAlgorithm(\"KeyAgreement.ECCDHWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$DHwithSHA512CKDF\");\n\n            registerOid(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n            registerOid(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.id_ecPublicKey, \"EC\");\n\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.dhSinglePass_cofactorDH_sha1kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha224kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha224kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha256kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha256kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha384kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha384kdf_scheme, \"EC\");\n\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_stdDH_sha512kdf_scheme, \"EC\");\n            registerOidAlgorithmParameters(provider, SECObjectIdentifiers.dhSinglePass_cofactorDH_sha512kdf_scheme, \"EC\");\n\n            if (!Properties.isOverrideSet(\"org.bouncycastle.ec.disable_mqv\"))\n            {\n                provider.addAlgorithm(\"KeyAgreement.ECMQV\", PREFIX + \"KeyAgreementSpi$MQV\");\n\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA1CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA1CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA224CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA224CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA256CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA256CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA384CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA384CKDF\");\n                provider.addAlgorithm(\"KeyAgreement.ECMQVWITHSHA512CKDF\", PREFIX + \"KeyAgreementSpi$MQVwithSHA512CKDF\");\n\n                provider.addAlgorithm(\"KeyAgreement.\" + X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA1KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA224KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA256KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA384KDFAndSharedInfo\");\n                provider.addAlgorithm(\"KeyAgreement.\" + SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, PREFIX + \"KeyAgreementSpi$MQVwithSHA512KDFAndSharedInfo\");\n\n                registerOid(provider, X9ObjectIdentifiers.dhSinglePass_stdDH_sha1kdf_scheme, \"EC\", new KeyFactorySpi.EC());\n                registerOidAlgorithmParameters(provider, X9ObjectIdentifiers.mqvSinglePass_sha1kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha256kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha224kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha384kdf_scheme, \"EC\");\n\n                registerOid(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"ECMQV\", new KeyFactorySpi.ECMQV());\n                registerOidAlgorithmParameters(provider, SECObjectIdentifiers.mqvSinglePass_sha512kdf_scheme, \"EC\");\n\n                provider.addAlgorithm(\"KeyFactory.ECMQV\", PREFIX + \"KeyFactorySpi$ECMQV\");\n                provider.addAlgorithm(\"KeyPairGenerator.ECMQV\", PREFIX + \"KeyPairGeneratorSpi$ECMQV\");\n            }\n\n            provider.addAlgorithm(\"KeyFactory.EC\", PREFIX + \"KeyFactorySpi$EC\");\n            provider.addAlgorithm(\"KeyFactory.ECDSA\", PREFIX + \"KeyFactorySpi$ECDSA\");\n            provider.addAlgorithm(\"KeyFactory.ECDH\", PREFIX + \"KeyFactorySpi$ECDH\");\n            provider.addAlgorithm(\"KeyFactory.ECDHC\", PREFIX + \"KeyFactorySpi$ECDHC\");\n\n            provider.addAlgorithm(\"KeyPairGenerator.EC\", PREFIX + \"KeyPairGeneratorSpi$EC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDSA\", PREFIX + \"KeyPairGeneratorSpi$ECDSA\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDH\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHWITHSHA1KDF\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECDHC\", PREFIX + \"KeyPairGeneratorSpi$ECDHC\");\n            provider.addAlgorithm(\"KeyPairGenerator.ECIES\", PREFIX + \"KeyPairGeneratorSpi$ECDH\");\n\n            provider.addAlgorithm(\"Cipher.ECIES\", PREFIX + \"IESCipher$ECIES\");\n\n            provider.addAlgorithm(\"Cipher.ECIESwithAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHAES-CBC\", PREFIX + \"IESCipher$ECIESwithAESCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESwithDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n            provider.addAlgorithm(\"Cipher.ECIESWITHDESEDE-CBC\", PREFIX + \"IESCipher$ECIESwithDESedeCBC\");\n\n            provider.addAlgorithm(\"Signature.ECDSA\", PREFIX + \"SignatureSpi$ecDSA\");\n            provider.addAlgorithm(\"Signature.NONEwithECDSA\", PREFIX + \"SignatureSpi$ecDSAnone\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1withECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAwithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWITHSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WithECDSA\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.ECDSAWithSHA1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.1.2.840.10045.4.1\", \"ECDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.\" + TeleTrusTObjectIdentifiers.ecSignWithSha1, \"ECDSA\");\n\n            provider.addAlgorithm(\"Signature.ECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA1WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSA512\");\n            provider.addAlgorithm(\"Signature.SHA3-224WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_224\");\n            provider.addAlgorithm(\"Signature.SHA3-256WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_256\");\n            provider.addAlgorithm(\"Signature.SHA3-384WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_384\");\n            provider.addAlgorithm(\"Signature.SHA3-512WITHECDDSA\", PREFIX + \"SignatureSpi$ecDetDSASha3_512\");\n\n            provider.addAlgorithm(\"Alg.Alias.Signature.DETECDSA\", \"ECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA1WITHDETECDSA\", \"SHA1WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA224WITHDETECDSA\", \"SHA224WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA256WITHDETECDSA\", \"SHA256WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA384WITHDETECDSA\", \"SHA384WITHECDDSA\");\n            provider.addAlgorithm(\"Alg.Alias.Signature.SHA512WITHDETECDSA\", \"SHA512WITHECDDSA\");\n\n            addSignatureAlgorithm(provider, \"SHA224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA224\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA256\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA384\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSA512\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n            addSignatureAlgorithm(provider, \"SHA3-224\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_224\", NISTObjectIdentifiers.id_ecdsa_with_sha3_224);\n            addSignatureAlgorithm(provider, \"SHA3-256\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_256\", NISTObjectIdentifiers.id_ecdsa_with_sha3_256);\n            addSignatureAlgorithm(provider, \"SHA3-384\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_384\", NISTObjectIdentifiers.id_ecdsa_with_sha3_384);\n            addSignatureAlgorithm(provider, \"SHA3-512\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSASha3_512\", NISTObjectIdentifiers.id_ecdsa_with_sha3_512);\n\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"ECDSA\", PREFIX + \"SignatureSpi$ecDSARipeMD160\",TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n\n            provider.addAlgorithm(\"Signature.SHA1WITHECNR\", PREFIX + \"SignatureSpi$ecNR\");\n            provider.addAlgorithm(\"Signature.SHA224WITHECNR\", PREFIX + \"SignatureSpi$ecNR224\");\n            provider.addAlgorithm(\"Signature.SHA256WITHECNR\", PREFIX + \"SignatureSpi$ecNR256\");\n            provider.addAlgorithm(\"Signature.SHA384WITHECNR\", PREFIX + \"SignatureSpi$ecNR384\");\n            provider.addAlgorithm(\"Signature.SHA512WITHECNR\", PREFIX + \"SignatureSpi$ecNR512\");\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"CVC-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n            addSignatureAlgorithm(provider, \"SHA1\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA\", BSIObjectIdentifiers.ecdsa_plain_SHA1);\n            addSignatureAlgorithm(provider, \"SHA224\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA224\", BSIObjectIdentifiers.ecdsa_plain_SHA224);\n            addSignatureAlgorithm(provider, \"SHA256\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA256\", BSIObjectIdentifiers.ecdsa_plain_SHA256);\n            addSignatureAlgorithm(provider, \"SHA384\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA384\", BSIObjectIdentifiers.ecdsa_plain_SHA384);\n            addSignatureAlgorithm(provider, \"SHA512\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecCVCDSA512\", BSIObjectIdentifiers.ecdsa_plain_SHA512);\n            addSignatureAlgorithm(provider, \"RIPEMD160\", \"PLAIN-ECDSA\", PREFIX + \"SignatureSpi$ecPlainDSARP160\", BSIObjectIdentifiers.ecdsa_plain_RIPEMD160);\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static IESParameterSpec guessParameterSpec(BufferedBlockCipher iesBlockCipher)\n    {\n        if (iesBlockCipher == null)\n        {\n            return new IESParameterSpec(null, null, 128);\n        }\n        else\n        {\n            BlockCipher underlyingCipher = iesBlockCipher.getUnderlyingCipher();\n\n            if (underlyingCipher.getAlgorithmName().equals(\"DES\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC2\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-32\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-64\"))\n            {\n                return new IESParameterSpec(null, null, 64, 64);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"SKIPJACK\"))\n            {\n                return new IESParameterSpec(null, null, 80, 80);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"GOST28147\"))\n            {\n                return new IESParameterSpec(null, null, 256, 256);\n            }\n\n            return new IESParameterSpec(null, null, 128, 128);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static IESParameterSpec guessParameterSpec(BufferedBlockCipher iesBlockCipher, byte[] nonce)\n    {\n        if (iesBlockCipher == null)\n        {\n            return new IESParameterSpec(null, null, 128);\n        }\n        else\n        {\n            BlockCipher underlyingCipher = iesBlockCipher.getUnderlyingCipher();\n\n            if (underlyingCipher.getAlgorithmName().equals(\"DES\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC2\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-32\") ||\n                underlyingCipher.getAlgorithmName().equals(\"RC5-64\"))\n            {\n                return new IESParameterSpec(null, null, 64, 64, nonce);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"SKIPJACK\"))\n            {\n                return new IESParameterSpec(null, null, 80, 80, nonce);\n            }\n            else if (underlyingCipher.getAlgorithmName().equals(\"GOST28147\"))\n            {\n                return new IESParameterSpec(null, null, 256, 256, nonce);\n            }\n\n            return new IESParameterSpec(null, null, 128, 128, nonce);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public IESCipher(OldIESEngine engine)\n    {\n        this.engine = engine;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public IESCipher(IESEngine engine, int ivLength)\n    {\n        this.engine = engine;\n        this.ivLength = ivLength;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public byte[] engineGetIV()\n    {\n        return null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public byte[] engineGetIV()\n    {\n        if (engineSpec != null)\n        {\n            return engineSpec.getNonce();\n        }\n        return null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public byte[] engineGetIV()\n    {\n        return null;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public byte[] engineGetIV()\n    {\n        if (engineSpec != null)\n        {\n            return engineSpec.getNonce();\n        }\n        return null;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ECIESwithCipher(BlockCipher cipher, int ivLength)\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                            new KDF2BytesGenerator(new SHA1Digest()),\n                            new HMac(new SHA1Digest()),\n                            new PaddedBufferedBlockCipher(cipher)), ivLength);\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ECIESwithCipher(BlockCipher cipher, int ivLength)\n        {\n            super(new IESEngine(new ECDHBasicAgreement(),\n                            new KDF2BytesGenerator(new SHA1Digest()),\n                            new HMac(new SHA1Digest()),\n                            new PaddedBufferedBlockCipher(cipher)), ivLength);\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ECIESwithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESEngine()), 16);\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ECIESwithAESCBC()\n        {\n            super(new CBCBlockCipher(new AESFastEngine()), 16);\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void initialize(\n        int strength,\n        SecureRandom random)\n    {\n        if (strength < 512 || strength > 4096 || ((strength < 1024) && strength % 64 != 0) || (strength >= 1024 && strength % 1024 != 0))\n        {\n            throw new InvalidParameterException(\"strength must be from 512 - 4096 and a multiple of 1024 above 1024\");\n        }\n\n        this.strength = strength;\n        this.random = random;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void initialize(\n        int strength,\n        SecureRandom random)\n    {\n        if (strength < 512 || strength > 4096 || ((strength < 1024) && strength % 64 != 0) || (strength >= 1024 && strength % 1024 != 0))\n        {\n            throw new InvalidParameterException(\"strength must be from 512 - 4096 and a multiple of 1024 above 1024\");\n        }\n\n        this.strength = strength;\n        this.random = random;\n        this.initialised = false;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public KeyPair generateKeyPair()\n    {\n        if (!initialised)\n        {\n            DSAParametersGenerator pGen = new DSAParametersGenerator();\n\n            pGen.init(strength, certainty, random);\n            param = new DSAKeyGenerationParameters(random, pGen.generateParameters());\n            engine.init(param);\n            initialised = true;\n        }\n\n        AsymmetricCipherKeyPair pair = engine.generateKeyPair();\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)pair.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)pair.getPrivate();\n\n        return new KeyPair(new BCDSAPublicKey(pub), new BCDSAPrivateKey(priv));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public KeyPair generateKeyPair()\n    {\n        if (!initialised)\n        {\n            Integer paramStrength = Integers.valueOf(strength);\n\n            if (params.containsKey(paramStrength))\n            {\n                param = (DSAKeyGenerationParameters)params.get(paramStrength);\n            }\n            else\n            {\n                synchronized (lock)\n                {\n                    // we do the check again in case we were blocked by a generator for\n                    // our key size.\n                    if (params.containsKey(paramStrength))\n                    {\n                        param = (DSAKeyGenerationParameters)params.get(paramStrength);\n                    }\n                    else\n                    {\n                        DSAParametersGenerator pGen;\n                        DSAParameterGenerationParameters dsaParams;\n\n                        // Typical combination of keysize and size of q.\n                        //     keysize = 1024, q's size = 160\n                        //     keysize = 2048, q's size = 224\n                        //     keysize = 2048, q's size = 256\n                        //     keysize = 3072, q's size = 256\n                        // For simplicity if keysize is greater than 1024 then we choose q's size to be 256.\n                        // For legacy keysize that is less than 1024-bit, we just use the 186-2 style parameters\n                        if (strength == 1024)\n                        {\n                            pGen = new DSAParametersGenerator();\n                            if (Properties.isOverrideSet(\"org.bouncycastle.dsa.FIPS186-2for1024bits\"))\n                            {\n                                pGen.init(strength, certainty, random);\n                            }\n                            else\n                            {\n                                dsaParams = new DSAParameterGenerationParameters(1024, 160, certainty, random);\n                                pGen.init(dsaParams);\n                            }\n                        }\n                        else if (strength > 1024)\n                        {\n                            dsaParams = new DSAParameterGenerationParameters(strength, 256, certainty, random);\n                            pGen = new DSAParametersGenerator(new SHA256Digest());\n                            pGen.init(dsaParams);\n                        }\n                        else\n                        {\n                            pGen = new DSAParametersGenerator();\n                            pGen.init(strength, certainty, random);\n                        }\n                        param = new DSAKeyGenerationParameters(random, pGen.generateParameters());\n\n                        params.put(paramStrength, param);\n                    }\n                }\n            }\n\n            engine.init(param);\n            initialised = true;\n        }\n\n        AsymmetricCipherKeyPair pair = engine.generateKeyPair();\n        DSAPublicKeyParameters pub = (DSAPublicKeyParameters)pair.getPublic();\n        DSAPrivateKeyParameters priv = (DSAPrivateKeyParameters)pair.getPrivate();\n\n        return new KeyPair(new BCDSAPublicKey(pub), new BCDSAPrivateKey(priv));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public AuthenticationResult handleResponse(final byte[] response)\n    {\n        if (_state == State.COMPLETE)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalStateException(\"Multiple Authentications not permitted.\"));\n        }\n        else if (_state == State.INITIAL && (response == null || response.length == 0))\n        {\n            _state = State.CHALLENGE_SENT;\n            return new AuthenticationResult(new byte[0], AuthenticationResult.AuthenticationStatus.CONTINUE);\n        }\n\n        _state = State.COMPLETE;\n        if (response == null || response.length == 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authcid null terminator not found\"));\n        }\n\n        String password;\n        try\n        {\n            _username = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, UTF8);\n            // TODO: should not get pwd as a String but as a char array...\n            int passwordLen = response.length - authcidNullPosition - 1;\n            password = new String(response, authcidNullPosition + 1, passwordLen, UTF8);\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            throw new RuntimeException(\"JVM does not support UTF8\", e);\n        }\n        return _usernamePasswordAuthenticationProvider.authenticate(_username, password);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public AuthenticationResult handleResponse(final byte[] response)\n    {\n        if (_state == State.COMPLETE)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalStateException(\"Multiple Authentications not permitted.\"));\n        }\n        else if (_state == State.INITIAL && (response == null || response.length == 0))\n        {\n            _state = State.CHALLENGE_SENT;\n            return new AuthenticationResult(new byte[0], AuthenticationResult.AuthenticationStatus.CONTINUE);\n        }\n\n        _state = State.COMPLETE;\n        if (response == null || response.length == 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authzid null terminator not found\"));\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            return new AuthenticationResult(AuthenticationResult.AuthenticationStatus.ERROR,\n                                            new IllegalArgumentException(\n                                                    \"Invalid PLAIN encoding, authcid null terminator not found\"));\n        }\n\n        String password;\n        _username = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, UTF8);\n        // TODO: should not get pwd as a String but as a char array...\n        int passwordLen = response.length - authcidNullPosition - 1;\n        password = new String(response, authcidNullPosition + 1, passwordLen, UTF8);\n        return _usernamePasswordAuthenticationProvider.authenticate(_username, password);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private Document getXmlDoc() {\n    if (this.xmlDoc != null) {\n      return this.xmlDoc;\n    }\n\n    try {\n      this.xmlDoc = DocumentBuilderFactory\n        .newInstance()\n        .newDocumentBuilder()\n        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));\n      return xmlDoc;\n    } catch (SAXException | IOException | ParserConfigurationException e) {\n      throw new RuntimeException(\"非法的xml文本内容：\" + this.xmlString);\n    }\n\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "private Document getXmlDoc() {\n    if (this.xmlDoc != null) {\n      return this.xmlDoc;\n    }\n\n    try {\n      final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n      factory.setExpandEntityReferences(false);\n      this.xmlDoc = factory.newDocumentBuilder()\n        .parse(new ByteArrayInputStream(this.xmlString.getBytes(StandardCharsets.UTF_8)));\n      return xmlDoc;\n    } catch (SAXException | IOException | ParserConfigurationException e) {\n      throw new RuntimeException(\"非法的xml文本内容：\" + this.xmlString);\n    }\n\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected DocumentBuilder initialValue() {\n      try {\n        return DocumentBuilderFactory.newInstance().newDocumentBuilder();\n      } catch (ParserConfigurationException exc) {\n        throw new IllegalArgumentException(exc);\n      }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected DocumentBuilder initialValue() {\n      try {\n        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setExpandEntityReferences(false);\n        return factory.newDocumentBuilder();\n      } catch (ParserConfigurationException exc) {\n        throw new IllegalArgumentException(exc);\n      }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "ssl\n        if (requireSSL) {\n          throw new PSQLException(GT.tr(\"The server does not support SSL.\"),\n              PSQLState.CONNECTION_REJECTED);\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "throws\n                if (false) {\n                  //#else\n                  throw new PSQLException(GT.tr(\n                          \"SCRAM authentication is not supported by this driver. You need JDK >= 8 and pgjdbc >= 42.2.0 (not \\\".jre\\\" versions)\",\n                          areq), PSQLState.CONNECTION_REJECTED);\n                  //#endif\n                  //#if mvn.project.property.postgresql.jdbc.spec >= \"JDBC4.2\"\n                }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DocumentBuilder createDocumentBuilder() {\n        try {\n            DocumentBuilder documentBuilder = createDocumentBuilderFactory().newDocumentBuilder();\n            return documentBuilder;\n        } catch (ParserConfigurationException e) {\n            throw new RuntimeException(e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DocumentBuilder createDocumentBuilder() {\n        try {\n            DocumentBuilder documentBuilder = createDocumentBuilderFactory().newDocumentBuilder();\n            return documentBuilder;\n        } catch (ParserConfigurationException e) {\n            throw new XBException(\"Error on creating document builder\",e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DocumentBuilderFactory createDocumentBuilderFactory() {\n        DocumentBuilderFactory instance = DocumentBuilderFactory.newInstance();\n        instance.setExpandEntityReferences(false);\n        if (!NamespacePhilosophy.AGNOSTIC.equals(namespacePhilosophy)) {\n            instance.setNamespaceAware(NamespacePhilosophy.HEDONISTIC.equals(namespacePhilosophy));\n        }\n        return instance;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DocumentBuilderFactory createDocumentBuilderFactory() {\n        DocumentBuilderFactory instance = DocumentBuilderFactory.newInstance();\n        instance.setXIncludeAware(false);\n        instance.setExpandEntityReferences(false);\n        for (String featureDefault : FEATURE_DEFAULTS) {\n            String[] featureValue = featureDefault.split(\"#\");\n            try {\n                instance.setFeature(featureValue[0], Boolean.valueOf(featureValue[1]));\n            } catch (ParserConfigurationException e) {\n                // No worries if one feature is not supported.\n            }\n        }\n        if (!NamespacePhilosophy.AGNOSTIC.equals(namespacePhilosophy)) {\n            instance.setNamespaceAware(NamespacePhilosophy.HEDONISTIC.equals(namespacePhilosophy));\n        }\n        return instance;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Transformer createTransformer(final Document... document) {\n        try {\n            Transformer transformer = createTransformerFactory().newTransformer();\n            if (isPrettyPrinting()) {\n\n                // Enable some pretty printing of the resulting xml.\n                transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n                transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            }\n            if (isOmitXMLDeclaration()) {\n                transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n            }\n            return transformer;\n        } catch (TransformerConfigurationException e) {\n            throw new RuntimeException(e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Transformer createTransformer(final Document... document) {\n        try {\n            Transformer transformer = createTransformerFactory().newTransformer();\n            if (isPrettyPrinting()) {\n\n                // Enable some pretty printing of the resulting xml.\n                transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n                transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            }\n            if (isOmitXMLDeclaration()) {\n                transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n            }\n            return transformer;\n        } catch (TransformerConfigurationException e) {\n            throw new XBException(\"Error on creating transformer\",e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static void deployModel(final ProcessEngine engine, final ProcessDefinition procDef) {\n        XMLStreamReader xtr = null;\n        try (InputStream bpmnStream = engine.getRepositoryService().\n                getResourceAsStream(procDef.getDeploymentId(), procDef.getResourceName());\n                InputStreamReader isr = new InputStreamReader(bpmnStream)) {\n\n            xtr = XMLInputFactory.newInstance().createXMLStreamReader(isr);\n            BpmnModel bpmnModel = new BpmnXMLConverter().convertToBpmnModel(xtr);\n\n            Model model = engine.getRepositoryService().newModel();\n            ObjectNode modelObjectNode = OBJECT_MAPPER.createObjectNode();\n            modelObjectNode.put(ModelDataJsonConstants.MODEL_NAME, procDef.getName());\n            model.setMetaInfo(modelObjectNode.toString());\n            model.setName(procDef.getName());\n            model.setDeploymentId(procDef.getDeploymentId());\n            model.setVersion(procDef.getVersion());\n\n            engine.getRepositoryService().saveModel(model);\n            engine.getRepositoryService().addModelEditorSource(\n                    model.getId(),\n                    new BpmnJsonConverter().convertToJson(bpmnModel).toString().getBytes());\n        } catch (Exception e) {\n            throw new WorkflowException(\"While importing \" + procDef.getResourceName(), e);\n        } finally {\n            if (xtr != null) {\n                try {\n                    xtr.close();\n                } catch (XMLStreamException e) {\n                    // ignore\n                }\n            }\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static void deployModel(final ProcessEngine engine, final ProcessDefinition procDef) {\n        XMLStreamReader xtr = null;\n        try (InputStream bpmnStream = engine.getRepositoryService().\n                getResourceAsStream(procDef.getDeploymentId(), procDef.getResourceName());\n                InputStreamReader isr = new InputStreamReader(bpmnStream)) {\n\n            xtr = XML_INPUT_FACTORY.createXMLStreamReader(isr);\n            BpmnModel bpmnModel = new BpmnXMLConverter().convertToBpmnModel(xtr);\n\n            Model model = engine.getRepositoryService().newModel();\n            ObjectNode modelObjectNode = OBJECT_MAPPER.createObjectNode();\n            modelObjectNode.put(ModelDataJsonConstants.MODEL_NAME, procDef.getName());\n            model.setMetaInfo(modelObjectNode.toString());\n            model.setName(procDef.getName());\n            model.setDeploymentId(procDef.getDeploymentId());\n            model.setVersion(procDef.getVersion());\n\n            engine.getRepositoryService().saveModel(model);\n            engine.getRepositoryService().addModelEditorSource(\n                    model.getId(),\n                    new BpmnJsonConverter().convertToJson(bpmnModel).toString().getBytes());\n        } catch (Exception e) {\n            throw new WorkflowException(\"While importing \" + procDef.getResourceName(), e);\n        } finally {\n            if (xtr != null) {\n                try {\n                    xtr.close();\n                } catch (XMLStreamException e) {\n                    // ignore\n                }\n            }\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected ResourceResponse newResourceResponse(final IResource.Attributes attributes) {\n        ResourceResponse response = new AbstractResource.ResourceResponse();\n        response.setContentType(MediaType.TEXT_PLAIN);\n        try {\n            HttpServletRequest request = (HttpServletRequest) attributes.getRequest().getContainerRequest();\n            if (!xsrfCheck(request)) {\n                LOG.error(\"XSRF TOKEN does not match\");\n                response.setError(Response.Status.BAD_REQUEST.getStatusCode(), \"XSRF TOKEN does not match\");\n                return response;\n            }\n\n            if (!captchaCheck(\n                    request.getHeader(\"captcha\"),\n                    request.getSession().getAttribute(SyncopeEnduserConstants.CAPTCHA_SESSION_KEY))) {\n\n                throw new IllegalArgumentException(\"Entered captcha is not matching\");\n            }\n\n            UserTO userTO = MAPPER.readValue(request.getReader().readLine(), UserTO.class);\n            Map<String, CustomAttributesInfo> customFormAttributes =\n                    SyncopeEnduserApplication.get().getCustomFormAttributes();\n\n            // check if request is compliant with customization form rules\n            if (UserRequestValidator.compliant(userTO, customFormAttributes, false)) {\n                // 1. membership attributes management\n                Set<AttrTO> membAttrs = new HashSet<>();\n                for (AttrTO attr : userTO.getPlainAttrs()) {\n                    if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                        final String[] compositeSchemaKey = attr.getSchema().split(\n                                SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                        MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                new Predicate<MembershipTO>() {\n\n                            @Override\n                            public boolean evaluate(final MembershipTO item) {\n                                return compositeSchemaKey[0].equals(item.getGroupName());\n                            }\n                        });\n                        if (membership == null) {\n                            membership = new MembershipTO.Builder().group(null, compositeSchemaKey[0]).build();\n                            userTO.getMemberships().add(membership);\n                        }\n                        AttrTO clone = SerializationUtils.clone(attr);\n                        clone.setSchema(compositeSchemaKey[1]);\n                        membership.getPlainAttrs().add(clone);\n                        membAttrs.add(attr);\n                    }\n                }\n                userTO.getPlainAttrs().removeAll(membAttrs);\n\n                // 2. millis -> Date conversion for PLAIN attributes of USER and its MEMBERSHIPS\n                for (PlainSchemaTO plainSchema : SyncopeEnduserSession.get().getDatePlainSchemas()) {\n                    millisToDate(userTO.getPlainAttrs(), plainSchema);\n                    for (MembershipTO membership : userTO.getMemberships()) {\n                        millisToDate(membership.getPlainAttrs(), plainSchema);\n                    }\n                }\n\n                membAttrs.clear();\n                for (AttrTO attr : userTO.getDerAttrs()) {\n                    if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                        final String[] simpleAttrs = attr.getSchema().split(\n                                SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                        MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                new Predicate<MembershipTO>() {\n\n                            @Override\n                            public boolean evaluate(final MembershipTO item) {\n                                return simpleAttrs[0].equals(item.getGroupName());\n                            }\n                        });\n                        if (membership == null) {\n                            membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                            userTO.getMemberships().add(membership);\n                        }\n                        AttrTO clone = SerializationUtils.clone(attr);\n                        clone.setSchema(simpleAttrs[1]);\n                        membership.getDerAttrs().add(clone);\n                        membAttrs.add(attr);\n                    }\n                }\n                userTO.getDerAttrs().removeAll(membAttrs);\n\n                membAttrs.clear();\n                for (AttrTO attr : userTO.getVirAttrs()) {\n                    if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                        final String[] simpleAttrs = attr.getSchema().split(\n                                SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                        MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                new Predicate<MembershipTO>() {\n\n                            @Override\n                            public boolean evaluate(final MembershipTO item) {\n                                return simpleAttrs[0].equals(item.getGroupName());\n                            }\n                        });\n                        if (membership == null) {\n                            membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                            userTO.getMemberships().add(membership);\n\n                        }\n                        AttrTO clone = SerializationUtils.clone(attr);\n                        clone.setSchema(simpleAttrs[1]);\n                        membership.getVirAttrs().add(clone);\n                        membAttrs.add(attr);\n                    }\n                }\n                userTO.getVirAttrs().removeAll(membAttrs);\n\n                // get old user object from session\n                UserTO selfTO = SyncopeEnduserSession.get().getSelfTO();\n                // align \"userTO\" and \"selfTO\" objects\n                if (customFormAttributes != null && !customFormAttributes.isEmpty()) {\n                    completeUserObject(userTO, selfTO);\n                }\n                // create diff patch\n                UserPatch userPatch = AnyOperations.diff(userTO, selfTO, false);\n                if (userPatch.isEmpty()) {\n                    // nothing to do\n                    buildResponse(response,\n                            Response.Status.OK.getStatusCode(),\n                            \"No need to update [\" + selfTO.getUsername() + \"]\");\n                } else {\n                    // update user by patch\n                    Response coreResponse = SyncopeEnduserSession.get().\n                            getService(userTO.getETagValue(), UserSelfService.class).update(userPatch);\n\n                    buildResponse(response,\n                            coreResponse.getStatus(),\n                            coreResponse.getStatusInfo().getFamily() == Response.Status.Family.SUCCESSFUL\n                            ? \"User [\" + selfTO.getUsername() + \"] successfully updated\"\n                            : \"ErrorMessage{{ \" + coreResponse.getStatusInfo().getReasonPhrase() + \" }}\");\n                }\n            } else {\n                LOG.warn(\n                        \"Incoming update request [{}] is not compliant with form customization rules.\"\n                        + \" Update NOT allowed\", userTO.getUsername());\n                buildResponse(response, Response.Status.OK.getStatusCode(),\n                        \"User: \" + userTO.getUsername() + \" successfully created\");\n            }\n        } catch (final Exception e) {\n            LOG.error(\"Error while updating user\", e);\n            response.setError(Response.Status.BAD_REQUEST.getStatusCode(),\n                    new StringBuilder().\n                            append(\"ErrorMessage{{ \").\n                            append(e.getMessage()).\n                            append(\" }}\").\n                            toString());\n        }\n        return response;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected ResourceResponse newResourceResponse(final IResource.Attributes attributes) {\n        ResourceResponse response = new AbstractResource.ResourceResponse();\n        response.setContentType(MediaType.TEXT_PLAIN);\n        try {\n            HttpServletRequest request = (HttpServletRequest) attributes.getRequest().getContainerRequest();\n            if (!xsrfCheck(request)) {\n                LOG.error(\"XSRF TOKEN does not match\");\n                response.setError(Response.Status.BAD_REQUEST.getStatusCode(), \"XSRF TOKEN does not match\");\n                return response;\n            }\n\n            if (!captchaCheck(\n                    request.getHeader(\"captcha\"),\n                    request.getSession().getAttribute(SyncopeEnduserConstants.CAPTCHA_SESSION_KEY))) {\n\n                throw new IllegalArgumentException(\"Entered captcha is not matching\");\n            }\n\n            UserTO userTO = MAPPER.readValue(request.getReader().readLine(), UserTO.class);\n            Map<String, CustomAttributesInfo> customFormAttributes =\n                    SyncopeEnduserApplication.get().getCustomFormAttributes();\n\n            // check if request is compliant with customization form rules\n            if (Validation.isCompliant(userTO, customFormAttributes, false)) {\n                // 1. membership attributes management\n                Set<AttrTO> membAttrs = new HashSet<>();\n                for (AttrTO attr : userTO.getPlainAttrs()) {\n                    if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                        final String[] compositeSchemaKey = attr.getSchema().split(\n                                SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                        MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                new Predicate<MembershipTO>() {\n\n                            @Override\n                            public boolean evaluate(final MembershipTO item) {\n                                return compositeSchemaKey[0].equals(item.getGroupName());\n                            }\n                        });\n                        if (membership == null) {\n                            membership = new MembershipTO.Builder().group(null, compositeSchemaKey[0]).build();\n                            userTO.getMemberships().add(membership);\n                        }\n                        AttrTO clone = SerializationUtils.clone(attr);\n                        clone.setSchema(compositeSchemaKey[1]);\n                        membership.getPlainAttrs().add(clone);\n                        membAttrs.add(attr);\n                    }\n                }\n                userTO.getPlainAttrs().removeAll(membAttrs);\n\n                // 2. millis -> Date conversion for PLAIN attributes of USER and its MEMBERSHIPS\n                for (PlainSchemaTO plainSchema : SyncopeEnduserSession.get().getDatePlainSchemas()) {\n                    millisToDate(userTO.getPlainAttrs(), plainSchema);\n                    for (MembershipTO membership : userTO.getMemberships()) {\n                        millisToDate(membership.getPlainAttrs(), plainSchema);\n                    }\n                }\n\n                membAttrs.clear();\n                for (AttrTO attr : userTO.getDerAttrs()) {\n                    if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                        final String[] simpleAttrs = attr.getSchema().split(\n                                SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                        MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                new Predicate<MembershipTO>() {\n\n                            @Override\n                            public boolean evaluate(final MembershipTO item) {\n                                return simpleAttrs[0].equals(item.getGroupName());\n                            }\n                        });\n                        if (membership == null) {\n                            membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                            userTO.getMemberships().add(membership);\n                        }\n                        AttrTO clone = SerializationUtils.clone(attr);\n                        clone.setSchema(simpleAttrs[1]);\n                        membership.getDerAttrs().add(clone);\n                        membAttrs.add(attr);\n                    }\n                }\n                userTO.getDerAttrs().removeAll(membAttrs);\n\n                membAttrs.clear();\n                for (AttrTO attr : userTO.getVirAttrs()) {\n                    if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                        final String[] simpleAttrs = attr.getSchema().split(\n                                SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                        MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                new Predicate<MembershipTO>() {\n\n                            @Override\n                            public boolean evaluate(final MembershipTO item) {\n                                return simpleAttrs[0].equals(item.getGroupName());\n                            }\n                        });\n                        if (membership == null) {\n                            membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                            userTO.getMemberships().add(membership);\n\n                        }\n                        AttrTO clone = SerializationUtils.clone(attr);\n                        clone.setSchema(simpleAttrs[1]);\n                        membership.getVirAttrs().add(clone);\n                        membAttrs.add(attr);\n                    }\n                }\n                userTO.getVirAttrs().removeAll(membAttrs);\n\n                // get old user object from session\n                UserTO selfTO = SyncopeEnduserSession.get().getSelfTO();\n                // align \"userTO\" and \"selfTO\" objects\n                if (customFormAttributes != null && !customFormAttributes.isEmpty()) {\n                    completeUserObject(userTO, selfTO);\n                }\n                // create diff patch\n                UserPatch userPatch = AnyOperations.diff(userTO, selfTO, false);\n                if (userPatch.isEmpty()) {\n                    // nothing to do\n                    buildResponse(response,\n                            Response.Status.OK.getStatusCode(),\n                            \"No need to update [\" + selfTO.getUsername() + \"]\");\n                } else {\n                    // update user by patch\n                    Response coreResponse = SyncopeEnduserSession.get().\n                            getService(userTO.getETagValue(), UserSelfService.class).update(userPatch);\n\n                    buildResponse(response,\n                            coreResponse.getStatus(),\n                            coreResponse.getStatusInfo().getFamily() == Response.Status.Family.SUCCESSFUL\n                            ? \"User [\" + selfTO.getUsername() + \"] successfully updated\"\n                            : \"ErrorMessage{{ \" + coreResponse.getStatusInfo().getReasonPhrase() + \" }}\");\n                }\n            } else {\n                LOG.warn(\n                        \"Incoming update request [{}] is not compliant with form customization rules.\"\n                        + \" Update NOT allowed\", userTO.getUsername());\n                buildResponse(response, Response.Status.OK.getStatusCode(),\n                        \"User: \" + userTO.getUsername() + \" successfully created\");\n            }\n        } catch (final Exception e) {\n            LOG.error(\"Error while updating user\", e);\n            response.setError(Response.Status.BAD_REQUEST.getStatusCode(),\n                    new StringBuilder().\n                            append(\"ErrorMessage{{ \").\n                            append(e.getMessage()).\n                            append(\" }}\").\n                            toString());\n        }\n        return response;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected ResourceResponse newResourceResponse(final Attributes attributes) {\n        ResourceResponse response = new ResourceResponse();\n        response.setContentType(MediaType.TEXT_PLAIN);\n        try {\n            HttpServletRequest request = (HttpServletRequest) attributes.getRequest().getContainerRequest();\n\n            if (!xsrfCheck(request)) {\n                LOG.error(\"XSRF TOKEN is not matching\");\n                response.setError(Response.Status.BAD_REQUEST.getStatusCode(), \"XSRF TOKEN is not matching\");\n                return response;\n            }\n\n            String jsonString = request.getReader().readLine();\n            final UserTO userTO = MAPPER.readValue(jsonString, UserTO.class);\n\n            if (!captchaCheck(\n                    request.getHeader(\"captcha\"),\n                    request.getSession().getAttribute(SyncopeEnduserConstants.CAPTCHA_SESSION_KEY))) {\n\n                throw new IllegalArgumentException(\"Entered captcha is not matching\");\n            }\n\n            if (isSelfRegistrationAllowed() && userTO != null) {\n                LOG.debug(\"User self registration request for [{}]\", userTO.getUsername());\n                LOG.trace(\"Request is [{}]\", userTO);\n\n                // check if request is compliant with customization form rules\n                if (UserRequestValidator.compliant(userTO,\n                        SyncopeEnduserApplication.get().getCustomFormAttributes(), true)) {\n\n                    // 1. membership attributes management\n                    Set<AttrTO> membAttrs = new HashSet<>();\n                    for (AttrTO attr : userTO.getPlainAttrs()) {\n                        if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                            final String[] simpleAttrs = attr.getSchema().split(\n                                    SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                            MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                    new Predicate<MembershipTO>() {\n\n                                @Override\n                                public boolean evaluate(final MembershipTO item) {\n                                    return simpleAttrs[0].equals(item.getGroupName());\n                                }\n                            });\n                            if (membership == null) {\n                                membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                                userTO.getMemberships().add(membership);\n                            }\n\n                            AttrTO clone = SerializationUtils.clone(attr);\n                            clone.setSchema(simpleAttrs[1]);\n                            membership.getPlainAttrs().add(clone);\n                            membAttrs.add(attr);\n                        }\n                    }\n                    userTO.getPlainAttrs().removeAll(membAttrs);\n\n                    // 2. millis -> Date conversion for PLAIN attributes of USER and its MEMBERSHIPS\n                    for (PlainSchemaTO plainSchema : SyncopeEnduserSession.get().getDatePlainSchemas()) {\n                        millisToDate(userTO.getPlainAttrs(), plainSchema);\n                        for (MembershipTO membership : userTO.getMemberships()) {\n                            millisToDate(membership.getPlainAttrs(), plainSchema);\n                        }\n                    }\n\n                    membAttrs.clear();\n                    for (AttrTO attr : userTO.getDerAttrs()) {\n                        if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                            final String[] simpleAttrs = attr.getSchema().split(\n                                    SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                            MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                    new Predicate<MembershipTO>() {\n\n                                @Override\n                                public boolean evaluate(final MembershipTO item) {\n                                    return simpleAttrs[0].equals(item.getGroupName());\n                                }\n                            });\n                            if (membership == null) {\n                                membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                                userTO.getMemberships().add(membership);\n                            }\n\n                            AttrTO clone = SerializationUtils.clone(attr);\n                            clone.setSchema(simpleAttrs[1]);\n                            membership.getDerAttrs().add(clone);\n                            membAttrs.add(attr);\n                        }\n                    }\n                    userTO.getDerAttrs().removeAll(membAttrs);\n\n                    membAttrs.clear();\n                    for (AttrTO attr : userTO.getVirAttrs()) {\n                        if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                            final String[] simpleAttrs = attr.getSchema().split(\n                                    SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                            MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                    new Predicate<MembershipTO>() {\n\n                                @Override\n                                public boolean evaluate(final MembershipTO item) {\n                                    return simpleAttrs[0].equals(item.getGroupName());\n                                }\n                            });\n                            if (membership == null) {\n                                membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                                userTO.getMemberships().add(membership);\n                            }\n\n                            AttrTO clone = SerializationUtils.clone(attr);\n                            clone.setSchema(simpleAttrs[1]);\n                            membership.getVirAttrs().add(clone);\n                            membAttrs.add(attr);\n                        }\n                    }\n                    userTO.getVirAttrs().removeAll(membAttrs);\n\n                    LOG.debug(\"Received user self registration request for user: [{}]\", userTO.getUsername());\n                    LOG.trace(\"Received user self registration request is: [{}]\", userTO);\n\n                    // adapt request and create user\n                    final Response res = SyncopeEnduserSession.get().getService(UserSelfService.class).create(userTO,\n                            true);\n\n                    buildResponse(response, res.getStatus(),\n                            Response.Status.Family.SUCCESSFUL.equals(res.getStatusInfo().getFamily())\n                            ? \"User[ \" + userTO.getUsername() + \"] successfully created\"\n                            : \"ErrorMessage{{ \" + res.getStatusInfo().getReasonPhrase() + \" }}\");\n                } else {\n                    LOG.warn(\n                            \"Incoming create request [{}] is not compliant with form customization rules. \"\n                            + \"Create NOT allowed\", userTO.getUsername());\n                    buildResponse(response, Response.Status.OK.getStatusCode(),\n                            \"User: \" + userTO.getUsername() + \" successfully created\");\n                }\n            } else {\n                response.setError(Response.Status.FORBIDDEN.getStatusCode(), new StringBuilder().\n                        append(\"ErrorMessage{{\").append(userTO == null\n                        ? \"Request received is not valid }}\"\n                        : \"Self registration not allowed }}\").toString());\n            }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected ResourceResponse newResourceResponse(final Attributes attributes) {\n        ResourceResponse response = new ResourceResponse();\n        response.setContentType(MediaType.TEXT_PLAIN);\n        try {\n            HttpServletRequest request = (HttpServletRequest) attributes.getRequest().getContainerRequest();\n\n            if (!xsrfCheck(request)) {\n                LOG.error(\"XSRF TOKEN is not matching\");\n                response.setError(Response.Status.BAD_REQUEST.getStatusCode(), \"XSRF TOKEN is not matching\");\n                return response;\n            }\n\n            String jsonString = request.getReader().readLine();\n            final UserTO userTO = MAPPER.readValue(jsonString, UserTO.class);\n\n            if (!captchaCheck(\n                    request.getHeader(\"captcha\"),\n                    request.getSession().getAttribute(SyncopeEnduserConstants.CAPTCHA_SESSION_KEY))) {\n\n                throw new IllegalArgumentException(\"Entered captcha is not matching\");\n            }\n\n            if (isSelfRegistrationAllowed() && userTO != null) {\n                LOG.debug(\"User self registration request for [{}]\", userTO.getUsername());\n                LOG.trace(\"Request is [{}]\", userTO);\n\n                // check if request is compliant with customization form rules\n                if (Validation.isCompliant(userTO,\n                        SyncopeEnduserApplication.get().getCustomFormAttributes(), true)) {\n\n                    // 1. membership attributes management\n                    Set<AttrTO> membAttrs = new HashSet<>();\n                    for (AttrTO attr : userTO.getPlainAttrs()) {\n                        if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                            final String[] simpleAttrs = attr.getSchema().split(\n                                    SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                            MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                    new Predicate<MembershipTO>() {\n\n                                @Override\n                                public boolean evaluate(final MembershipTO item) {\n                                    return simpleAttrs[0].equals(item.getGroupName());\n                                }\n                            });\n                            if (membership == null) {\n                                membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                                userTO.getMemberships().add(membership);\n                            }\n\n                            AttrTO clone = SerializationUtils.clone(attr);\n                            clone.setSchema(simpleAttrs[1]);\n                            membership.getPlainAttrs().add(clone);\n                            membAttrs.add(attr);\n                        }\n                    }\n                    userTO.getPlainAttrs().removeAll(membAttrs);\n\n                    // 2. millis -> Date conversion for PLAIN attributes of USER and its MEMBERSHIPS\n                    for (PlainSchemaTO plainSchema : SyncopeEnduserSession.get().getDatePlainSchemas()) {\n                        millisToDate(userTO.getPlainAttrs(), plainSchema);\n                        for (MembershipTO membership : userTO.getMemberships()) {\n                            millisToDate(membership.getPlainAttrs(), plainSchema);\n                        }\n                    }\n\n                    membAttrs.clear();\n                    for (AttrTO attr : userTO.getDerAttrs()) {\n                        if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                            final String[] simpleAttrs = attr.getSchema().split(\n                                    SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                            MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                    new Predicate<MembershipTO>() {\n\n                                @Override\n                                public boolean evaluate(final MembershipTO item) {\n                                    return simpleAttrs[0].equals(item.getGroupName());\n                                }\n                            });\n                            if (membership == null) {\n                                membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                                userTO.getMemberships().add(membership);\n                            }\n\n                            AttrTO clone = SerializationUtils.clone(attr);\n                            clone.setSchema(simpleAttrs[1]);\n                            membership.getDerAttrs().add(clone);\n                            membAttrs.add(attr);\n                        }\n                    }\n                    userTO.getDerAttrs().removeAll(membAttrs);\n\n                    membAttrs.clear();\n                    for (AttrTO attr : userTO.getVirAttrs()) {\n                        if (attr.getSchema().contains(SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR)) {\n                            final String[] simpleAttrs = attr.getSchema().split(\n                                    SyncopeEnduserConstants.MEMBERSHIP_ATTR_SEPARATOR);\n                            MembershipTO membership = IterableUtils.find(userTO.getMemberships(),\n                                    new Predicate<MembershipTO>() {\n\n                                @Override\n                                public boolean evaluate(final MembershipTO item) {\n                                    return simpleAttrs[0].equals(item.getGroupName());\n                                }\n                            });\n                            if (membership == null) {\n                                membership = new MembershipTO.Builder().group(null, simpleAttrs[0]).build();\n                                userTO.getMemberships().add(membership);\n                            }\n\n                            AttrTO clone = SerializationUtils.clone(attr);\n                            clone.setSchema(simpleAttrs[1]);\n                            membership.getVirAttrs().add(clone);\n                            membAttrs.add(attr);\n                        }\n                    }\n                    userTO.getVirAttrs().removeAll(membAttrs);\n\n                    LOG.debug(\"Received user self registration request for user: [{}]\", userTO.getUsername());\n                    LOG.trace(\"Received user self registration request is: [{}]\", userTO);\n\n                    // adapt request and create user\n                    final Response res = SyncopeEnduserSession.get().getService(UserSelfService.class).create(userTO,\n                            true);\n\n                    buildResponse(response, res.getStatus(),\n                            Response.Status.Family.SUCCESSFUL.equals(res.getStatusInfo().getFamily())\n                            ? \"User[ \" + userTO.getUsername() + \"] successfully created\"\n                            : \"ErrorMessage{{ \" + res.getStatusInfo().getReasonPhrase() + \" }}\");\n                } else {\n                    LOG.warn(\n                            \"Incoming create request [{}] is not compliant with form customization rules. \"\n                            + \"Create NOT allowed\", userTO.getUsername());\n                    buildResponse(response, Response.Status.OK.getStatusCode(),\n                            \"User: \" + userTO.getUsername() + \" successfully created\");\n                }\n            } else {\n                response.setError(Response.Status.FORBIDDEN.getStatusCode(), new StringBuilder().\n                        append(\"ErrorMessage{{\").append(userTO == null\n                        ? \"Request received is not valid }}\"\n                        : \"Self registration not allowed }}\").toString());\n            }",
    "is_vulnerable": false
  },
  {
    "function_code": "private SaltGenerator() {\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private SaltGenerator() {\n        // private constructor for static utility class\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String toOperationId(String operationId) {\n        //rename to empty_function_name_1 (e.g.) if method name is empty\n        if (StringUtils.isEmpty(operationId)) {\n            operationId = underscore(\"empty_function_name_\" + emptyFunctionNameCounter++);\n            LOGGER.warn(\"Empty method name (operationId) found. Renamed to \" + operationId);\n            return operationId;\n        }\n\n        // method name cannot use reserved keyword, e.g. return\n        if (isReservedWord(operationId)) {\n            LOGGER.warn(operationId + \" (reserved word) cannot be used as method name. Renamed to \" + underscore(\"call_\" + operationId));\n            return underscore(\"call_\" + operationId);\n        }\n\n        return underscore(operationId);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String toOperationId(String operationId) {\n        //rename to empty_function_name_1 (e.g.) if method name is empty\n        if (StringUtils.isEmpty(operationId)) {\n            operationId = underscore(\"empty_function_name_\" + emptyFunctionNameCounter++);\n            LOGGER.warn(\"Empty method name (operationId) found. Renamed to \" + operationId);\n            return operationId;\n        }\n\n        // method name cannot use reserved keyword, e.g. return\n        if (isReservedWord(operationId)) {\n            LOGGER.warn(operationId + \" (reserved word) cannot be used as method name. Renamed to \" + underscore(\"call_\" + operationId));\n            return underscore(\"call_\" + operationId);\n        }\n\n        //return underscore(operationId).replaceAll(\"[^A-Za-z0-9_]\", \"\");\n        return underscore(sanitizeName(operationId));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void preprocessSwagger(Swagger swagger) {\n        super.preprocessSwagger(swagger);\n\n        if (swagger.getInfo() != null) {\n            Info info = swagger.getInfo();\n            if (StringUtils.isBlank(projectName) && info.getTitle() != null) {\n                // when projectName is not specified, generate it from info.title\n                projectName = dashize(info.getTitle());\n            }\n            if (StringUtils.isBlank(projectVersion)) {\n                // when projectVersion is not specified, use info.version\n                projectVersion = info.getVersion();\n            }\n            if (projectDescription == null) {\n                // when projectDescription is not specified, use info.description\n                projectDescription = info.getDescription();\n            }\n            if (additionalProperties.get(PROJECT_LICENSE_NAME) == null) {\n                // when projectLicense is not specified, use info.license\n                if (info.getLicense() != null) {\n                    License license = info.getLicense();\n                    additionalProperties.put(PROJECT_LICENSE_NAME, license.getName());\n                }\n            }\n        }\n\n        // default values\n        if (StringUtils.isBlank(projectName)) {\n            projectName = \"swagger-js-client\";\n        }\n        if (StringUtils.isBlank(moduleName)) {\n            moduleName = camelize(underscore(projectName));\n        }\n        if (StringUtils.isBlank(projectVersion)) {\n            projectVersion = \"1.0.0\";\n        }\n        if (projectDescription == null) {\n            projectDescription = \"Client library of \" + projectName;\n        }\n\n        additionalProperties.put(PROJECT_NAME, projectName);\n        additionalProperties.put(MODULE_NAME, moduleName);\n        additionalProperties.put(PROJECT_DESCRIPTION, escapeText(projectDescription));\n        additionalProperties.put(PROJECT_VERSION, projectVersion);\n        additionalProperties.put(CodegenConstants.API_PACKAGE, apiPackage);\n        additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n        additionalProperties.put(CodegenConstants.LOCAL_VARIABLE_PREFIX, localVariablePrefix);\n        additionalProperties.put(CodegenConstants.MODEL_PACKAGE, modelPackage);\n        additionalProperties.put(CodegenConstants.SOURCE_FOLDER, sourceFolder);\n        additionalProperties.put(USE_PROMISES, usePromises);\n        additionalProperties.put(USE_INHERITANCE, supportsInheritance);\n        additionalProperties.put(EMIT_MODEL_METHODS, emitModelMethods);\n        additionalProperties.put(EMIT_JS_DOC, emitJSDoc);\n\n        // make api and model doc path available in mustache template\n        additionalProperties.put(\"apiDocPath\", apiDocPath);\n        additionalProperties.put(\"modelDocPath\", modelDocPath);\n\n        supportingFiles.add(new SupportingFile(\"package.mustache\", \"\", \"package.json\"));\n        supportingFiles.add(new SupportingFile(\"index.mustache\", createPath(sourceFolder, invokerPackage), \"index.js\"));\n        supportingFiles.add(new SupportingFile(\"ApiClient.mustache\", createPath(sourceFolder, invokerPackage), \"ApiClient.js\"));\n        supportingFiles.add(new SupportingFile(\"git_push.sh.mustache\", \"\", \"git_push.sh\"));\n        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n        supportingFiles.add(new SupportingFile(\"mocha.opts\", \"\", \"mocha.opts\"));\n        supportingFiles.add(new SupportingFile(\"travis.yml\", \"\", \".travis.yml\"));\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void preprocessSwagger(Swagger swagger) {\n        super.preprocessSwagger(swagger);\n\n        if (swagger.getInfo() != null) {\n            Info info = swagger.getInfo();\n            if (StringUtils.isBlank(projectName) && info.getTitle() != null) {\n                // when projectName is not specified, generate it from info.title\n                projectName = sanitizeName(dashize(info.getTitle()));\n            }\n            if (StringUtils.isBlank(projectVersion)) {\n                // when projectVersion is not specified, use info.version\n                projectVersion = escapeUnsafeCharacters(escapeQuotationMark(info.getVersion()));\n            }\n            if (projectDescription == null) {\n                // when projectDescription is not specified, use info.description\n                projectDescription = sanitizeName(info.getDescription());\n            }\n            if (additionalProperties.get(PROJECT_LICENSE_NAME) == null) {\n                // when projectLicense is not specified, use info.license\n                if (info.getLicense() != null) {\n                    License license = info.getLicense();\n                    additionalProperties.put(PROJECT_LICENSE_NAME, sanitizeName(license.getName()));\n                }\n            }\n        }\n\n        // default values\n        if (StringUtils.isBlank(projectName)) {\n            projectName = \"swagger-js-client\";\n        }\n        if (StringUtils.isBlank(moduleName)) {\n            moduleName = camelize(underscore(projectName));\n        }\n        if (StringUtils.isBlank(projectVersion)) {\n            projectVersion = \"1.0.0\";\n        }\n        if (projectDescription == null) {\n            projectDescription = \"Client library of \" + projectName;\n        }\n\n        additionalProperties.put(PROJECT_NAME, projectName);\n        additionalProperties.put(MODULE_NAME, moduleName);\n        additionalProperties.put(PROJECT_DESCRIPTION, escapeText(projectDescription));\n        additionalProperties.put(PROJECT_VERSION, projectVersion);\n        additionalProperties.put(CodegenConstants.API_PACKAGE, apiPackage);\n        additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);\n        additionalProperties.put(CodegenConstants.LOCAL_VARIABLE_PREFIX, localVariablePrefix);\n        additionalProperties.put(CodegenConstants.MODEL_PACKAGE, modelPackage);\n        additionalProperties.put(CodegenConstants.SOURCE_FOLDER, sourceFolder);\n        additionalProperties.put(USE_PROMISES, usePromises);\n        additionalProperties.put(USE_INHERITANCE, supportsInheritance);\n        additionalProperties.put(EMIT_MODEL_METHODS, emitModelMethods);\n        additionalProperties.put(EMIT_JS_DOC, emitJSDoc);\n\n        // make api and model doc path available in mustache template\n        additionalProperties.put(\"apiDocPath\", apiDocPath);\n        additionalProperties.put(\"modelDocPath\", modelDocPath);\n\n        supportingFiles.add(new SupportingFile(\"package.mustache\", \"\", \"package.json\"));\n        supportingFiles.add(new SupportingFile(\"index.mustache\", createPath(sourceFolder, invokerPackage), \"index.js\"));\n        supportingFiles.add(new SupportingFile(\"ApiClient.mustache\", createPath(sourceFolder, invokerPackage), \"ApiClient.js\"));\n        supportingFiles.add(new SupportingFile(\"git_push.sh.mustache\", \"\", \"git_push.sh\"));\n        supportingFiles.add(new SupportingFile(\"README.mustache\", \"\", \"README.md\"));\n        supportingFiles.add(new SupportingFile(\"mocha.opts\", \"\", \"mocha.opts\"));\n        supportingFiles.add(new SupportingFile(\"travis.yml\", \"\", \".travis.yml\"));\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(IIOPRootDefinition.INSTANCE);\n        subsystemRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        subsystem.registerXMLElementWriter(new IIOPSubsystemParser_2_0());\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, CURRENT_MODEL_VERSION);\n        final ManagementResourceRegistration subsystemRegistration = subsystem.registerSubsystemModel(IIOPRootDefinition.INSTANCE);\n        subsystemRegistration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        subsystem.registerXMLElementWriter(new IIOPSubsystemParser_2_1());\n\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME,Namespace.IIOP_OPENJDK_1_0.getUriString(), IIOPSubsystemParser_1::new);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME,Namespace.IIOP_OPENJDK_2_0.getUriString(), IIOPSubsystemParser_2_0::new);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME,Namespace.IIOP_OPENJDK_1_0.getUriString(), IIOPSubsystemParser_1::new);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME,Namespace.IIOP_OPENJDK_2_0.getUriString(), IIOPSubsystemParser_2_0::new);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME,Namespace.IIOP_OPENJDK_2_1.getUriString(), IIOPSubsystemParser_2_1::new);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void run() {\n        try {\n            mcs.joinGroup(MULTICAST);\n            ready.signal();\n\n            while(true) {\n                byte[] buf = new byte[2048];\n                DatagramPacket p = new DatagramPacket(buf,buf.length);\n                mcs.receive(p);\n\n                SocketAddress sender = p.getSocketAddress();\n\n                // prepare a response\n                TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n\n                StringBuilder rsp = new StringBuilder(\"<hudson>\");\n                tag(rsp,\"version\", Jenkins.VERSION);\n                tag(rsp,\"url\", jenkins.getRootUrl());\n                tag(rsp,\"server-id\", Util.getDigestOf(jenkins.getSecretKey()));\n                tag(rsp,\"slave-port\",tal==null?null:tal.getPort());\n\n                for (UDPBroadcastFragment f : UDPBroadcastFragment.all())\n                    f.buildFragment(rsp,sender);\n\n                rsp.append(\"</hudson>\");\n\n                byte[] response = rsp.toString().getBytes(\"UTF-8\");\n                mcs.send(new DatagramPacket(response,response.length,sender));\n            }\n        } catch (ClosedByInterruptException e) {\n            // shut down\n        } catch (BindException e) {\n            // if we failed to listen to UDP, just silently abandon it, as a stack trace\n            // makes people unnecessarily concerned, for a feature that currently does no good.\n            LOGGER.log(Level.WARNING, \"Failed to listen to UDP port \"+PORT,e);\n        } catch (IOException e) {\n            if (shutdown)   return; // forcibly closed\n            LOGGER.log(Level.WARNING, \"UDP handling problem\",e);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public void run() {\n        try {\n            mcs.joinGroup(MULTICAST);\n            ready.signal();\n\n            while(true) {\n                byte[] buf = new byte[2048];\n                DatagramPacket p = new DatagramPacket(buf,buf.length);\n                mcs.receive(p);\n\n                SocketAddress sender = p.getSocketAddress();\n\n                // prepare a response\n                TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n\n                StringBuilder rsp = new StringBuilder(\"<hudson>\");\n                tag(rsp,\"version\", Jenkins.VERSION);\n                tag(rsp,\"url\", jenkins.getRootUrl());\n                tag(rsp,\"server-id\", jenkins.getLegacyInstanceId());\n                tag(rsp,\"slave-port\",tal==null?null:tal.getPort());\n\n                for (UDPBroadcastFragment f : UDPBroadcastFragment.all())\n                    f.buildFragment(rsp,sender);\n\n                rsp.append(\"</hudson>\");\n\n                byte[] response = rsp.toString().getBytes(\"UTF-8\");\n                mcs.send(new DatagramPacket(response,response.length,sender));\n            }\n        } catch (ClosedByInterruptException e) {\n            // shut down\n        } catch (BindException e) {\n            // if we failed to listen to UDP, just silently abandon it, as a stack trace\n            // makes people unnecessarily concerned, for a feature that currently does no good.\n            LOGGER.log(Level.WARNING, \"Failed to listen to UDP port \"+PORT,e);\n        } catch (IOException e) {\n            if (shutdown)   return; // forcibly closed\n            LOGGER.log(Level.WARNING, \"UDP handling problem\",e);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DNSMultiCast(final Jenkins jenkins) {\n        if (disabled)   return; // escape hatch\n        \n        // the registerService call can be slow. run these asynchronously\n        MasterComputer.threadPoolForRemoting.submit(new Callable<Object>() {\n            public Object call() {\n                try {\n                    jmdns = JmDNS.create();\n\n                    Map<String,String> props = new HashMap<String, String>();\n                    String rootURL = jenkins.getRootUrl();\n                    if (rootURL==null)  return null;\n\n                    props.put(\"url\", rootURL);\n                    try {\n                        props.put(\"version\",String.valueOf(Jenkins.getVersion()));\n                    } catch (IllegalArgumentException e) {\n                        // failed to parse the version number\n                    }\n\n                    TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n                    if (tal!=null)\n                        props.put(\"slave-port\",String.valueOf(tal.getPort()));\n\n                    props.put(\"server-id\", Util.getDigestOf(jenkins.getSecretKey()));\n\n                    URL jenkins_url = new URL(rootURL);\n                    int jenkins_port = jenkins_url.getPort();\n                    if (jenkins_port == -1) {\n                        jenkins_port = 80;\n                    }\n                    if (jenkins_url.getPath().length() > 0) {\n                        props.put(\"path\", jenkins_url.getPath());\n                    }\n\n                    jmdns.registerService(ServiceInfo.create(\"_hudson._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\t// for backward compatibility\n                    jmdns.registerService(ServiceInfo.create(\"_jenkins._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\n\n                    // Make Jenkins appear in Safari's Bonjour bookmarks\n                    jmdns.registerService(ServiceInfo.create(\"_http._tcp.local.\",\"Jenkins\",\n                            jenkins_port,0,0,props));\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING,\"Failed to advertise the service to DNS multi-cast\",e);\n                }\n                return null;\n            }\n        });\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DNSMultiCast(final Jenkins jenkins) {\n        if (disabled)   return; // escape hatch\n        \n        // the registerService call can be slow. run these asynchronously\n        MasterComputer.threadPoolForRemoting.submit(new Callable<Object>() {\n            public Object call() {\n                try {\n                    jmdns = JmDNS.create();\n\n                    Map<String,String> props = new HashMap<String, String>();\n                    String rootURL = jenkins.getRootUrl();\n                    if (rootURL==null)  return null;\n\n                    props.put(\"url\", rootURL);\n                    try {\n                        props.put(\"version\",String.valueOf(Jenkins.getVersion()));\n                    } catch (IllegalArgumentException e) {\n                        // failed to parse the version number\n                    }\n\n                    TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n                    if (tal!=null)\n                        props.put(\"slave-port\",String.valueOf(tal.getPort()));\n\n                    props.put(\"server-id\", jenkins.getLegacyInstanceId());\n\n                    URL jenkins_url = new URL(rootURL);\n                    int jenkins_port = jenkins_url.getPort();\n                    if (jenkins_port == -1) {\n                        jenkins_port = 80;\n                    }\n                    if (jenkins_url.getPath().length() > 0) {\n                        props.put(\"path\", jenkins_url.getPath());\n                    }\n\n                    jmdns.registerService(ServiceInfo.create(\"_hudson._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\t// for backward compatibility\n                    jmdns.registerService(ServiceInfo.create(\"_jenkins._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\n\n                    // Make Jenkins appear in Safari's Bonjour bookmarks\n                    jmdns.registerService(ServiceInfo.create(\"_http._tcp.local.\",\"Jenkins\",\n                            jenkins_port,0,0,props));\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING,\"Failed to advertise the service to DNS multi-cast\",e);\n                }\n                return null;\n            }\n        });\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Object call() {\n                try {\n                    jmdns = JmDNS.create();\n\n                    Map<String,String> props = new HashMap<String, String>();\n                    String rootURL = jenkins.getRootUrl();\n                    if (rootURL==null)  return null;\n\n                    props.put(\"url\", rootURL);\n                    try {\n                        props.put(\"version\",String.valueOf(Jenkins.getVersion()));\n                    } catch (IllegalArgumentException e) {\n                        // failed to parse the version number\n                    }\n\n                    TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n                    if (tal!=null)\n                        props.put(\"slave-port\",String.valueOf(tal.getPort()));\n\n                    props.put(\"server-id\", Util.getDigestOf(jenkins.getSecretKey()));\n\n                    URL jenkins_url = new URL(rootURL);\n                    int jenkins_port = jenkins_url.getPort();\n                    if (jenkins_port == -1) {\n                        jenkins_port = 80;\n                    }\n                    if (jenkins_url.getPath().length() > 0) {\n                        props.put(\"path\", jenkins_url.getPath());\n                    }\n\n                    jmdns.registerService(ServiceInfo.create(\"_hudson._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\t// for backward compatibility\n                    jmdns.registerService(ServiceInfo.create(\"_jenkins._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\n\n                    // Make Jenkins appear in Safari's Bonjour bookmarks\n                    jmdns.registerService(ServiceInfo.create(\"_http._tcp.local.\",\"Jenkins\",\n                            jenkins_port,0,0,props));\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING,\"Failed to advertise the service to DNS multi-cast\",e);\n                }\n                return null;\n            }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Object call() {\n                try {\n                    jmdns = JmDNS.create();\n\n                    Map<String,String> props = new HashMap<String, String>();\n                    String rootURL = jenkins.getRootUrl();\n                    if (rootURL==null)  return null;\n\n                    props.put(\"url\", rootURL);\n                    try {\n                        props.put(\"version\",String.valueOf(Jenkins.getVersion()));\n                    } catch (IllegalArgumentException e) {\n                        // failed to parse the version number\n                    }\n\n                    TcpSlaveAgentListener tal = jenkins.getTcpSlaveAgentListener();\n                    if (tal!=null)\n                        props.put(\"slave-port\",String.valueOf(tal.getPort()));\n\n                    props.put(\"server-id\", jenkins.getLegacyInstanceId());\n\n                    URL jenkins_url = new URL(rootURL);\n                    int jenkins_port = jenkins_url.getPort();\n                    if (jenkins_port == -1) {\n                        jenkins_port = 80;\n                    }\n                    if (jenkins_url.getPath().length() > 0) {\n                        props.put(\"path\", jenkins_url.getPath());\n                    }\n\n                    jmdns.registerService(ServiceInfo.create(\"_hudson._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\t// for backward compatibility\n                    jmdns.registerService(ServiceInfo.create(\"_jenkins._tcp.local.\",\"jenkins\",\n                            jenkins_port,0,0,props));\n\n                    // Make Jenkins appear in Safari's Bonjour bookmarks\n                    jmdns.registerService(ServiceInfo.create(\"_http._tcp.local.\",\"Jenkins\",\n                            jenkins_port,0,0,props));\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING,\"Failed to advertise the service to DNS multi-cast\",e);\n                }\n                return null;\n            }",
    "is_vulnerable": false
  },
  {
    "function_code": "protected String makeTokenSignature(long tokenExpiryTime, UserDetails userDetails) {\n        String expectedTokenSignature = DigestUtils.md5Hex(userDetails.getUsername() + \":\" + tokenExpiryTime + \":\"\n                + \"N/A\" + \":\" + getKey());\n        return expectedTokenSignature;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected String makeTokenSignature(long tokenExpiryTime, UserDetails userDetails) {\n        String expectedTokenSignature = MAC.mac(userDetails.getUsername() + \":\" + tokenExpiryTime + \":\"\n                + \"N/A\" + \":\" + getKey());\n        return expectedTokenSignature;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private static RememberMeServices createRememberMeService(UserDetailsService uds) {\n            // create our default TokenBasedRememberMeServices, which depends on the availability of the secret key\n            TokenBasedRememberMeServices2 rms = new TokenBasedRememberMeServices2();\n            rms.setUserDetailsService(uds);\n            rms.setKey(Jenkins.getInstance().getSecretKey());\n            rms.setParameter(\"remember_me\"); // this is the form field name in login.jelly\n            return rms;\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "private static RememberMeServices createRememberMeService(UserDetailsService uds) {\n            // create our default TokenBasedRememberMeServices, which depends on the availability of the secret key\n            TokenBasedRememberMeServices2 rms = new TokenBasedRememberMeServices2();\n            rms.setUserDetailsService(uds);\n            /*\n                TokenBasedRememberMeServices needs to be used in conjunction with RememberMeAuthenticationProvider,\n                and both needs to use the same key (this is a reflection of a poor design in AcgeiSecurity, if you ask me)\n                and various security plugins have its own groovy script that configures them.\n\n                So if we change this, it creates a painful situation for those plugins by forcing them to choose\n                to work with earlier version of Jenkins or newer version of Jenkins, and not both.\n\n                So we keep this here.\n             */\n            rms.setKey(Jenkins.getInstance().getSecretKey());\n            rms.setParameter(\"remember_me\"); // this is the form field name in login.jelly\n            return rms;\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public DescriptorImpl() {\n            super(Jenkins.getInstance().getSecretKey(), System.getProperty(\"hudson.security.csrf.requestfield\", \".crumb\"));\n            load();\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public DescriptorImpl() {\n            // salt just needs to be unique, and it doesn't have to be a secret\n            super(Jenkins.getInstance().getLegacyInstanceId(), System.getProperty(\"hudson.security.csrf.requestfield\", \".crumb\"));\n            load();\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                // we went too far into the future\n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   // this field is already in a good shape. move on to next\n\n                // we are modifying this field, so clear all the lower level fields\n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    // we need to roll over to the next field.\n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    // since higher order field is affected by this, we need to restart from all over\n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    //check if value was actually set\n                    if (f.valueOf(cal) != next) {\n                        // we need to roll over to the next field.\n                        f.rollUp(cal, 1);\n                        f.setTo(cal,f.first(this));\n                        // since higher order field is affected by this, we need to restart from all over\n                        continue OUTER;\n                    }\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; // when we modify DAY_OF_MONTH and DAY_OF_WEEK, do it all over from the top\n                }\n            }\n            return cal; // all fields adjusted\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public EnvVars getCharacteristicEnvVars() {\n        EnvVars env = new EnvVars();\n        env.put(\"JENKINS_SERVER_COOKIE\",Util.getDigestOf(\"ServerID:\"+ Jenkins.getInstance().getSecretKey()));\n        env.put(\"HUDSON_SERVER_COOKIE\",Util.getDigestOf(\"ServerID:\"+ Jenkins.getInstance().getSecretKey())); // Legacy compatibility\n        env.put(\"JOB_NAME\",getFullName());\n        return env;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public EnvVars getCharacteristicEnvVars() {\n        EnvVars env = new EnvVars();\n        env.put(\"JENKINS_SERVER_COOKIE\",SERVER_COOKIE.get());\n        env.put(\"HUDSON_SERVER_COOKIE\",SERVER_COOKIE.get()); // Legacy compatibility\n        env.put(\"JOB_NAME\",getFullName());\n        return env;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getWhyKeepLog() {\n        // if any of the downstream project is configured with 'keep dependency component',\n        // we need to keep this log\n        OUTER:\n        for (AbstractProject<?,?> p : getParent().getDownstreamProjects()) {\n            if (!p.isKeepDependencies()) continue;\n\n            AbstractBuild<?,?> fb = p.getFirstBuild();\n            if (fb==null)        continue; // no active record\n\n            // is there any active build that depends on us?\n            for (int i : getDownstreamRelationship(p).listNumbersReverse()) {\n                // TODO: this is essentially a \"find intersection between two sparse sequences\"\n                // and we should be able to do much better.\n\n                if (i<fb.getNumber())\n                    continue OUTER; // all the other records are younger than the first record, so pointless to search.\n\n                AbstractBuild<?,?> b = p.getBuildByNumber(i);\n                if (b!=null)\n                    return Messages.AbstractBuild_KeptBecause(b);\n            }\n        }\n\n        return super.getWhyKeepLog();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getWhyKeepLog() {\n        // if any of the downstream project is configured with 'keep dependency component',\n        // we need to keep this log\n        OUTER:\n        for (AbstractProject<?,?> p : getParent().getDownstreamProjects()) {\n            if (!p.isKeepDependencies()) continue;\n\n            AbstractBuild<?,?> fb = p.getFirstBuild();\n            if (fb==null)        continue; // no active record\n\n            // is there any active build that depends on us?\n            for (int i : getDownstreamRelationship(p).listNumbersReverse()) {\n                // TODO: this is essentially a \"find intersection between two sparse sequences\"\n                // and we should be able to do much better.\n\n                if (i<fb.getNumber())\n                    continue OUTER; // all the other records are younger than the first record, so pointless to search.\n\n                AbstractBuild<?,?> b = p.getBuildByNumber(i);\n                if (b!=null)\n                    return Messages.AbstractBuild_KeptBecause(p.hasPermission(Item.READ) ? b.toString() : \"?\");\n            }\n        }\n\n        return super.getWhyKeepLog();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public BuildWrapper createBuildWrapper(AbstractBuild<?,?> build) {\n        return new BuildWrapper() {\n            @Override\n            public Environment setUp(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {\n            \tif (!StringUtils.isEmpty(location) && !StringUtils.isEmpty(file.getName())) {\n            \t    listener.getLogger().println(\"Copying file to \"+location);\n                    FilePath locationFilePath = build.getWorkspace().child(location);\n                    locationFilePath.getParent().mkdirs();\n            \t    locationFilePath.copyFrom(file);\n                    locationFilePath.copyTo(new FilePath(getLocationUnderBuild(build)));\n            \t}\n                return new Environment() {};\n            }\n        };\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public BuildWrapper createBuildWrapper(AbstractBuild<?,?> build) {\n        return new BuildWrapper() {\n            @Override\n            public Environment setUp(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {\n            \tif (!StringUtils.isEmpty(location) && !StringUtils.isEmpty(file.getName())) {\n            \t    listener.getLogger().println(\"Copying file to \"+location);\n                    FilePath ws = build.getWorkspace();\n                    if (ws == null) {\n                        throw new IllegalStateException(\"The workspace should be created when setUp method is called\");\n                    }\n                    if (!ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE && !ws.isDescendant(location)) {\n                        listener.error(\"Rejecting file path escaping base directory with relative path: \" + location);\n                        // force the build to fail\n                        return null;\n                    }\n                    FilePath locationFilePath = ws.child(location);\n                    locationFilePath.getParent().mkdirs();\n            \t    locationFilePath.copyFrom(file);\n                    locationFilePath.copyTo(new FilePath(getLocationUnderBuild(build)));\n            \t}\n                return new Environment() {};\n            }\n        };\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "new BuildWrapper() {\n            @Override\n            public Environment setUp(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {\n            \tif (!StringUtils.isEmpty(location) && !StringUtils.isEmpty(file.getName())) {\n            \t    listener.getLogger().println(\"Copying file to \"+location);\n                    FilePath locationFilePath = build.getWorkspace().child(location);\n                    locationFilePath.getParent().mkdirs();\n            \t    locationFilePath.copyFrom(file);\n                    locationFilePath.copyTo(new FilePath(getLocationUnderBuild(build)));\n            \t}\n                return new Environment() {};\n            }\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "new BuildWrapper() {\n            @Override\n            public Environment setUp(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException, InterruptedException {\n            \tif (!StringUtils.isEmpty(location) && !StringUtils.isEmpty(file.getName())) {\n            \t    listener.getLogger().println(\"Copying file to \"+location);\n                    FilePath ws = build.getWorkspace();\n                    if (ws == null) {\n                        throw new IllegalStateException(\"The workspace should be created when setUp method is called\");\n                    }\n                    if (!ALLOW_FOLDER_TRAVERSAL_OUTSIDE_WORKSPACE && !ws.isDescendant(location)) {\n                        listener.error(\"Rejecting file path escaping base directory with relative path: \" + location);\n                        // force the build to fail\n                        return null;\n                    }\n                    FilePath locationFilePath = ws.child(location);\n                    locationFilePath.getParent().mkdirs();\n            \t    locationFilePath.copyFrom(file);\n                    locationFilePath.copyTo(new FilePath(getLocationUnderBuild(build)));\n            \t}\n                return new Environment() {};\n            }\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "private File getLocationUnderBuild(AbstractBuild build) {\n        return new File(build.getRootDir(), \"fileParameters/\" + location);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private File getLocationUnderBuild(AbstractBuild build) {\n        return new File(getFileParameterFolderUnderBuild(build), location);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public AnnotatedLargeText<Computer> getLogText() {\n        return new AnnotatedLargeText<Computer>(getLogFile(), Charset.defaultCharset(), false, this);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public AnnotatedLargeText<Computer> getLogText() {\n        checkPermission(CONNECT);\n        return new AnnotatedLargeText<Computer>(getLogFile(), Charset.defaultCharset(), false, this);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public AutoCompletionCandidates doAutoCompleteCopyNewItemFrom(@QueryParameter final String value, @AncestorInPath ItemGroup<?> container) {\n        // TODO do we need a permissions check here?\n        AutoCompletionCandidates candidates = AutoCompletionCandidates.ofJobNames(TopLevelItem.class, value, container);\n        if (container instanceof DirectlyModifiableTopLevelItemGroup) {\n            DirectlyModifiableTopLevelItemGroup modifiableContainer = (DirectlyModifiableTopLevelItemGroup) container;\n            Iterator<String> it = candidates.getValues().iterator();\n            while (it.hasNext()) {\n                TopLevelItem item = Jenkins.getInstance().getItem(it.next(), container, TopLevelItem.class);\n                if (item == null) {\n                    continue; // ?\n                }\n                if (!modifiableContainer.canAdd(item)) {\n                    it.remove();\n                }\n            }\n        }\n        return candidates;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public AutoCompletionCandidates doAutoCompleteCopyNewItemFrom(@QueryParameter final String value, @AncestorInPath ItemGroup<?> container) {\n        AutoCompletionCandidates candidates = AutoCompletionCandidates.ofJobNames(TopLevelItem.class, value, container);\n        if (container instanceof DirectlyModifiableTopLevelItemGroup) {\n            DirectlyModifiableTopLevelItemGroup modifiableContainer = (DirectlyModifiableTopLevelItemGroup) container;\n            Iterator<String> it = candidates.getValues().iterator();\n            while (it.hasNext()) {\n                TopLevelItem item = Jenkins.getInstance().getItem(it.next(), container, TopLevelItem.class);\n                if (item == null) {\n                    continue; // ?\n                }\n                if (!modifiableContainer.canAdd(item)) {\n                    it.remove();\n                }\n            }\n        }\n        return candidates;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HttpResponse doConnectionStatus(StaplerRequest request) {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        try {\n            String siteId = request.getParameter(\"siteId\");\n            if (siteId == null) {\n                siteId = ID_DEFAULT;\n            } else if (siteId.equals(\"default\")) {\n                // If the request explicitly requires the default ID, ship it\n                siteId = ID_DEFAULT;\n            }\n            ConnectionCheckJob checkJob = getConnectionCheckJob(siteId);\n            if (checkJob == null) {\n                UpdateSite site = getSite(siteId);\n                if (site != null) {\n                    checkJob = addConnectionCheckJob(site);\n                }\n            }\n            if (checkJob != null) {\n                boolean isOffline = false;\n                for (ConnectionStatus status : checkJob.connectionStates.values()) {\n                    if(ConnectionStatus.FAILED.equals(status)) {\n                        isOffline = true;\n                        break;\n                    }\n                }\n                if (isOffline) {\n                    // retry connection states if determined to be offline\n                    checkJob.run();\n                    isOffline = false;\n                    for (ConnectionStatus status : checkJob.connectionStates.values()) {\n                        if(ConnectionStatus.FAILED.equals(status)) {\n                            isOffline = true;\n                            break;\n                        }\n                    }\n                    if(!isOffline) { // also need to download the metadata\n                        updateAllSites();\n                    }\n                }\n                return HttpResponses.okJSON(checkJob.connectionStates);\n            } else {\n                return HttpResponses.errorJSON(String.format(\"Cannot check connection status of the update site with ID='%s'\"\n                        + \". This update center cannot be resolved\", siteId));\n            }\n        } catch (Exception e) {\n            return HttpResponses.errorJSON(String.format(\"ERROR: %s\", e.getMessage()));\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HttpResponse doConnectionStatus(StaplerRequest request) {\n        try {\n            String siteId = request.getParameter(\"siteId\");\n            if (siteId == null) {\n                siteId = ID_DEFAULT;\n            } else if (siteId.equals(\"default\")) {\n                // If the request explicitly requires the default ID, ship it\n                siteId = ID_DEFAULT;\n            }\n            ConnectionCheckJob checkJob = getConnectionCheckJob(siteId);\n            if (checkJob == null) {\n                UpdateSite site = getSite(siteId);\n                if (site != null) {\n                    checkJob = addConnectionCheckJob(site);\n                }\n            }\n            if (checkJob != null) {\n                boolean isOffline = false;\n                for (ConnectionStatus status : checkJob.connectionStates.values()) {\n                    if(ConnectionStatus.FAILED.equals(status)) {\n                        isOffline = true;\n                        break;\n                    }\n                }\n                if (isOffline) {\n                    // retry connection states if determined to be offline\n                    checkJob.run();\n                    isOffline = false;\n                    for (ConnectionStatus status : checkJob.connectionStates.values()) {\n                        if(ConnectionStatus.FAILED.equals(status)) {\n                            isOffline = true;\n                            break;\n                        }\n                    }\n                    if(!isOffline) { // also need to download the metadata\n                        updateAllSites();\n                    }\n                }\n                return HttpResponses.okJSON(checkJob.connectionStates);\n            } else {\n                return HttpResponses.errorJSON(String.format(\"Cannot check connection status of the update site with ID='%s'\"\n                        + \". This update center cannot be resolved\", siteId));\n            }\n        } catch (Exception e) {\n            return HttpResponses.errorJSON(String.format(\"ERROR: %s\", e.getMessage()));\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HttpResponse doIncompleteInstallStatus() {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        try {\n        Map<String,String> jobs = InstallUtil.getPersistedInstallStatus();\n        if(jobs == null) {\n            jobs = Collections.emptyMap();\n        }\n            return HttpResponses.okJSON(jobs);\n        } catch (Exception e) {\n            return HttpResponses.errorJSON(String.format(\"ERROR: %s\", e.getMessage()));\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HttpResponse doIncompleteInstallStatus() {\n        try {\n        Map<String,String> jobs = InstallUtil.getPersistedInstallStatus();\n        if(jobs == null) {\n            jobs = Collections.emptyMap();\n        }\n            return HttpResponses.okJSON(jobs);\n        } catch (Exception e) {\n            return HttpResponses.errorJSON(String.format(\"ERROR: %s\", e.getMessage()));\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HttpResponse doInstallStatus(StaplerRequest request) {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        try {\n            String correlationId = request.getParameter(\"correlationId\");\n            Map<String,Object> response = new HashMap<>();\n            response.put(\"state\", Jenkins.getInstance().getInstallState().name());\n            List<Map<String, String>> installStates = new ArrayList<>();\n            response.put(\"jobs\", installStates);\n            List<UpdateCenterJob> jobCopy = getJobs();\n\n            for (UpdateCenterJob job : jobCopy) {\n                if (job instanceof InstallationJob) {\n                    UUID jobCorrelationId = job.getCorrelationId();\n                    if (correlationId == null || (jobCorrelationId != null && correlationId.equals(jobCorrelationId.toString()))) {\n                        InstallationJob installationJob = (InstallationJob) job;\n                        Map<String, String> pluginInfo = new LinkedHashMap<>();\n                        pluginInfo.put(\"name\", installationJob.plugin.name);\n                        pluginInfo.put(\"version\", installationJob.plugin.version);\n                        pluginInfo.put(\"title\", installationJob.plugin.title);\n                        pluginInfo.put(\"installStatus\", installationJob.status.getType());\n                        pluginInfo.put(\"requiresRestart\", Boolean.toString(installationJob.status.requiresRestart()));\n                        if (jobCorrelationId != null) {\n                            pluginInfo.put(\"correlationId\", jobCorrelationId.toString());\n                        }\n                        installStates.add(pluginInfo);\n                    }\n                }\n            }\n            return HttpResponses.okJSON(JSONObject.fromObject(response));\n        } catch (Exception e) {\n            return HttpResponses.errorJSON(String.format(\"ERROR: %s\", e.getMessage()));\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HttpResponse doInstallStatus(StaplerRequest request) {\n        try {\n            String correlationId = request.getParameter(\"correlationId\");\n            Map<String,Object> response = new HashMap<>();\n            response.put(\"state\", Jenkins.getInstance().getInstallState().name());\n            List<Map<String, String>> installStates = new ArrayList<>();\n            response.put(\"jobs\", installStates);\n            List<UpdateCenterJob> jobCopy = getJobs();\n\n            for (UpdateCenterJob job : jobCopy) {\n                if (job instanceof InstallationJob) {\n                    UUID jobCorrelationId = job.getCorrelationId();\n                    if (correlationId == null || (jobCorrelationId != null && correlationId.equals(jobCorrelationId.toString()))) {\n                        InstallationJob installationJob = (InstallationJob) job;\n                        Map<String, String> pluginInfo = new LinkedHashMap<>();\n                        pluginInfo.put(\"name\", installationJob.plugin.name);\n                        pluginInfo.put(\"version\", installationJob.plugin.version);\n                        pluginInfo.put(\"title\", installationJob.plugin.title);\n                        pluginInfo.put(\"installStatus\", installationJob.status.getType());\n                        pluginInfo.put(\"requiresRestart\", Boolean.toString(installationJob.status.requiresRestart()));\n                        if (jobCorrelationId != null) {\n                            pluginInfo.put(\"correlationId\", jobCorrelationId.toString());\n                        }\n                        installStates.add(pluginInfo);\n                    }\n                }\n            }\n            return HttpResponses.okJSON(JSONObject.fromObject(response));\n        } catch (Exception e) {\n            return HttpResponses.errorJSON(String.format(\"ERROR: %s\", e.getMessage()));\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HttpResponse doInvalidateData() {\n        Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n        for (UpdateSite site : sites) {\n            site.doInvalidateData();\n        }\n\n        return HttpResponses.ok();\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HttpResponse doInvalidateData() {\n        for (UpdateSite site : sites) {\n            site.doInvalidateData();\n        }\n\n        return HttpResponses.ok();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public CommandConnector(String command) {\n        this.command = command;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public CommandConnector(String command) {\n        this.command = command;\n        Jenkins.getInstance().checkPermission(Jenkins.RUN_SCRIPTS);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public CommandLauncher(String command, EnvVars env) {\n    \tthis.agentCommand = command;\n    \tthis.env = env;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public CommandLauncher(String command, EnvVars env) {\n    \tthis.agentCommand = command;\n    \tthis.env = env;\n        Jenkins.getInstance().checkPermission(Jenkins.RUN_SCRIPTS);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public FormValidation doCheckCommand(@QueryParameter String value) {\n            if(Util.fixEmptyAndTrim(value)==null)\n                return FormValidation.error(Messages.CommandLauncher_NoLaunchCommand());\n            else\n                return FormValidation.ok();\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public FormValidation doCheckCommand(@QueryParameter String value) {\n            if (!Jenkins.getInstance().hasPermission(Jenkins.RUN_SCRIPTS)) {\n                return FormValidation.warning(Messages.CommandLauncher_cannot_be_configured_by_non_administrato());\n            }\n            if(Util.fixEmptyAndTrim(value)==null)\n                return FormValidation.error(Messages.CommandLauncher_NoLaunchCommand());\n            else\n                return FormValidation.ok();\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ApiTokenProperty newInstance(User user) {\n            return new ApiTokenProperty(Util.getDigestOf(Jenkins.getInstance().getSecretKey() + \":\" + user.getId()));\n        }",
    "is_vulnerable": true
  },
  {
    "function_code": "public ApiTokenProperty newInstance(User user) {\n            return new ApiTokenProperty(API_KEY_SEED.mac(user.getId()));\n        }",
    "is_vulnerable": false
  },
  {
    "function_code": "new ContextualHttpServletRequest(request)\n     {\n        @Override\n        public void process() throws Exception\n        {\n           ServletContexts.instance().setRequest(request);\n           \n           if (request.getQueryString() == null)\n           {\n              throw new ServletException(\"Invalid request - no component specified\");\n           }\n                     \n           Set<Component> components = new HashSet<Component>();\n           Set<Type> types = new HashSet<Type>();\n           \n           response.setContentType(\"text/javascript\");\n\n           Enumeration e = request.getParameterNames();\n           while (e.hasMoreElements())\n           {\n              String componentName = ((String) e.nextElement()).trim();\n              \n              Component component = Component.forName(componentName);\n              if (component == null)\n              {                 \n                 try\n                 {\n                    Class c = Reflections.classForName(componentName);\n                    appendClassSource(response.getOutputStream(), c, types);\n                 }\n                 catch (ClassNotFoundException ex)\n                 {\n                    log.error(String.format(\"Component not found: [%s]\", componentName));\n                    throw new ServletException(\"Invalid request - component not found.\");\n                 }\n              }\n              else\n              {\n                 components.add(component);\n              }\n           }\n           \n           generateComponentInterface(components, response.getOutputStream(), types);            \n       }\n     }",
    "is_vulnerable": true
  },
  {
    "function_code": "new ContextualHttpServletRequest(request)\n     {\n        @Override\n        public void process() throws Exception\n        {\n           ServletContexts.instance().setRequest(request);\n           \n           if (request.getQueryString() == null)\n           {\n              throw new ServletException(\"Invalid request - no component specified\");\n           }\n                     \n           Set<Component> components = new HashSet<Component>();\n           Set<Type> types = new HashSet<Type>();\n           \n           response.setContentType(\"text/javascript\");\n\n           Enumeration e = request.getParameterNames();\n           while (e.hasMoreElements())\n           {\n              String componentName = ((String) e.nextElement()).trim();\n              \n              Component component = Component.forName(componentName);\n              if (component == null)\n              {                 \n                 log.error(String.format(\"Component not found: [%s]\", componentName));\n                 throw new ServletException(\"Invalid request - component not found.\");\n              }\n              else\n              {\n                 components.add(component);\n              }\n           }\n           \n           generateComponentInterface(components, response.getOutputStream(), types);            \n       }\n     }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<SyncInfo> getCurrentSyncsAsUser(int userId) {\n        enforceCrossUserPermission(userId,\n                \"no permission to read the sync settings for user \" + userId);\n        mContext.enforceCallingOrSelfPermission(Manifest.permission.READ_SYNC_STATS,\n                \"no permission to read the sync stats\");\n\n        long identityToken = clearCallingIdentity();\n        try {\n            return getSyncManager().getSyncStorageEngine().getCurrentSyncsCopy(userId);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<SyncInfo> getCurrentSyncsAsUser(int userId) {\n        enforceCrossUserPermission(userId,\n                \"no permission to read the sync settings for user \" + userId);\n        mContext.enforceCallingOrSelfPermission(Manifest.permission.READ_SYNC_STATS,\n                \"no permission to read the sync stats\");\n\n        final boolean canAccessAccounts =\n            mContext.checkCallingOrSelfPermission(Manifest.permission.GET_ACCOUNTS)\n                == PackageManager.PERMISSION_GRANTED;\n        long identityToken = clearCallingIdentity();\n        try {\n            return getSyncManager().getSyncStorageEngine()\n                .getCurrentSyncsCopy(userId, canAccessAccounts);\n        } finally {\n            restoreCallingIdentity(identityToken);\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public List<SyncInfo> getCurrentSyncsCopy(int userId) {\n        synchronized (mAuthorities) {\n            final List<SyncInfo> syncs = getCurrentSyncsLocked(userId);\n            final List<SyncInfo> syncsCopy = new ArrayList<SyncInfo>();\n            for (SyncInfo sync : syncs) {\n                syncsCopy.add(new SyncInfo(sync));\n            }\n            return syncsCopy;\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public List<SyncInfo> getCurrentSyncsCopy(int userId, boolean canAccessAccounts) {\n        synchronized (mAuthorities) {\n            final List<SyncInfo> syncs = getCurrentSyncsLocked(userId);\n            final List<SyncInfo> syncsCopy = new ArrayList<SyncInfo>();\n            for (SyncInfo sync : syncs) {\n                SyncInfo copy;\n                if (!canAccessAccounts) {\n                    copy = SyncInfo.createAccountRedacted(\n                        sync.authorityId, sync.authority, sync.startTime);\n                } else {\n                    copy = new SyncInfo(sync);\n                }\n                syncsCopy.add(copy);\n            }\n            return syncsCopy;\n        }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public Nmap4j( String path ) {\n\t\tnmapProperties = new NMapProperties( path ) ;\n\t\tflags = new ArgumentProperties() ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public Nmap4j(String path) {\n        nmapProperties = new NMapProperties(path);\n        flags = new ArgumentProperties();\n        validator = new HostsInputValidator();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void addFlags( String flagSet ) {\n\t\tStringBuilder sb = new StringBuilder() ;\n\t\tsb.append( flagSet ) ;\n\t\tif( !flagSet.contains( \"-oX\" ) ) {\n\t\t\tsb.append( \" -oX -\" ) ;\n\t\t}\n\t\tflags.addFlag( sb.toString() ) ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void addFlags(String flagSet) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(flagSet);\n        if (!flagSet.contains(\"-oX\")) {\n            sb.append(\" -oX -\");\n        }\n        flags.addFlag(sb.toString());\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void includeHosts( String hosts )  {\n\t\tflags.addIncludedHost( hosts ) ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void includeHosts(String hosts) {\n        if (!validator.valid(hosts)) {\n            throw new RuntimeException(\"Non legal hosts parameter\");\n        }\n        flags.addIncludedHost(hosts);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void excludeHosts( String hosts ) {\n\t\tflags.addExcludedHost( hosts ) ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public void excludeHosts(String hosts) {\n        flags.addExcludedHost(hosts);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getOutput() {\n\t\treturn results.getOutput() ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getOutput() {\n        return results.getOutput();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public NMapRun getResult() {\n\t\tOnePassParser parser = new OnePassParser() ;\n\t\tNMapRun nmapRun = parser.parse(results.getOutput(), OnePassParser.STRING_INPUT ) ;\n\t\treturn nmapRun ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public NMapRun getResult() {\n        OnePassParser parser = new OnePassParser();\n        NMapRun nmapRun = parser.parse(results.getOutput(), OnePassParser.STRING_INPUT);\n        return nmapRun;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean hasError() {\n\t\treturn results.getErrors().contains( \"ERROR\") ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean hasError() {\n        return results.getErrors().contains(\"ERROR\");\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ExecutionResults getExecutionResults() {\n\t\treturn results ;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ExecutionResults getExecutionResults() {\n        return results;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean valid(String host) {\n        return InternetDomainName.isValid(host) || ip(host) || subnet(host);\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean valid(String host) {\n        return InternetDomainName.isValid(host) || isIp(host) || isSubnet(host) || isFile(host);\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public boolean validateMAC(SecretKey authKey) {\n\t    boolean usesMAC = ESAPI.securityConfiguration().useMACforCipherText();\n\n\t    if (  usesMAC && macComputed() ) {  // Uses MAC and it was computed\n\t        // Calculate MAC from HMAC-SHA1(nonce, IV + plaintext) and\n\t        // compare to stored value (separate_mac_). If same, then return true,\n\t        // else return false.\n\t        byte[] mac = computeMAC(authKey);\n\t        assert mac.length == separate_mac_.length : \"MACs are of differnt lengths. Should both be the same.\";\n\t        return CryptoHelper.arrayCompare(mac, separate_mac_); // Safe compare!!!\n\t    } else if ( ! usesMAC ) {           // Doesn't use MAC\n\t        return true;\n\t    } else {                            // Uses MAC but it has not been computed / stored.\n\t        logger.warning(Logger.SECURITY_FAILURE, \"Cannot validate MAC as it was never computed and stored. \" +\n\t        \"Decryption result may be garbage even when decryption succeeds.\");\n\t        return true;    // Need to return 'true' here because of encrypt() / decrypt() methods don't support this.\n\t    }\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public boolean validateMAC(SecretKey authKey) {\n\t    boolean requiresMAC = ESAPI.securityConfiguration().useMACforCipherText();\n\n\t    if (  requiresMAC && macComputed() ) {  // Uses MAC and it was computed\n\t        // Calculate MAC from HMAC-SHA1(nonce, IV + plaintext) and\n\t        // compare to stored value (separate_mac_). If same, then return true,\n\t        // else return false.\n\t        byte[] mac = computeMAC(authKey);\n\t        assert mac.length == separate_mac_.length : \"MACs are of differnt lengths. Should both be the same.\";\n\t        return CryptoHelper.arrayCompare(mac, separate_mac_); // Safe compare!!!\n\t    } else if ( ! requiresMAC ) {           // Doesn't require a MAC\n\t        return true;\n\t    } else {\n\t    \t\t// This *used* to be the case (for versions 2.0 and 2.0.1) where we tried to\n\t    \t\t// accomodate the deprecated decrypt() method from ESAPI 1.4. Unfortunately,\n\t    \t\t// that was an EPIC FAIL. (See Google Issue # 306 for details.)\n\t        logger.warning(Logger.SECURITY_FAILURE, \"MAC may have been tampered with (e.g., length set to 0).\");\n\t        return false;    // Deprecated decrypt() method removed, so now return false.\n\t    }\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "else if ( ! usesMAC ) {           // Doesn't use MAC\n\t        return true;\n\t    }",
    "is_vulnerable": true
  },
  {
    "function_code": "else if ( ! requiresMAC ) {           // Doesn't require a MAC\n\t        return true;\n\t    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n\n        // check for user specified immune characters\n        if ( immune != null && containsCharacter( c.charValue(), immune ) )\n            return cStr;\n\n        // check for standard characters (e.g., alphanumeric, etc.)\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "protected HttpServerOptions createBaseServerOptions() {\n    return new HttpServerOptions().setPort(DEFAULT_HTTP_PORT).setHost(DEFAULT_HTTP_HOST);\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "protected HttpServerOptions createBaseServerOptions() {\n    return new HttpServerOptions().setPort(DEFAULT_HTTP_PORT).setHost(DEFAULT_HTTP_HOST);\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public static CharSequence createOptimized(String value) {\n    return io.netty.handler.codec.http.HttpHeaders.newEntity(value);\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static CharSequence createOptimized(String value) {\n    HttpUtils.validateHeader(value);\n    return new AsciiString(value);\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public MultiMap add(CharSequence name, Iterable<CharSequence> values) {\n    headers.add(toLowerCase(name), values);\n    return this;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public MultiMap add(CharSequence name, Iterable<CharSequence> values) {\n    HttpUtils.validateHeader(name, values);\n    headers.add(toLowerCase(name), values);\n    return this;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public MultiMap set(CharSequence name, Iterable<CharSequence> values) {\n    headers.set(toLowerCase(name), values);\n    return this;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "public MultiMap set(CharSequence name, Iterable<CharSequence> values) {\n    HttpUtils.validateHeader(name, values);\n    headers.set(toLowerCase(name), values);\n    return this;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "private void add0(int h, int i, final CharSequence name, final CharSequence value) {\n    // Update the hash table.\n    VertxHttpHeaders.MapEntry e = entries[i];\n    VertxHttpHeaders.MapEntry newEntry;\n    entries[i] = newEntry = new VertxHttpHeaders.MapEntry(h, name, value);\n    newEntry.next = e;\n\n    // Update the linked list.\n    newEntry.addBefore(head);\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "private void add0(int h, int i, final CharSequence name, final CharSequence value) {\n    if (!(name instanceof AsciiString)) {\n      HttpUtils.validateHeader(name);\n    }\n    if (!(value instanceof AsciiString)) {\n      HttpUtils.validateHeader(value);\n    }\n    // Update the hash table.\n    VertxHttpHeaders.MapEntry e = entries[i];\n    VertxHttpHeaders.MapEntry newEntry;\n    entries[i] = newEntry = new VertxHttpHeaders.MapEntry(h, name, value);\n    newEntry.next = e;\n\n    // Update the linked list.\n    newEntry.addBefore(head);\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "else if (loadFilename != null) {\n      try (FileInputStream fis = new FileInputStream(loadFilename);\n          ZipInputStream zipis = new ZipInputStream(fis)) {\n        ZipEntry entry = zipis.getNextEntry();\n        Preconditions.checkState(entry.getName().equals(\"parser_data\"));\n        try (ObjectInputStream ois = new ObjectInputStream(zipis)) {\n          RemoteDaemonicParserState state;\n          try {\n            state = (RemoteDaemonicParserState) ois.readObject();\n          } catch (ClassNotFoundException e) {\n            params.getConsole().printErrorText(\"Invalid file format\");\n            return ExitCode.COMMANDLINE_ERROR;\n          }\n          params.getParser().restoreParserState(state, params.getCell());\n        }\n      }\n      invalidateChanges(params);\n\n      ParserConfig configView = params.getBuckConfig().getView(ParserConfig.class);\n      if (configView.isParserCacheMutationWarningEnabled()) {\n        params\n            .getConsole()\n            .printErrorText(\n                params\n                    .getConsole()\n                    .getAnsi()\n                    .asWarningText(\n                        \"WARNING: Buck injected a parser state that may not match the local state.\"));\n      }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "else if (loadFilename != null) {\n      try (FileInputStream fis = new FileInputStream(loadFilename);\n          ZipInputStream zipis = new ZipInputStream(fis)) {\n        ZipEntry entry = zipis.getNextEntry();\n        Preconditions.checkState(entry.getName().equals(\"parser_data\"));\n        try (ObjectInputStream ois = new ParserStateObjectInputStream(zipis)) {\n          RemoteDaemonicParserState state;\n          try {\n            state = (RemoteDaemonicParserState) ois.readObject();\n          } catch (ClassNotFoundException e) {\n            params.getConsole().printErrorText(\"Invalid file format\");\n            return ExitCode.COMMANDLINE_ERROR;\n          }\n          params.getParser().restoreParserState(state, params.getCell());\n        }\n      }\n      invalidateChanges(params);\n\n      ParserConfig configView = params.getBuckConfig().getView(ParserConfig.class);\n      if (configView.isParserCacheMutationWarningEnabled()) {\n        params\n            .getConsole()\n            .printErrorText(\n                params\n                    .getConsole()\n                    .getAnsi()\n                    .asWarningText(\n                        \"WARNING: Buck injected a parser state that may not match the local state.\"));\n      }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getIconFileName() {\n\t\treturn \"plugin/jenkins-multijob-plugin/tool32.png\";\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public String getIconFileName() {\n        return Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER) ? \"plugin/jenkins-multijob-plugin/tool32.png\" : null;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }",
    "is_vulnerable": true
  },
  {
    "function_code": "private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    // The callers of this decode will have already handled 'none' if it was deemed to be valid based upon\n    // the provided verifiers. At this point, if we have a 'none' algorithm specified in the header, it is invalid.\n    if (header.algorithm == Algorithm.none) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // If a signature is provided and verifier must be provided.\n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    // A verifier was provided but no signature exists, this is treated as an invalid signature.\n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    int index = encodedJWT.lastIndexOf(\".\");\n    // The message comprises the first two segments of the entire JWT, the signature is the last segment.\n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    if (parts.length == 3) {\n      // Verify the signature before de-serializing the payload.\n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    // Verify expiration claim\n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    // Verify the notBefore claim\n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }",
    "is_vulnerable": false
  },
  {
    "function_code": "public ConstrainedExecutable(\n\t\t\tConfigurationSource source,\n\t\t\tConstraintLocation location,\n\t\t\tList<ConstrainedParameter> parameterMetaData,\n\t\t\tSet<MetaConstraint<?>> crossParameterConstraints,\n\t\t\tSet<MetaConstraint<?>> returnValueConstraints,\n\t\t\tMap<Class<?>, Class<?>> groupConversions,\n\t\t\tboolean isCascading,\n\t\t\tboolean requiresUnwrapping) {\n\t\tsuper(\n\t\t\t\tsource,\n\t\t\t\t( location.getMember() instanceof Constructor ) ? ConstrainedElementKind.CONSTRUCTOR : ConstrainedElementKind.METHOD,\n\t\t\t\tlocation,\n\t\t\t\treturnValueConstraints,\n\t\t\t\tgroupConversions,\n\t\t\t\tisCascading,\n\t\t\t\trequiresUnwrapping\n\t\t);\n\n\t\tthis.executable = ( location.getMember() instanceof Method ) ?\n\t\t\t\tExecutableElement.forMethod( (Method) location.getMember() ) :\n\t\t\t\tExecutableElement.forConstructor( (Constructor<?>) location.getMember() );\n\n\t\tif ( parameterMetaData.size() != executable.getParameterTypes().length ) {\n\t\t\tthrow log.getInvalidLengthOfParameterMetaDataListException(\n\t\t\t\t\texecutable.getAsString(),\n\t\t\t\t\texecutable.getParameterTypes().length,\n\t\t\t\t\tparameterMetaData.size()\n\t\t\t);\n\t\t}\n\n\t\tthis.crossParameterConstraints = crossParameterConstraints;\n\t\tthis.parameterMetaData = Collections.unmodifiableList( parameterMetaData );\n\t\tthis.hasParameterConstraints = hasParameterConstraints( parameterMetaData ) || !crossParameterConstraints.isEmpty();\n\n\t\tif ( isConstrained() ) {\n\t\t\trun( SetAccessibility.action( location.getMember() ) );\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ConstrainedExecutable(\n\t\t\tConfigurationSource source,\n\t\t\tConstraintLocation location,\n\t\t\tList<ConstrainedParameter> parameterMetaData,\n\t\t\tSet<MetaConstraint<?>> crossParameterConstraints,\n\t\t\tSet<MetaConstraint<?>> returnValueConstraints,\n\t\t\tMap<Class<?>, Class<?>> groupConversions,\n\t\t\tboolean isCascading,\n\t\t\tboolean requiresUnwrapping) {\n\t\tsuper(\n\t\t\t\tsource,\n\t\t\t\t( location.getMember() instanceof Constructor ) ? ConstrainedElementKind.CONSTRUCTOR : ConstrainedElementKind.METHOD,\n\t\t\t\tlocation,\n\t\t\t\treturnValueConstraints,\n\t\t\t\tgroupConversions,\n\t\t\t\tisCascading,\n\t\t\t\trequiresUnwrapping\n\t\t);\n\n\t\tthis.executable = ( location.getMember() instanceof Method ) ?\n\t\t\t\tExecutableElement.forMethod( (Method) location.getMember() ) :\n\t\t\t\tExecutableElement.forConstructor( (Constructor<?>) location.getMember() );\n\n\t\tif ( parameterMetaData.size() != executable.getParameterTypes().length ) {\n\t\t\tthrow log.getInvalidLengthOfParameterMetaDataListException(\n\t\t\t\t\texecutable.getAsString(),\n\t\t\t\t\texecutable.getParameterTypes().length,\n\t\t\t\t\tparameterMetaData.size()\n\t\t\t);\n\t\t}\n\n\t\tthis.crossParameterConstraints = crossParameterConstraints;\n\t\tthis.parameterMetaData = Collections.unmodifiableList( parameterMetaData );\n\t\tthis.hasParameterConstraints = hasParameterConstraints( parameterMetaData ) || !crossParameterConstraints.isEmpty();\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public ConstrainedField(ConfigurationSource source,\n\t\t\t\t\t\t\tConstraintLocation location,\n\t\t\t\t\t\t\tSet<MetaConstraint<?>> constraints,\n\t\t\t\t\t\t\tMap<Class<?>, Class<?>> groupConversions,\n\t\t\t\t\t\t\tboolean isCascading,\n\t\t\t\t\t\t\tboolean requiresUnwrapping) {\n\n\t\tsuper( source, ConstrainedElementKind.FIELD, location, constraints, groupConversions, isCascading, requiresUnwrapping );\n\n\t\tMember member = location.getMember();\n\t\tif ( member != null && isConstrained() ) {\n\t\t\trun( SetAccessibility.action( member ) );\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public ConstrainedField(ConfigurationSource source,\n\t\t\t\t\t\t\tConstraintLocation location,\n\t\t\t\t\t\t\tSet<MetaConstraint<?>> constraints,\n\t\t\t\t\t\t\tMap<Class<?>, Class<?>> groupConversions,\n\t\t\t\t\t\t\tboolean isCascading,\n\t\t\t\t\t\t\tboolean requiresUnwrapping) {\n\n\t\tsuper( source, ConstrainedElementKind.FIELD, location, constraints, groupConversions, isCascading, requiresUnwrapping );\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private boolean validateConstraint(ValidationContext<?> validationContext,\n\t\t\t\t\t\t\t\t\t   ValueContext<?, Object> valueContext,\n\t\t\t\t\t\t\t\t\t   boolean propertyPathComplete,\n\t\t\t\t\t\t\t\t\t   MetaConstraint<?> metaConstraint) {\n\n\t\tboolean validationSuccessful = true;\n\n\t\tif ( metaConstraint.getElementType() != ElementType.TYPE ) {\n\t\t\tPropertyMetaData propertyMetaData = beanMetaDataManager.getBeanMetaData( valueContext.getCurrentBeanType() ).getMetaDataFor(\n\t\t\t\t\tReflectionHelper.getPropertyName( metaConstraint.getLocation().getMember() )\n\t\t\t);\n\n\t\t\tif ( !propertyPathComplete ) {\n\t\t\t\tvalueContext.appendNode( propertyMetaData );\n\t\t\t}\n\t\t\tsetValidatedValueHandlerToValueContextIfPresent( validationContext, valueContext, propertyMetaData );\n\t\t}\n\t\telse {\n\t\t\tvalueContext.appendBeanNode();\n\t\t}\n\n\t\tif ( isValidationRequired( validationContext, valueContext, metaConstraint ) ) {\n\t\t\tif ( valueContext.getCurrentBean() != null ) {\n\t\t\t\tObject valueToValidate = getValue( metaConstraint.getLocation().getMember(), valueContext.getCurrentBean() );\n\t\t\t\tvalueContext.setCurrentValidatedValue( valueToValidate );\n\t\t\t}\n\t\t\tvalidationSuccessful = metaConstraint.validateConstraint( validationContext, valueContext );\n\t\t}\n\n\t\treturn validationSuccessful;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private boolean validateConstraint(ValidationContext<?> validationContext,\n\t\t\t\t\t\t\t\t\t   ValueContext<?, Object> valueContext,\n\t\t\t\t\t\t\t\t\t   boolean propertyPathComplete,\n\t\t\t\t\t\t\t\t\t   MetaConstraint<?> metaConstraint) {\n\n\t\tboolean validationSuccessful = true;\n\n\t\tif ( metaConstraint.getElementType() != ElementType.TYPE ) {\n\t\t\tPropertyMetaData propertyMetaData = beanMetaDataManager.getBeanMetaData( valueContext.getCurrentBeanType() ).getMetaDataFor(\n\t\t\t\t\tReflectionHelper.getPropertyName( metaConstraint.getLocation().getMember() )\n\t\t\t);\n\n\t\t\tif ( !propertyPathComplete ) {\n\t\t\t\tvalueContext.appendNode( propertyMetaData );\n\t\t\t}\n\t\t\tsetValidatedValueHandlerToValueContextIfPresent( valueContext, propertyMetaData );\n\t\t}\n\t\telse {\n\t\t\tvalueContext.appendBeanNode();\n\t\t}\n\n\t\tif ( isValidationRequired( validationContext, valueContext, metaConstraint ) ) {\n\t\t\tif ( valueContext.getCurrentBean() != null ) {\n\t\t\t\tObject valueToValidate = getValue( metaConstraint.getLocation().getMember(), valueContext.getCurrentBean() );\n\t\t\t\tvalueContext.setCurrentValidatedValue( valueToValidate );\n\t\t\t}\n\t\t\tvalidationSuccessful = metaConstraint.validateConstraint( validationContext, valueContext );\n\t\t}\n\n\t\treturn validationSuccessful;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private void validateCascadedConstraints(ValidationContext<?> validationContext, ValueContext<?, Object> valueContext) {\n\t\tValidatable validatable = valueContext.getCurrentValidatable();\n\t\tPathImpl originalPath = valueContext.getPropertyPath();\n\t\tClass<?> originalGroup = valueContext.getCurrentGroup();\n\n\t\tfor ( Cascadable cascadable : validatable.getCascadables() ) {\n\t\t\tvalueContext.appendNode( cascadable );\n\t\t\tClass<?> group = cascadable.convertGroup( originalGroup );\n\t\t\tvalueContext.setCurrentGroup( group );\n\n\t\t\tElementType elementType = cascadable.getElementType();\n\t\t\tif ( isCascadeRequired(\n\t\t\t\t\tvalidationContext,\n\t\t\t\t\tvalueContext.getCurrentBean(),\n\t\t\t\t\tvalueContext.getPropertyPath(),\n\t\t\t\t\telementType\n\t\t\t) ) {\n\n\t\t\t\tObject value = getValue( valueContext.getCurrentBean(), cascadable );\n\n\t\t\t\t// Value can be wrapped (e.g. Optional<Address>). Try to unwrap it\n\t\t\t\tConstraintMetaData metaData = (ConstraintMetaData) cascadable;\n\t\t\t\tif ( metaData.requiresUnwrapping() ) {\n\t\t\t\t\tsetValidatedValueHandlerToValueContextIfPresent( validationContext, valueContext, metaData );\n\t\t\t\t\tvalueContext.setCurrentValidatedValue( value );\n\t\t\t\t\tvalue = valueContext.getCurrentValidatedValue();\n\t\t\t\t}\n\n\t\t\t\tif ( value != null ) {\n\n\t\t\t\t\t// expand the group only if was created by group conversion;\n\t\t\t\t\t// otherwise we're looping through the right validation order\n\t\t\t\t\t// already and need only to pass the current element\n\t\t\t\t\tValidationOrder validationOrder = validationOrderGenerator.getValidationOrder(\n\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\tgroup != originalGroup\n\t\t\t\t\t);\n\n\t\t\t\t\t// HV-902: First, validate the value itself\n\t\t\t\t\tIterator<?> valueIter = Collections.singletonList( value ).iterator();\n\t\t\t\t\tvalidateCascadedConstraint(\n\t\t\t\t\t\t\tvalidationContext,\n\t\t\t\t\t\t\tvalueIter,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tvalueContext,\n\t\t\t\t\t\t\tvalidationOrder\n\t\t\t\t\t);\n\t\t\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Second, validate elements contained in the value if it is Iterable, Map, or an Array\n\t\t\t\t\tType type = value.getClass();\n\t\t\t\t\tIterator<?> elementsIter = createIteratorForCascadedValue( type, value, valueContext );\n\t\t\t\t\tboolean isIndexable = isIndexable( type );\n\n\t\t\t\t\tvalidateCascadedConstraint(\n\t\t\t\t\t\t\tvalidationContext,\n\t\t\t\t\t\t\telementsIter,\n\t\t\t\t\t\t\tisIndexable,\n\t\t\t\t\t\t\tvalueContext,\n\t\t\t\t\t\t\tvalidationOrder\n\t\t\t\t\t);\n\t\t\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset the path\n\t\t\tvalueContext.setPropertyPath( originalPath );\n\t\t\tvalueContext.setCurrentGroup( originalGroup );\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private void validateCascadedConstraints(ValidationContext<?> validationContext, ValueContext<?, Object> valueContext) {\n\t\tValidatable validatable = valueContext.getCurrentValidatable();\n\t\tPathImpl originalPath = valueContext.getPropertyPath();\n\t\tClass<?> originalGroup = valueContext.getCurrentGroup();\n\n\t\tfor ( Cascadable cascadable : validatable.getCascadables() ) {\n\t\t\tvalueContext.appendNode( cascadable );\n\t\t\tClass<?> group = cascadable.convertGroup( originalGroup );\n\t\t\tvalueContext.setCurrentGroup( group );\n\n\t\t\tElementType elementType = cascadable.getElementType();\n\t\t\tif ( isCascadeRequired(\n\t\t\t\t\tvalidationContext,\n\t\t\t\t\tvalueContext.getCurrentBean(),\n\t\t\t\t\tvalueContext.getPropertyPath(),\n\t\t\t\t\telementType\n\t\t\t) ) {\n\n\t\t\t\tObject value = getValue( valueContext.getCurrentBean(), cascadable );\n\n\t\t\t\t// Value can be wrapped (e.g. Optional<Address>). Try to unwrap it\n\t\t\t\tConstraintMetaData metaData = (ConstraintMetaData) cascadable;\n\t\t\t\tif ( metaData.requiresUnwrapping() ) {\n\t\t\t\t\tsetValidatedValueHandlerToValueContextIfPresent( valueContext, metaData );\n\t\t\t\t\tvalueContext.setCurrentValidatedValue( value );\n\t\t\t\t\tvalue = valueContext.getCurrentValidatedValue();\n\t\t\t\t}\n\n\t\t\t\tif ( value != null ) {\n\n\t\t\t\t\t// expand the group only if was created by group conversion;\n\t\t\t\t\t// otherwise we're looping through the right validation order\n\t\t\t\t\t// already and need only to pass the current element\n\t\t\t\t\tValidationOrder validationOrder = validationOrderGenerator.getValidationOrder(\n\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\tgroup != originalGroup\n\t\t\t\t\t);\n\n\t\t\t\t\t// HV-902: First, validate the value itself\n\t\t\t\t\tIterator<?> valueIter = Collections.singletonList( value ).iterator();\n\t\t\t\t\tvalidateCascadedConstraint(\n\t\t\t\t\t\t\tvalidationContext,\n\t\t\t\t\t\t\tvalueIter,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tvalueContext,\n\t\t\t\t\t\t\tvalidationOrder\n\t\t\t\t\t);\n\t\t\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Second, validate elements contained in the value if it is Iterable, Map, or an Array\n\t\t\t\t\tType type = value.getClass();\n\t\t\t\t\tIterator<?> elementsIter = createIteratorForCascadedValue( type, value, valueContext );\n\t\t\t\t\tboolean isIndexable = isIndexable( type );\n\n\t\t\t\t\tvalidateCascadedConstraint(\n\t\t\t\t\t\t\tvalidationContext,\n\t\t\t\t\t\t\telementsIter,\n\t\t\t\t\t\t\tisIndexable,\n\t\t\t\t\t\t\tvalueContext,\n\t\t\t\t\t\t\tvalidationOrder\n\t\t\t\t\t);\n\t\t\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// reset the path\n\t\t\tvalueContext.setPropertyPath( originalPath );\n\t\t\tvalueContext.setCurrentGroup( originalGroup );\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "int validateParametersForGroup(ValidationContext<T> validationContext, Object[] parameterValues, Group group) {\n\t\tint numberOfViolationsBefore = validationContext.getFailingConstraints().size();\n\n\t\tBeanMetaData<T> beanMetaData = beanMetaDataManager.getBeanMetaData( validationContext.getRootBeanClass() );\n\t\tExecutableMetaData executableMetaData = beanMetaData.getMetaDataFor( validationContext.getExecutable() );\n\n\t\tif ( parameterValues.length != executableMetaData.getParameterTypes().length ) {\n\t\t\tthrow log.getInvalidParameterCountForExecutableException(\n\t\t\t\t\tExecutableElement.getExecutableAsString(\n\t\t\t\t\t\t\texecutableMetaData.getType().toString() + \"#\" + executableMetaData.getName(),\n\t\t\t\t\t\t\texecutableMetaData.getParameterTypes()\n\t\t\t\t\t), parameterValues.length, executableMetaData.getParameterTypes().length\n\t\t\t);\n\t\t}\n\n\t\t// TODO GM: define behavior with respect to redefined default sequences. Should only the\n\t\t// sequence from the validated bean be honored or also default sequence definitions up in\n\t\t// the inheritance tree?\n\t\t// For now a redefined default sequence will only be considered if specified at the bean\n\t\t// hosting the validated itself, but no other default sequence from parent types\n\t\tList<Class<?>> groupList;\n\t\tif ( group.isDefaultGroup() ) {\n\t\t\tgroupList = beanMetaData.getDefaultGroupSequence( validationContext.getRootBean() );\n\t\t}\n\t\telse {\n\t\t\tgroupList = Arrays.<Class<?>>asList( group.getDefiningClass() );\n\t\t}\n\n\t\t//the only case where we can have multiple groups here is a redefined default group sequence\n\t\tfor ( Class<?> currentValidatedGroup : groupList ) {\n\t\t\tint numberOfViolationsOfCurrentGroup = 0;\n\n\t\t\tValueContext<T, Object> valueContext = getExecutableValueContext(\n\t\t\t\t\tvalidationContext.getRootBean(), executableMetaData, currentValidatedGroup\n\t\t\t);\n\t\t\tvalueContext.appendCrossParameterNode();\n\t\t\tvalueContext.setCurrentValidatedValue( parameterValues );\n\n\t\t\t// 1. validate cross-parameter constraints\n\t\t\tnumberOfViolationsOfCurrentGroup += validateConstraintsForGroup(\n\t\t\t\t\tvalidationContext, valueContext, executableMetaData.getCrossParameterConstraints()\n\t\t\t);\n\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t}\n\n\t\t\tvalueContext = getExecutableValueContext(\n\t\t\t\t\tvalidationContext.getRootBean(), executableMetaData, currentValidatedGroup\n\t\t\t);\n\t\t\tvalueContext.setCurrentValidatedValue( parameterValues );\n\n\t\t\t// 2. validate parameter constraints\n\t\t\tfor ( int i = 0; i < parameterValues.length; i++ ) {\n\t\t\t\tPathImpl originalPath = valueContext.getPropertyPath();\n\n\t\t\t\tParameterMetaData parameterMetaData = executableMetaData.getParameterMetaData( i );\n\t\t\t\tObject value = parameterValues[i];\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tClass<?> valueType = value.getClass();\n\t\t\t\t\tif ( parameterMetaData.getType() instanceof Class && ( (Class<?>) parameterMetaData.getType() ).isPrimitive() ) {\n\t\t\t\t\t\tvalueType = ReflectionHelper.unBoxedType( valueType );\n\t\t\t\t\t}\n\t\t\t\t\tif ( !TypeHelper.isAssignable( TypeHelper.getErasedType( parameterMetaData.getType() ), valueType ) ) {\n\t\t\t\t\t\tthrow log.getParameterTypesDoNotMatchException(\n\t\t\t\t\t\t\t\tvalueType.getName(),\n\t\t\t\t\t\t\t\tparameterMetaData.getType().toString(),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\tvalidationContext.getExecutable().getMember()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalueContext.appendNode( parameterMetaData );\n\t\t\t\tsetValidatedValueHandlerToValueContextIfPresent( validationContext, valueContext, parameterMetaData );\n\t\t\t\tvalueContext.setCurrentValidatedValue( value );\n\n\t\t\t\tnumberOfViolationsOfCurrentGroup += validateConstraintsForGroup(\n\t\t\t\t\t\tvalidationContext, valueContext, parameterMetaData\n\t\t\t\t);\n\t\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t\t}\n\n\t\t\t\tvalueContext.setPropertyPath( originalPath );\n\t\t\t}\n\n\t\t\t//stop processing after first group with errors occurred\n\t\t\tif ( numberOfViolationsOfCurrentGroup > 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "int validateParametersForGroup(ValidationContext<T> validationContext, Object[] parameterValues, Group group) {\n\t\tint numberOfViolationsBefore = validationContext.getFailingConstraints().size();\n\n\t\tBeanMetaData<T> beanMetaData = beanMetaDataManager.getBeanMetaData( validationContext.getRootBeanClass() );\n\t\tExecutableMetaData executableMetaData = beanMetaData.getMetaDataFor( validationContext.getExecutable() );\n\n\t\tif ( parameterValues.length != executableMetaData.getParameterTypes().length ) {\n\t\t\tthrow log.getInvalidParameterCountForExecutableException(\n\t\t\t\t\tExecutableElement.getExecutableAsString(\n\t\t\t\t\t\t\texecutableMetaData.getType().toString() + \"#\" + executableMetaData.getName(),\n\t\t\t\t\t\t\texecutableMetaData.getParameterTypes()\n\t\t\t\t\t), parameterValues.length, executableMetaData.getParameterTypes().length\n\t\t\t);\n\t\t}\n\n\t\t// TODO GM: define behavior with respect to redefined default sequences. Should only the\n\t\t// sequence from the validated bean be honored or also default sequence definitions up in\n\t\t// the inheritance tree?\n\t\t// For now a redefined default sequence will only be considered if specified at the bean\n\t\t// hosting the validated itself, but no other default sequence from parent types\n\t\tList<Class<?>> groupList;\n\t\tif ( group.isDefaultGroup() ) {\n\t\t\tgroupList = beanMetaData.getDefaultGroupSequence( validationContext.getRootBean() );\n\t\t}\n\t\telse {\n\t\t\tgroupList = Arrays.<Class<?>>asList( group.getDefiningClass() );\n\t\t}\n\n\t\t//the only case where we can have multiple groups here is a redefined default group sequence\n\t\tfor ( Class<?> currentValidatedGroup : groupList ) {\n\t\t\tint numberOfViolationsOfCurrentGroup = 0;\n\n\t\t\tValueContext<T, Object> valueContext = getExecutableValueContext(\n\t\t\t\t\tvalidationContext.getRootBean(), executableMetaData, currentValidatedGroup\n\t\t\t);\n\t\t\tvalueContext.appendCrossParameterNode();\n\t\t\tvalueContext.setCurrentValidatedValue( parameterValues );\n\n\t\t\t// 1. validate cross-parameter constraints\n\t\t\tnumberOfViolationsOfCurrentGroup += validateConstraintsForGroup(\n\t\t\t\t\tvalidationContext, valueContext, executableMetaData.getCrossParameterConstraints()\n\t\t\t);\n\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t}\n\n\t\t\tvalueContext = getExecutableValueContext(\n\t\t\t\t\tvalidationContext.getRootBean(), executableMetaData, currentValidatedGroup\n\t\t\t);\n\t\t\tvalueContext.setCurrentValidatedValue( parameterValues );\n\n\t\t\t// 2. validate parameter constraints\n\t\t\tfor ( int i = 0; i < parameterValues.length; i++ ) {\n\t\t\t\tPathImpl originalPath = valueContext.getPropertyPath();\n\n\t\t\t\tParameterMetaData parameterMetaData = executableMetaData.getParameterMetaData( i );\n\t\t\t\tObject value = parameterValues[i];\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tClass<?> valueType = value.getClass();\n\t\t\t\t\tif ( parameterMetaData.getType() instanceof Class && ( (Class<?>) parameterMetaData.getType() ).isPrimitive() ) {\n\t\t\t\t\t\tvalueType = ReflectionHelper.unBoxedType( valueType );\n\t\t\t\t\t}\n\t\t\t\t\tif ( !TypeHelper.isAssignable( TypeHelper.getErasedType( parameterMetaData.getType() ), valueType ) ) {\n\t\t\t\t\t\tthrow log.getParameterTypesDoNotMatchException(\n\t\t\t\t\t\t\t\tvalueType.getName(),\n\t\t\t\t\t\t\t\tparameterMetaData.getType().toString(),\n\t\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\t\tvalidationContext.getExecutable().getMember()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvalueContext.appendNode( parameterMetaData );\n\t\t\t\tsetValidatedValueHandlerToValueContextIfPresent( valueContext, parameterMetaData );\n\t\t\t\tvalueContext.setCurrentValidatedValue( value );\n\n\t\t\t\tnumberOfViolationsOfCurrentGroup += validateConstraintsForGroup(\n\t\t\t\t\t\tvalidationContext, valueContext, parameterMetaData\n\t\t\t\t);\n\t\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t\t}\n\n\t\t\t\tvalueContext.setPropertyPath( originalPath );\n\t\t\t}\n\n\t\t\t//stop processing after first group with errors occurred\n\t\t\tif ( numberOfViolationsOfCurrentGroup > 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "sequence\n\t\tfor ( Class<?> oneGroup : groupList ) {\n\n\t\t\tint numberOfViolationsOfCurrentGroup = 0;\n\n\t\t\t// validate constraints at return value itself\n\t\t\tValueContext<?, Object> valueContext = getExecutableValueContext(\n\t\t\t\t\texecutableMetaData.getKind() == ElementKind.CONSTRUCTOR ? value : bean,\n\t\t\t\t\texecutableMetaData,\n\t\t\t\t\toneGroup\n\t\t\t);\n\n\t\t\tvalueContext.setCurrentValidatedValue( value );\n\t\t\tvalueContext.appendNode( executableMetaData.getReturnValueMetaData() );\n\t\t\tsetValidatedValueHandlerToValueContextIfPresent(\n\t\t\t\t\tvalidationContext,\n\t\t\t\t\tvalueContext,\n\t\t\t\t\texecutableMetaData.getReturnValueMetaData()\n\t\t\t);\n\n\t\t\tnumberOfViolationsOfCurrentGroup +=\n\t\t\t\t\tvalidateConstraintsForGroup(\n\t\t\t\t\t\t\tvalidationContext, valueContext, executableMetaData\n\t\t\t\t\t);\n\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t}\n\n\t\t\t//stop processing after first group with errors occurred\n\t\t\tif ( numberOfViolationsOfCurrentGroup > 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "sequence\n\t\tfor ( Class<?> oneGroup : groupList ) {\n\n\t\t\tint numberOfViolationsOfCurrentGroup = 0;\n\n\t\t\t// validate constraints at return value itself\n\t\t\tValueContext<?, Object> valueContext = getExecutableValueContext(\n\t\t\t\t\texecutableMetaData.getKind() == ElementKind.CONSTRUCTOR ? value : bean,\n\t\t\t\t\texecutableMetaData,\n\t\t\t\t\toneGroup\n\t\t\t);\n\n\t\t\tvalueContext.setCurrentValidatedValue( value );\n\t\t\tvalueContext.appendNode( executableMetaData.getReturnValueMetaData() );\n\t\t\tsetValidatedValueHandlerToValueContextIfPresent(\n\t\t\t\t\tvalueContext,\n\t\t\t\t\texecutableMetaData.getReturnValueMetaData()\n\t\t\t);\n\n\t\t\tnumberOfViolationsOfCurrentGroup +=\n\t\t\t\t\tvalidateConstraintsForGroup(\n\t\t\t\t\t\t\tvalidationContext, valueContext, executableMetaData\n\t\t\t\t\t);\n\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t}\n\n\t\t\t//stop processing after first group with errors occurred\n\t\t\tif ( numberOfViolationsOfCurrentGroup > 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "int validateReturnValueForGroup(ValidationContext<T> validationContext, T bean, Object value, Group group) {\n\t\tint numberOfViolationsBefore = validationContext.getFailingConstraints().size();\n\n\t\tBeanMetaData<T> beanMetaData = beanMetaDataManager.getBeanMetaData( validationContext.getRootBeanClass() );\n\t\tExecutableMetaData executableMetaData = beanMetaData.getMetaDataFor( validationContext.getExecutable() );\n\n\t\tif ( executableMetaData == null ) {\n\t\t\t// nothing to validate\n\t\t\treturn 0;\n\t\t}\n\n\t\t// TODO GM: define behavior with respect to redefined default sequences. Should only the\n\t\t// sequence from the validated bean be honored or also default sequence definitions up in\n\t\t// the inheritance tree?\n\t\t// For now a redefined default sequence will only be considered if specified at the bean\n\t\t// hosting the validated itself, but no other default sequence from parent types\n\n\t\tList<Class<?>> groupList;\n\t\tif ( group.isDefaultGroup() ) {\n\t\t\tgroupList = beanMetaData.getDefaultGroupSequence( bean );\n\t\t}\n\t\telse {\n\t\t\tgroupList = Arrays.<Class<?>>asList( group.getDefiningClass() );\n\t\t}\n\n\t\t//the only case where we can have multiple groups here is a redefined default group sequence\n\t\tfor ( Class<?> oneGroup : groupList ) {\n\n\t\t\tint numberOfViolationsOfCurrentGroup = 0;\n\n\t\t\t// validate constraints at return value itself\n\t\t\tValueContext<?, Object> valueContext = getExecutableValueContext(\n\t\t\t\t\texecutableMetaData.getKind() == ElementKind.CONSTRUCTOR ? value : bean,\n\t\t\t\t\texecutableMetaData,\n\t\t\t\t\toneGroup\n\t\t\t);\n\n\t\t\tvalueContext.setCurrentValidatedValue( value );\n\t\t\tvalueContext.appendNode( executableMetaData.getReturnValueMetaData() );\n\t\t\tsetValidatedValueHandlerToValueContextIfPresent(\n\t\t\t\t\tvalidationContext,\n\t\t\t\t\tvalueContext,\n\t\t\t\t\texecutableMetaData.getReturnValueMetaData()\n\t\t\t);\n\n\t\t\tnumberOfViolationsOfCurrentGroup +=\n\t\t\t\t\tvalidateConstraintsForGroup(\n\t\t\t\t\t\t\tvalidationContext, valueContext, executableMetaData\n\t\t\t\t\t);\n\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t}\n\n\t\t\t//stop processing after first group with errors occurred\n\t\t\tif ( numberOfViolationsOfCurrentGroup > 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "int validateReturnValueForGroup(ValidationContext<T> validationContext, T bean, Object value, Group group) {\n\t\tint numberOfViolationsBefore = validationContext.getFailingConstraints().size();\n\n\t\tBeanMetaData<T> beanMetaData = beanMetaDataManager.getBeanMetaData( validationContext.getRootBeanClass() );\n\t\tExecutableMetaData executableMetaData = beanMetaData.getMetaDataFor( validationContext.getExecutable() );\n\n\t\tif ( executableMetaData == null ) {\n\t\t\t// nothing to validate\n\t\t\treturn 0;\n\t\t}\n\n\t\t// TODO GM: define behavior with respect to redefined default sequences. Should only the\n\t\t// sequence from the validated bean be honored or also default sequence definitions up in\n\t\t// the inheritance tree?\n\t\t// For now a redefined default sequence will only be considered if specified at the bean\n\t\t// hosting the validated itself, but no other default sequence from parent types\n\n\t\tList<Class<?>> groupList;\n\t\tif ( group.isDefaultGroup() ) {\n\t\t\tgroupList = beanMetaData.getDefaultGroupSequence( bean );\n\t\t}\n\t\telse {\n\t\t\tgroupList = Arrays.<Class<?>>asList( group.getDefiningClass() );\n\t\t}\n\n\t\t//the only case where we can have multiple groups here is a redefined default group sequence\n\t\tfor ( Class<?> oneGroup : groupList ) {\n\n\t\t\tint numberOfViolationsOfCurrentGroup = 0;\n\n\t\t\t// validate constraints at return value itself\n\t\t\tValueContext<?, Object> valueContext = getExecutableValueContext(\n\t\t\t\t\texecutableMetaData.getKind() == ElementKind.CONSTRUCTOR ? value : bean,\n\t\t\t\t\texecutableMetaData,\n\t\t\t\t\toneGroup\n\t\t\t);\n\n\t\t\tvalueContext.setCurrentValidatedValue( value );\n\t\t\tvalueContext.appendNode( executableMetaData.getReturnValueMetaData() );\n\t\t\tsetValidatedValueHandlerToValueContextIfPresent(\n\t\t\t\t\tvalueContext,\n\t\t\t\t\texecutableMetaData.getReturnValueMetaData()\n\t\t\t);\n\n\t\t\tnumberOfViolationsOfCurrentGroup +=\n\t\t\t\t\tvalidateConstraintsForGroup(\n\t\t\t\t\t\t\tvalidationContext, valueContext, executableMetaData\n\t\t\t\t\t);\n\t\t\tif ( shouldFailFast( validationContext ) ) {\n\t\t\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t\t\t}\n\n\t\t\t//stop processing after first group with errors occurred\n\t\t\tif ( numberOfViolationsOfCurrentGroup > 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn validationContext.getFailingConstraints().size() - numberOfViolationsBefore;\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "void setValidatedValueHandlerToValueContextIfPresent(ValidationContext<?> validationContext,\n\t\t\tValueContext<?, T> valueContext, ConstraintMetaData metaData) {\n\t\tif ( metaData.requiresUnwrapping() ) {\n\t\t\t@SuppressWarnings(\"unchecked\") //we know the handler matches the value type\n\t\t\t\t\tValidatedValueUnwrapper<? super T> handler = (ValidatedValueUnwrapper<T>) getValidatedValueHandler(\n\t\t\t\t\tmetaData.getType()\n\t\t\t);\n\n\t\t\tif ( handler == null ) {\n\t\t\t\tthrow log.getNoUnwrapperFoundForTypeException( metaData.getType().toString() );\n\t\t\t}\n\n\t\t\tvalueContext.setValidatedValueHandler( handler );\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "void setValidatedValueHandlerToValueContextIfPresent(ValueContext<?, T> valueContext, ConstraintMetaData metaData) {\n\t\tif ( metaData.requiresUnwrapping() ) {\n\t\t\t@SuppressWarnings(\"unchecked\") //we know the handler matches the value type\n\t\t\t\t\tValidatedValueUnwrapper<? super T> handler = (ValidatedValueUnwrapper<T>) getValidatedValueHandler(\n\t\t\t\t\tmetaData.getType()\n\t\t\t);\n\n\t\t\tif ( handler == null ) {\n\t\t\t\tthrow log.getNoUnwrapperFoundForTypeException( metaData.getType().toString() );\n\t\t\t}\n\n\t\t\tvalueContext.setValidatedValueHandler( handler );\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "private void detectJPA() {\n\t\t// check whether we have Persistence on the classpath\n\t\tClass<?> persistenceClass;\n\t\ttry {\n\t\t\tpersistenceClass = run( LoadClass.action( PERSISTENCE_CLASS_NAME, this.getClass() ) );\n\t\t}\n\t\tcatch ( ValidationException e ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Cannot find %s on classpath. Assuming non JPA 2 environment. All properties will per default be traversable.\",\n\t\t\t\t\tPERSISTENCE_CLASS_NAME\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// check whether Persistence contains getPersistenceUtil\n\t\tMethod persistenceUtilGetter = run( GetMethod.action( persistenceClass, PERSISTENCE_UTIL_METHOD ) );\n\t\tif ( persistenceUtilGetter == null ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Found %s on classpath, but no method '%s'. Assuming JPA 1 environment. All properties will per default be traversable.\",\n\t\t\t\t\tPERSISTENCE_CLASS_NAME,\n\t\t\t\t\tPERSISTENCE_UTIL_METHOD\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// try to invoke the method to make sure that we are dealing with a complete JPA2 implementation\n\t\t// unfortunately there are several incomplete implementations out there (see HV-374)\n\t\ttry {\n\t\t\tObject persistence = run( NewInstance.action( persistenceClass, \"persistence provider\" ) );\n\t\t\tReflectionHelper.getValue(persistenceUtilGetter, persistence );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Unable to invoke %s.%s. Inconsistent JPA environment. All properties will per default be traversable.\",\n\t\t\t\t\tPERSISTENCE_CLASS_NAME,\n\t\t\t\t\tPERSISTENCE_UTIL_METHOD\n\t\t\t);\n\t\t}\n\n\t\tlog.debugf(\n\t\t\t\t\"Found %s on classpath containing '%s'. Assuming JPA 2 environment. Trying to instantiate JPA aware TraversableResolver\",\n\t\t\t\tPERSISTENCE_CLASS_NAME,\n\t\t\t\tPERSISTENCE_UTIL_METHOD\n\t\t);\n\n\t\ttry {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tClass<? extends TraversableResolver> jpaAwareResolverClass = (Class<? extends TraversableResolver>)\n\t\t\t\t\trun( LoadClass.action( JPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME, this.getClass() ) );\n\t\t\tjpaTraversableResolver = run( NewInstance.action( jpaAwareResolverClass, \"\" ) );\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Instantiated JPA aware TraversableResolver of type %s.\", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME\n\t\t\t);\n\t\t}\n\t\tcatch ( ValidationException e ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.\",\n\t\t\t\t\tJPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME\n\t\t\t);\n\t\t}\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "private void detectJPA() {\n\t\t// check whether we have Persistence on the classpath\n\t\tClass<?> persistenceClass;\n\t\ttry {\n\t\t\tpersistenceClass = run( LoadClass.action( PERSISTENCE_CLASS_NAME, this.getClass() ) );\n\t\t}\n\t\tcatch ( ValidationException e ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Cannot find %s on classpath. Assuming non JPA 2 environment. All properties will per default be traversable.\",\n\t\t\t\t\tPERSISTENCE_CLASS_NAME\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// check whether Persistence contains getPersistenceUtil\n\t\tMethod persistenceUtilGetter = run( GetMethod.action( persistenceClass, PERSISTENCE_UTIL_METHOD ) );\n\t\tif ( persistenceUtilGetter == null ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Found %s on classpath, but no method '%s'. Assuming JPA 1 environment. All properties will per default be traversable.\",\n\t\t\t\t\tPERSISTENCE_CLASS_NAME,\n\t\t\t\t\tPERSISTENCE_UTIL_METHOD\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// try to invoke the method to make sure that we are dealing with a complete JPA2 implementation\n\t\t// unfortunately there are several incomplete implementations out there (see HV-374)\n\t\ttry {\n\t\t\tObject persistence = run( NewInstance.action( persistenceClass, \"persistence provider\" ) );\n\t\t\tReflectionHelper.getValue( persistenceUtilGetter, persistence );\n\t\t}\n\t\tcatch ( Exception e ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Unable to invoke %s.%s. Inconsistent JPA environment. All properties will per default be traversable.\",\n\t\t\t\t\tPERSISTENCE_CLASS_NAME,\n\t\t\t\t\tPERSISTENCE_UTIL_METHOD\n\t\t\t);\n\t\t}\n\n\t\tlog.debugf(\n\t\t\t\t\"Found %s on classpath containing '%s'. Assuming JPA 2 environment. Trying to instantiate JPA aware TraversableResolver\",\n\t\t\t\tPERSISTENCE_CLASS_NAME,\n\t\t\t\tPERSISTENCE_UTIL_METHOD\n\t\t);\n\n\t\ttry {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tClass<? extends TraversableResolver> jpaAwareResolverClass = (Class<? extends TraversableResolver>)\n\t\t\t\t\trun( LoadClass.action( JPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME, this.getClass() ) );\n\t\t\tjpaTraversableResolver = run( NewInstance.action( jpaAwareResolverClass, \"\" ) );\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Instantiated JPA aware TraversableResolver of type %s.\", JPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME\n\t\t\t);\n\t\t}\n\t\tcatch ( ValidationException e ) {\n\t\t\tlog.debugf(\n\t\t\t\t\t\"Unable to load or instantiate JPA aware resolver %s. All properties will per default be traversable.\",\n\t\t\t\t\tJPA_AWARE_TRAVERSABLE_RESOLVER_CLASS_NAME\n\t\t\t);\n\t\t}\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "public static XMLTypeValidator createXMLTypeValidator(String xmlSchema) {\n      // create a SchemaFactory capable of understanding WXS schemas\n      SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n\n      // load a WXS schema, represented by a Schema instance\n      Source xmlSchemaSource = new StreamSource(new StringReader(xmlSchema));\n      try {\n        return new XMLTypeValidator(factory.newSchema(xmlSchemaSource).newValidator());\n      } catch (SAXException e) {\n        e.printStackTrace();\n        return null;\n      }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public static XMLTypeValidator createXMLTypeValidator(String xmlSchema) {\n      try {\n        // create a SchemaFactory capable of understanding WXS schemas\n        SchemaFactory factory = createSchemaFactoryInstance();\n        // load a WXS schema, represented by a Schema instance\n        Source xmlSchemaSource = new StreamSource(new StringReader(xmlSchema));\n        return new XMLTypeValidator(factory.newSchema(xmlSchemaSource).newValidator());\n      } catch (SAXException e) {\n        e.printStackTrace();\n        return null;\n      }\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public JBPMBpmn2ResourceImpl(URI uri) {\n\t\tsuper(uri);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DISABLE_NOTIFY, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_USE_XML_NAME_TO_FEATURE_MAP, xmlNameToFeatureMap);\n\n        // Switch off DTD external entity processing\n        Map parserFeatures = new HashMap();\n        parserFeatures.put(\"http://xml.org/sax/features/external-general-entities\", false);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_PARSER_FEATURES, parserFeatures);\n\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_ENCODING, \"UTF-8\");\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_DISCARD);\n\t}",
    "is_vulnerable": true
  },
  {
    "function_code": "public JBPMBpmn2ResourceImpl(URI uri) {\n\t\tsuper(uri);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DISABLE_NOTIFY, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_USE_XML_NAME_TO_FEATURE_MAP, xmlNameToFeatureMap);\n\n        // Switch off DTD external entity processing\n        Map parserFeatures = new HashMap();\n        parserFeatures.put(\"http://xml.org/sax/features/external-general-entities\", false);\n        parserFeatures.put(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_PARSER_FEATURES, parserFeatures);\n\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_ENCODING, \"UTF-8\");\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_DISCARD);\n\t}",
    "is_vulnerable": false
  },
  {
    "function_code": "Path resolveSecurely(Path rootPath, String path) {\n        Path resolvedPath;\n        if(path == null || path.isEmpty()) {\n            resolvedPath = rootPath.normalize();\n        } else {\n            String relativePath = removeSuperflousSlashes(path);\n            resolvedPath = rootPath.resolve(relativePath).normalize();\n        }\n        if(!resolvedPath.startsWith(rootPath))  {\n            throw DeploymentRepositoryLogger.ROOT_LOGGER.forbiddenPath(path);\n        }\n        return resolvedPath;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "Path resolveSecurely(Path rootPath, String path) {\n        Path resolvedPath;\n        if(path == null || path.isEmpty()) {\n            resolvedPath = rootPath.normalize();\n        } else {\n            String relativePath = removeSuperflousSlashes(path);\n            resolvedPath = rootPath.resolve(relativePath).normalize();\n        }\n        if(!resolvedPath.startsWith(rootPath)) {\n            throw DeploymentRepositoryLogger.ROOT_LOGGER.forbiddenPath(path);\n        }\n        return resolvedPath;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public String getPassword() {\n        return password;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "String getPassword() {\n        return secret.getPlainText();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public HudsonInstance(String name, String url, String login, String password) {\n        this.name = name;\n        this.url = url;\n        this.login = login;\n        this.password = password;\n\n        initVariables();\n        restoreQueue();\n        initPublisherThread();\n\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "public HudsonInstance(String name, String url, String login, String password) {\n        this.name = name;\n        this.url = url;\n        this.login = login;\n        this.secret = Secret.fromString(password);\n\n        initVariables();\n        restoreQueue();\n        initPublisherThread();\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "private Object readResolve() {\n        initVariables();\n\n        // let's wait until Hudson's initialized\n        Hudson.getInstance().getExtensionList(ItemListener.class).add(new ItemListener() {\n            @Override\n            public void onLoaded() {\n                restoreQueue();\n                initPublisherThread();\n            }\n        });\n\n        return this;\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "private Object readResolve() {\n        // Migrate plaintext password to secret\n        if (password != null) {\n            if (secret == null) {\n                secret = Secret.fromString(password);\n                password = null;\n            }\n        }\n\n        initVariables();\n\n        // let's wait until Hudson's initialized\n        Hudson.getInstance().getExtensionList(ItemListener.class).add(new ItemListener() {\n            @Override\n            public void onLoaded() {\n                restoreQueue();\n                initPublisherThread();\n            }\n        });\n\n        return this;\n    }",
    "is_vulnerable": false
  },
  {
    "function_code": "public void loadProxy(){\n        Jenkins j = Jenkins.getInstance();\n        ProxyConfiguration proxy = j!=null ? j.proxy : null;\n        if(proxy != null) {\n            client.getHostConfiguration().setProxy(proxy.name, proxy.port);\n            if(proxy.getUserName() != null)\n                client.getState().setProxyCredentials(AuthScope.ANY,new UsernamePasswordCredentials(proxy.getUserName(),proxy.getPassword()));\n        }\n    }",
    "is_vulnerable": true
  },
  {
    "function_code": "void loadProxy(){\n        Jenkins j = Jenkins.getInstance();\n        ProxyConfiguration proxy = j!=null ? j.proxy : null;\n        if(proxy != null) {\n            client.getHostConfiguration().setProxy(proxy.name, proxy.port);\n            if(proxy.getUserName() != null)\n                client.getState().setProxyCredentials(AuthScope.ANY,new UsernamePasswordCredentials(proxy.getUserName(),proxy.getPassword()));\n        }\n    }",
    "is_vulnerable": false
  }
]