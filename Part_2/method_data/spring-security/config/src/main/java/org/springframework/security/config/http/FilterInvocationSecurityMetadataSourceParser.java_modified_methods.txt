Method: parseInterceptUrlsForFilterInvocationRequestMap
VULNERABLE VERSION:
 BeanDefinition> parseInterceptUrlsForFilterInvocationRequestMap(
			MatcherType matcherType, List<Element> urlElts, boolean useExpressions,
			boolean addAuthenticatedAll, ParserContext parserContext) {

		ManagedMap<BeanDefinition, BeanDefinition> filterInvocationDefinitionMap = new ManagedMap<BeanDefinition, BeanDefinition>();

		for (Element urlElt : urlElts) {
			String access = urlElt.getAttribute(ATT_ACCESS);
			if (!StringUtils.hasText(access)) {
				continue;
			}

			String path = urlElt.getAttribute(ATT_PATTERN);

			if (!StringUtils.hasText(path)) {
				parserContext.getReaderContext().error(
						"path attribute cannot be empty or null", urlElt);
			}

			String method = urlElt.getAttribute(ATT_HTTP_METHOD);
			if (!StringUtils.hasText(method)) {
				method = null;
			}

			BeanDefinition matcher = matcherType.createMatcher(path, method);
			BeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder
					.rootBeanDefinition(SecurityConfig.class);

			if (useExpressions) {
				logger.info("Creating access control expression attribute '" + access
						+ "' for " + path);
				// The single expression will be parsed later by the
				// ExpressionFilterInvocationSecurityMetadataSource
				attributeBuilder.addConstructorArgValue(new String[] { access });
				attributeBuilder.setFactoryMethod("createList");

			}
			else {
				attributeBuilder.addConstructorArgValue(access);
				attributeBuilder.setFactoryMethod("createListFromCommaDelimitedString");
			}

			if (filterInvocationDefinitionMap.containsKey(matcher)) {
				logger.warn("Duplicate URL defined: " + path
						+ ". The original attribute values will be overwritten");
			}

			filterInvocationDefinitionMap.put(matcher,
					attributeBuilder.getBeanDefinition());
		}

		if (addAuthenticatedAll && filterInvocationDefinitionMap.isEmpty()) {

			BeanDefinition matcher = matcherType.createMatcher("/**", null);
			BeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder
					.rootBeanDefinition(SecurityConfig.class);
			attributeBuilder.addConstructorArgValue(new String[] { "authenticated" });
			attributeBuilder.setFactoryMethod("createList");
			filterInvocationDefinitionMap.put(matcher,
					attributeBuilder.getBeanDefinition());
		}

		return filterInvocationDefinitionMap;
	}
FIXED VERSION:
 BeanDefinition> parseInterceptUrlsForFilterInvocationRequestMap(
			MatcherType matcherType, List<Element> urlElts, boolean useExpressions,
			boolean addAuthenticatedAll, ParserContext parserContext) {

		ManagedMap<BeanDefinition, BeanDefinition> filterInvocationDefinitionMap = new ManagedMap<BeanDefinition, BeanDefinition>();

		for (Element urlElt : urlElts) {
			String access = urlElt.getAttribute(ATT_ACCESS);
			if (!StringUtils.hasText(access)) {
				continue;
			}

			String path = urlElt.getAttribute(ATT_PATTERN);

			if (!StringUtils.hasText(path)) {
				parserContext.getReaderContext().error(
						"path attribute cannot be empty or null", urlElt);
			}

			String method = urlElt.getAttribute(ATT_HTTP_METHOD);
			if (!StringUtils.hasText(method)) {
				method = null;
			}

			BeanDefinition matcher = matcherType.createMatcher(parserContext, path,
					method);
			BeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder
					.rootBeanDefinition(SecurityConfig.class);

			if (useExpressions) {
				logger.info("Creating access control expression attribute '" + access
						+ "' for " + path);
				// The single expression will be parsed later by the
				// ExpressionFilterInvocationSecurityMetadataSource
				attributeBuilder.addConstructorArgValue(new String[] { access });
				attributeBuilder.setFactoryMethod("createList");

			}
			else {
				attributeBuilder.addConstructorArgValue(access);
				attributeBuilder.setFactoryMethod("createListFromCommaDelimitedString");
			}

			if (filterInvocationDefinitionMap.containsKey(matcher)) {
				logger.warn("Duplicate URL defined: " + path
						+ ". The original attribute values will be overwritten");
			}

			filterInvocationDefinitionMap.put(matcher,
					attributeBuilder.getBeanDefinition());
		}

		if (addAuthenticatedAll && filterInvocationDefinitionMap.isEmpty()) {

			BeanDefinition matcher = matcherType.createMatcher(parserContext, "/**",
					null);
			BeanDefinitionBuilder attributeBuilder = BeanDefinitionBuilder
					.rootBeanDefinition(SecurityConfig.class);
			attributeBuilder.addConstructorArgValue(new String[] { "authenticated" });
			attributeBuilder.setFactoryMethod("createList");
			filterInvocationDefinitionMap.put(matcher,
					attributeBuilder.getBeanDefinition());
		}

		return filterInvocationDefinitionMap;
	}
================================================================================
