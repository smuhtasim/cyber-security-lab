Method: Parameters
VULNERABLE VERSION:

    public Parameters() {
        super( INITIAL_SIZE );
    }
FIXED VERSION:


    public Parameters() {
        // NO-OP
    }
================================================================================
Method: setEncoding
VULNERABLE VERSION:


    public void setEncoding( String s ) {
        encoding=s;
        if(debug>0) log( "Set encoding to " + s );
    }
FIXED VERSION:


    public void setEncoding( String s ) {
        encoding=s;
        if(log.isDebugEnabled()) {
            log.debug( "Set encoding to " + s );
        }
    }
================================================================================
Method: setQueryStringEncoding
VULNERABLE VERSION:


    public void setQueryStringEncoding( String s ) {
        queryStringEncoding=s;
        if(debug>0) log( "Set query string encoding to " + s );
    }
FIXED VERSION:


    public void setQueryStringEncoding( String s ) {
        queryStringEncoding=s;
        if(log.isDebugEnabled()) {
            log.debug( "Set query string encoding to " + s );
        }
    }
================================================================================
Method: recycle
VULNERABLE VERSION:


    public void recycle() {
        super.recycle();
        paramHashStringArray.clear();
        didQueryParameters=false;
        currentChild=null;
        didMerge=false;
        encoding=null;
        decodedQuery.recycle();
    }
FIXED VERSION:


    public void recycle() {
        parameterCount = 0;
        paramHashValues.clear();
        didQueryParameters=false;
        encoding=null;
        decodedQuery.recycle();
        parseFailed = false;
    }
================================================================================
Method: addParameterValues
VULNERABLE VERSION:


    public void addParameterValues( String key, String[] newValues) {
        if ( key==null ) return;
        String values[];
        if (paramHashStringArray.containsKey(key)) {
            String oldValues[] = (String[])paramHashStringArray.get(key);
            values = new String[oldValues.length + newValues.length];
            for (int i = 0; i < oldValues.length; i++) {
                values[i] = oldValues[i];
            }
            for (int i = 0; i < newValues.length; i++) {
                values[i+ oldValues.length] = newValues[i];
            }
        } else {
            values = newValues;
        }

        paramHashStringArray.put(key, values);
    }
FIXED VERSION:

    
    public void addParameterValues(String key, String[] newValues) {
        if (key == null) {
            return;
        }
        ArrayList values = (ArrayList) paramHashValues.get(key);
        if (values == null) {
            values = new ArrayList(newValues.length);
            paramHashValues.put(key, values);
        } else {
            values.ensureCapacity(values.size() + newValues.length);
        }
        for (int i = 0; i < newValues.length; i++) {
            values.add(newValues[i]);
        }
    }
================================================================================
Method: getParameterValues
VULNERABLE VERSION:


    public String[] getParameterValues(String name) {
        handleQueryParameters();
        // sub-request
        if( currentChild!=null ) {
            currentChild.merge();
            return (String[])currentChild.paramHashStringArray.get(name);
        }

        // no "facade"
        String values[]=(String[])paramHashStringArray.get(name);
        return values;
    }
FIXED VERSION:


    public String[] getParameterValues(String name) {
        handleQueryParameters();
        // no "facade"
        ArrayList values = (ArrayList) paramHashValues.get(name);
        if (values == null) {
            return null;
        }
        return (String[]) values.toArray(new String[values.size()]);
    }
================================================================================
Method: getParameterNames
VULNERABLE VERSION:

 
    public Enumeration getParameterNames() {
        handleQueryParameters();
        // Slow - the original code
        if( currentChild!=null ) {
            currentChild.merge();
            return currentChild.paramHashStringArray.keys();
        }

        // merge in child
        return paramHashStringArray.keys();
    }
FIXED VERSION:

 
    public Enumeration getParameterNames() {
        handleQueryParameters();
        return Collections.enumeration(paramHashValues.keySet());
    }
================================================================================
Method: getParameter
VULNERABLE VERSION:

    public String getParameter(String name ) {
        String[] values = getParameterValues(name);
        if (values != null) {
            if( values.length==0 ) return "";
            return values[0];
        } else {
            return null;
        }
    }
FIXED VERSION:

    public String getParameter(String name ) {
        handleQueryParameters();
        ArrayList values = (ArrayList) paramHashValues.get(name);
        if (values != null) {
            if(values.size() == 0) {
                return "";
            }
            return (String) values.get(0);
        } else {
            return null;
        }
    }
================================================================================
Method: handleQueryParameters
VULNERABLE VERSION:

    public void handleQueryParameters() {
        if( didQueryParameters ) return;

        didQueryParameters=true;

        if( queryMB==null || queryMB.isNull() )
            return;
        
        if( debug > 0  )
            log( "Decoding query " + decodedQuery + " " + queryStringEncoding);

        try {
            decodedQuery.duplicate( queryMB );
        } catch (IOException e) {
            // Can't happen, as decodedQuery can't overflow
            e.printStackTrace();
        }
        processParameters( decodedQuery, queryStringEncoding );
    }
FIXED VERSION:

    public void handleQueryParameters() {
        if( didQueryParameters ) return;

        didQueryParameters=true;

        if( queryMB==null || queryMB.isNull() )
            return;
        
        if(log.isDebugEnabled()) {
            log.debug("Decoding query " + decodedQuery + " " +
                    queryStringEncoding);
        }

        try {
            decodedQuery.duplicate( queryMB );
        } catch (IOException e) {
            // Can't happen, as decodedQuery can't overflow
            e.printStackTrace();
        }
        processParameters( decodedQuery, queryStringEncoding );
    }
================================================================================
Method: addParam
VULNERABLE VERSION:

    private void addParam( String key, String value ) {
        if( key==null ) return;
        String values[];
        if (paramHashStringArray.containsKey(key)) {
            String oldValues[] = (String[])paramHashStringArray.
                get(key);
            values = new String[oldValues.length + 1];
            for (int i = 0; i < oldValues.length; i++) {
                values[i] = oldValues[i];
            }
            values[oldValues.length] = value;
        } else {
            values = new String[1];
            values[0] = value;
        }
        
        
        paramHashStringArray.put(key, values);
    }
FIXED VERSION:



    private void addParam( String key, String value ) {
        if( key==null ) return;
        ArrayList values = (ArrayList) paramHashValues.get(key);
        if (values == null) {
            values = new ArrayList(1);
            paramHashValues.put(key, values);
        }
        values.add(value);
    }
================================================================================
Method: processParameters
VULNERABLE VERSION:

    public void processParameters( String str ) {
        int end=str.length();
        int pos=0;
        if( debug > 0)
            log("String: " + str );
        
        do {
            boolean noEq=false;
            int valStart=-1;
            int valEnd=-1;
            
            int nameStart=pos;
            int nameEnd=str.indexOf('=', nameStart );
            int nameEnd2=str.indexOf('&', nameStart );
            if( nameEnd2== -1 ) nameEnd2=end;
            if( (nameEnd2!=-1 ) &&
                ( nameEnd==-1 || nameEnd > nameEnd2) ) {
                nameEnd=nameEnd2;
                noEq=true;
                valStart=nameEnd;
                valEnd=nameEnd;
                if(debug>0) log("no equal " + nameStart + " " + nameEnd + " " +
                        str.substring(nameStart, nameEnd));
            }

            if( nameEnd== -1 ) nameEnd=end;

            if( ! noEq ) {
                valStart=nameEnd+1;
                valEnd=str.indexOf('&', valStart);
                if( valEnd== -1 ) valEnd = (valStart < end) ? end : valStart;
            }
            
            pos=valEnd+1;
            
            if( nameEnd<=nameStart ) {
                continue;
            }
            if( debug>0)
                log( "XXX " + nameStart + " " + nameEnd + " "
                     + valStart + " " + valEnd );
            
            try {
                tmpNameC.append(str, nameStart, nameEnd-nameStart );
                tmpValueC.append(str, valStart, valEnd-valStart );
            
                if( debug > 0 )
                    log( tmpNameC + "= " + tmpValueC);

                if( urlDec==null ) {
                    urlDec=new UDecoder();   
                }

                urlDec.convert( tmpNameC );
                urlDec.convert( tmpValueC );

                if( debug > 0 )
                    log( tmpNameC + "= " + tmpValueC);
                
                addParam( tmpNameC.toString(), tmpValueC.toString() );
            } catch( IOException ex ) {
                ex.printStackTrace();
            }

            tmpNameC.recycle();
            tmpValueC.recycle();

        } while( pos<end );
    }
FIXED VERSION:


    public void processParameters( MessageBytes data, String encoding ) {
        if( data==null || data.isNull() || data.getLength() <= 0 ) return;

        if( data.getType() != MessageBytes.T_BYTES ) {
            data.toBytes();
        }
        ByteChunk bc=data.getByteChunk();
        processParameters( bc.getBytes(), bc.getOffset(),
                           bc.getLength(), getCharset(encoding));
    }
================================================================================
Method: if
VULNERABLE VERSION:
 recursive
        if( debug > 0 ) {
            log("Before merging " + this + " " + parent + " " + didMerge );
            log(  paramsAsString());
        }
FIXED VERSION:
 else if (valueStart > -1 && valueEnd == -1){
                    valueEnd = pos;
                }
================================================================================
Method: paramsAsString
VULNERABLE VERSION:

    public String paramsAsString() {
        StringBuffer sb=new StringBuffer();
        Enumeration en= paramHashStringArray.keys();
        while( en.hasMoreElements() ) {
            String k=(String)en.nextElement();
            sb.append( k ).append("=");
            String v[]=(String[])paramHashStringArray.get( k );
            for( int i=0; i<v.length; i++ )
                sb.append( v[i] ).append(",");
            sb.append("\n");
        }
        return sb.toString();
    }
FIXED VERSION:

    public String paramsAsString() {
        StringBuffer sb = new StringBuffer();
        Iterator it = paramHashValues.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry e = (Map.Entry) it.next();
            sb.append(e.getKey()).append('=');
            ArrayList values = (ArrayList) e.getValue();
            for(int i = 0; i < values.size(); i++) {
                sb.append(values.get(i)).append(',');
            }
            sb.append('\n');
        }
        return sb.toString();
    }
================================================================================
