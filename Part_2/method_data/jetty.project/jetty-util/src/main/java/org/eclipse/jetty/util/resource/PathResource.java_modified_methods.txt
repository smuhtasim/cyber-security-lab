Method: checkAliasPath
VULNERABLE VERSION:
 Path checkAliasPath(final Path path)
    {
        Path abs = path;
        if (!abs.isAbsolute())
        {
            abs = path.toAbsolutePath();
        }

        try
        {
            if (Files.isSymbolicLink(path))
                return Files.readSymbolicLink(path);
            if (Files.exists(path))
            {
                Path real = abs.toRealPath(FOLLOW_LINKS);
                
                /*
                 * If the real path is not the same as the absolute path
                 * then we know that the real path is the alias for the
                 * provided path.
                 *
                 * For OS's that are case insensitive, this should
                 * return the real (on-disk / case correct) version
                 * of the path.
                 *
                 * We have to be careful on Windows and OSX.
                 * 
                 * Assume we have the following scenario
                 *   Path a = new File("foo").toPath();
                 *   Files.createFile(a);
                 *   Path b = new File("FOO").toPath();
                 * 
                 * There now exists a file called "foo" on disk.
                 * Using Windows or OSX, with a Path reference of
                 * "FOO", "Foo", "fOO", etc.. means the following
                 * 
                 *                        |  OSX    |  Windows   |  Linux
                 * -----------------------+---------+------------+---------
                 * Files.exists(a)        |  True   |  True      |  True
                 * Files.exists(b)        |  True   |  True      |  False
                 * Files.isSameFile(a,b)  |  True   |  True      |  False
                 * a.equals(b)            |  False  |  True      |  False
                 * 
                 * See the javadoc for Path.equals() for details about this FileSystem
                 * behavior difference
                 * 
                 * We also cannot rely on a.compareTo(b) as this is roughly equivalent
                 * in implementation to a.equals(b)
                 */
                
                int absCount = abs.getNameCount();
                int realCount = real.getNameCount();
                if (absCount != realCount)
                {
                    // different number of segments
                    return real;
                }
                
                // compare each segment of path, backwards
                for (int i = realCount-1; i >= 0; i--)
                {
                    if (!abs.getName(i).toString().equals(real.getName(i).toString()))
                    {
                        return real;
                    }
                }
            }
        }
        catch (IOException e)
        {
            LOG.ignore(e);
        }
        catch (Exception e)
        {
            LOG.warn("bad alias ({} {}) for {}", e.getClass().getName(), e.getMessage(),path);
        }
        return null;
    }
FIXED VERSION:
 Path checkAliasPath()
    {
        Path abs = path;

        /* Catch situation where the Path class has already normalized
         * the URI eg. input path "aa./foo.txt"
         * from an #addPath(String) is normalized away during
         * the creation of a Path object reference.
         * If the URI is different then the Path.toUri() then
         * we will just use the original URI to construct the
         * alias reference Path.
         */

        if(!URIUtil.equalsIgnoreEncodings(uri,path.toUri()))
        {
            return new File(uri).toPath().toAbsolutePath();
        }

        if (!abs.isAbsolute())
        {
            abs = path.toAbsolutePath();
        }

        try
        {
            if (Files.isSymbolicLink(path))
                return Files.readSymbolicLink(path);
            if (Files.exists(path))
            {
                Path real = abs.toRealPath(FOLLOW_LINKS);
                
                /*
                 * If the real path is not the same as the absolute path
                 * then we know that the real path is the alias for the
                 * provided path.
                 *
                 * For OS's that are case insensitive, this should
                 * return the real (on-disk / case correct) version
                 * of the path.
                 *
                 * We have to be careful on Windows and OSX.
                 * 
                 * Assume we have the following scenario
                 *   Path a = new File("foo").toPath();
                 *   Files.createFile(a);
                 *   Path b = new File("FOO").toPath();
                 * 
                 * There now exists a file called "foo" on disk.
                 * Using Windows or OSX, with a Path reference of
                 * "FOO", "Foo", "fOO", etc.. means the following
                 * 
                 *                        |  OSX    |  Windows   |  Linux
                 * -----------------------+---------+------------+---------
                 * Files.exists(a)        |  True   |  True      |  True
                 * Files.exists(b)        |  True   |  True      |  False
                 * Files.isSameFile(a,b)  |  True   |  True      |  False
                 * a.equals(b)            |  False  |  True      |  False
                 * 
                 * See the javadoc for Path.equals() for details about this FileSystem
                 * behavior difference
                 * 
                 * We also cannot rely on a.compareTo(b) as this is roughly equivalent
                 * in implementation to a.equals(b)
                 */
                
                int absCount = abs.getNameCount();
                int realCount = real.getNameCount();
                if (absCount != realCount)
                {
                    // different number of segments
                    return real;
                }
                
                // compare each segment of path, backwards
                for (int i = realCount-1; i >= 0; i--)
                {
                    if (!abs.getName(i).toString().equals(real.getName(i).toString()))
                    {
                        return real;
                    }
                }
            }
        }
        catch (IOException e)
        {
            LOG.ignore(e);
        }
        catch (Exception e)
        {
            LOG.warn("bad alias ({} {}) for {}", e.getClass().getName(), e.getMessage(),path);
        }
        return null;
    }
================================================================================
Method: PathResource
VULNERABLE VERSION:

    public PathResource(Path path)
    {
        this.path = path.toAbsolutePath();
        assertValidPath(path);
        this.uri = this.path.toUri();
        this.alias = checkAliasPath(path);
    }
FIXED VERSION:

    public PathResource(Path path)
    {
        this.path = path.toAbsolutePath();
        assertValidPath(path);
        this.uri = this.path.toUri();
        this.alias = checkAliasPath();
    }
================================================================================
