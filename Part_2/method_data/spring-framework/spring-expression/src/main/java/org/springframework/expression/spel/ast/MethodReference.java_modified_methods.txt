Method: updateExitTypeDescriptor
VULNERABLE VERSION:


	private void updateExitTypeDescriptor() {
		CachedMethodExecutor executorToCheck = this.cachedExecutor;
		if (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor) {
			Method method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();
			this.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());
		}
	}
FIXED VERSION:


	private void updateExitTypeDescriptor() {
		CachedMethodExecutor executorToCheck = this.cachedExecutor;
		if (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor) {
			Method method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();
			String descriptor = CodeFlow.toDescriptor(method.getReturnType());
			if (this.nullSafe && CodeFlow.isPrimitive(descriptor)) {
				originalPrimitiveExitTypeDescriptor = descriptor;
				this.exitTypeDescriptor = CodeFlow.toBoxedDescriptor(descriptor);
			}
			else {
				this.exitTypeDescriptor = descriptor;
			}
		}
	}
================================================================================
Method: generateCode
VULNERABLE VERSION:

	public void generateCode(MethodVisitor mv, CodeFlow cf) {
		CachedMethodExecutor executorToCheck = this.cachedExecutor;
		if (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {
			throw new IllegalStateException("No applicable cached executor found: " + executorToCheck);
		}

		ReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get();
		Method method = methodExecutor.getMethod();
		boolean isStaticMethod = Modifier.isStatic(method.getModifiers());
		String descriptor = cf.lastDescriptor();

		if (descriptor == null) {
			if (!isStaticMethod) {
				// Nothing on the stack but something is needed
				cf.loadTarget(mv);
			}
		}
		else {
			if (isStaticMethod) {
				// Something on the stack when nothing is needed
				mv.visitInsn(POP);
			}
		}
		
		if (CodeFlow.isPrimitive(descriptor)) {
			CodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));
		}

		String classDesc = null;
		if (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {
			classDesc = method.getDeclaringClass().getName().replace('.', '/');
		}
		else {
			Class<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass();
			Assert.state(publicDeclaringClass != null, "No public declaring class");
			classDesc = publicDeclaringClass.getName().replace('.', '/');
		}

		if (!isStaticMethod) {
			if (descriptor == null || !descriptor.substring(1).equals(classDesc)) {
				CodeFlow.insertCheckCast(mv, "L" + classDesc);
			}
		}

		generateCodeForArguments(mv, cf, method, this.children);
		mv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),
				CodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());
		cf.pushDescriptor(this.exitTypeDescriptor);
	}
FIXED VERSION:

	public void generateCode(MethodVisitor mv, CodeFlow cf) {
		CachedMethodExecutor executorToCheck = this.cachedExecutor;
		if (executorToCheck == null || !(executorToCheck.get() instanceof ReflectiveMethodExecutor)) {
			throw new IllegalStateException("No applicable cached executor found: " + executorToCheck);
		}

		ReflectiveMethodExecutor methodExecutor = (ReflectiveMethodExecutor) executorToCheck.get();
		Method method = methodExecutor.getMethod();
		boolean isStaticMethod = Modifier.isStatic(method.getModifiers());
		String descriptor = cf.lastDescriptor();

		Label skipIfNull = null;
		if (descriptor == null && !isStaticMethod) {
			// Nothing on the stack but something is needed
			cf.loadTarget(mv);
		}
		if ((descriptor != null || !isStaticMethod) && nullSafe) {
			mv.visitInsn(DUP);
			skipIfNull = new Label();
			Label continueLabel = new Label();
			mv.visitJumpInsn(IFNONNULL,continueLabel);
			CodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);
			mv.visitJumpInsn(GOTO, skipIfNull);
			mv.visitLabel(continueLabel);
		}
		if (descriptor != null && isStaticMethod) {
			// Something on the stack when nothing is needed
			mv.visitInsn(POP);
		}
		
		if (CodeFlow.isPrimitive(descriptor)) {
			CodeFlow.insertBoxIfNecessary(mv, descriptor.charAt(0));
		}

		String classDesc = null;
		if (Modifier.isPublic(method.getDeclaringClass().getModifiers())) {
			classDesc = method.getDeclaringClass().getName().replace('.', '/');
		}
		else {
			Class<?> publicDeclaringClass = methodExecutor.getPublicDeclaringClass();
			Assert.state(publicDeclaringClass != null, "No public declaring class");
			classDesc = publicDeclaringClass.getName().replace('.', '/');
		}

		if (!isStaticMethod) {
			if (descriptor == null || !descriptor.substring(1).equals(classDesc)) {
				CodeFlow.insertCheckCast(mv, "L" + classDesc);
			}
		}

		generateCodeForArguments(mv, cf, method, this.children);
		mv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),
				CodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());
		cf.pushDescriptor(this.exitTypeDescriptor);
		if (originalPrimitiveExitTypeDescriptor != null) {
			// The output of the accessor will be a primitive but from the block above it might be null,
			// so to have a 'common stack' element at skipIfNull target we need to box the primitive
			CodeFlow.insertBoxIfNecessary(mv, originalPrimitiveExitTypeDescriptor);
		}
		if (skipIfNull != null) {
			mv.visitLabel(skipIfNull);
		}
	}
================================================================================
